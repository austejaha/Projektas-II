\hypertarget{catch_8hpp_source}{}\doxysection{catch.\+hpp}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ *  Catch v2.13.7}}
\DoxyCodeLine{3 \textcolor{comment}{ *  Generated: 2021-\/07-\/28 20:29:27.753164}}
\DoxyCodeLine{4 \textcolor{comment}{ *  -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{5 \textcolor{comment}{ *  This file has been merged from multiple headers. Please don't edit it directly}}
\DoxyCodeLine{6 \textcolor{comment}{ *  Copyright (c) 2021 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{7 \textcolor{comment}{ *}}
\DoxyCodeLine{8 \textcolor{comment}{ *  Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{9 \textcolor{comment}{ *  file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{10 \textcolor{comment}{ */}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{13 \textcolor{comment}{// start catch.hpp}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MAJOR 2}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#define CATCH\_VERSION\_MINOR 13}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#define CATCH\_VERSION\_PATCH 7}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#    pragma clang system\_header}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#    pragma GCC system\_header}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{// start catch\_suppress\_warnings.h}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#   ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#       pragma warning(push)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#       pragma warning(disable: 161 1682)}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#   else }\textcolor{comment}{// \_\_ICC}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#       pragma clang diagnostic push}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wswitch-\/enum"{}}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#       pragma clang diagnostic ignored "{}-\/Wcovered-\/switch-\/default"{}}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{39      \textcolor{comment}{// Because REQUIREs trigger GCC's -\/Wparentheses, and because still}}
\DoxyCodeLine{40      \textcolor{comment}{// supported version of g++ have only buggy support for \_Pragmas,}}
\DoxyCodeLine{41      \textcolor{comment}{// Wparentheses have to be suppressed globally.}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wparentheses"{}} \textcolor{comment}{// See \#674 for details}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wunused-\/variable"{}}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 \textcolor{comment}{// end catch\_suppress\_warnings.h}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_MAIN) || defined(CATCH\_CONFIG\_RUNNER)}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#  define CATCH\_IMPL}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ALL\_PARTS}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 \textcolor{comment}{// In the impl file, we want to have access to all parts of the headers}}
\DoxyCodeLine{55 \textcolor{comment}{// Can also be used to sanely support PCHs}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ALL\_PARTS)}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_EXTERNAL\_INTERFACES}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#  if defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#    undef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#  if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{67 \textcolor{comment}{// start catch\_platform.h}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{comment}{// See e.g.:}}
\DoxyCodeLine{70 \textcolor{comment}{// https://opensource.apple.com/source/CarbonHeaders/CarbonHeaders-\/18.1/TargetConditionals.h.auto.html}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#ifdef \_\_APPLE\_\_}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#  include <TargetConditionals.h>}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#  if (defined(TARGET\_OS\_OSX) \&\& TARGET\_OS\_OSX == 1) || \(\backslash\)}}
\DoxyCodeLine{74 \textcolor{preprocessor}{      (defined(TARGET\_OS\_MAC) \&\& TARGET\_OS\_MAC == 1)}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#    define CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#  elif (defined(TARGET\_OS\_IPHONE) \&\& TARGET\_OS\_IPHONE == 1)}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#    define CATCH\_PLATFORM\_IPHONE}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{79 }
\DoxyCodeLine{80 \textcolor{preprocessor}{\#elif defined(linux) || defined(\_\_linux) || defined(\_\_linux\_\_)}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_LINUX}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83 \textcolor{preprocessor}{\#elif defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) || defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#  define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{comment}{// end catch\_platform.h}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#  ifndef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#    define CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 \textcolor{comment}{// start catch\_user\_interfaces.h}}
\DoxyCodeLine{97 }
\DoxyCodeLine{98 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{99     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{100 \}}
\DoxyCodeLine{101 }
\DoxyCodeLine{102 \textcolor{comment}{// end catch\_user\_interfaces.h}}
\DoxyCodeLine{103 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{comment}{// start catch\_common.h}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{comment}{// start catch\_compiler\_capabilities.h}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{comment}{// Detect a number of compiler features -\/ by compiler}}
\DoxyCodeLine{110 \textcolor{comment}{// The following features are defined:}}
\DoxyCodeLine{111 \textcolor{comment}{//}}
\DoxyCodeLine{112 \textcolor{comment}{// CATCH\_CONFIG\_COUNTER : is the \_\_COUNTER\_\_ macro supported?}}
\DoxyCodeLine{113 \textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH : is Windows SEH supported?}}
\DoxyCodeLine{114 \textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS : are POSIX signals supported?}}
\DoxyCodeLine{115 \textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_EXCEPTIONS : Are exceptions enabled?}}
\DoxyCodeLine{116 \textcolor{comment}{// ****************}}
\DoxyCodeLine{117 \textcolor{comment}{// Note to maintainers: if new toggles are added please document them}}
\DoxyCodeLine{118 \textcolor{comment}{// in configuration.md, too}}
\DoxyCodeLine{119 \textcolor{comment}{// ****************}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{comment}{// In general each macro has a \_NO\_<feature name> form}}
\DoxyCodeLine{122 \textcolor{comment}{// (e.g. CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) which disables the feature.}}
\DoxyCodeLine{123 \textcolor{comment}{// Many features, at point of detection, define an \_INTERNAL\_ macro, so they}}
\DoxyCodeLine{124 \textcolor{comment}{// can be combined, en-\/mass, with the \_NO\_ forms later.}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{preprocessor}{\#ifdef \_\_cplusplus}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201402L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201402L)}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#    define CATCH\_CPP14\_OR\_GREATER}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{131 }
\DoxyCodeLine{132 \textcolor{preprocessor}{\#  if (\_\_cplusplus >= 201703L) || (defined(\_MSVC\_LANG) \&\& \_MSVC\_LANG >= 201703L)}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#    define CATCH\_CPP17\_OR\_GREATER}}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{comment}{// Only GCC compiler should be used in this block, so other compilers trying to}}
\DoxyCodeLine{139 \textcolor{comment}{// mask themselves as GCC should be ignored.}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& !defined(\_\_ICC) \&\& !defined(\_\_CUDACC\_\_) \&\& !defined(\_\_LCC\_\_)}}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}GCC diagnostic push"{}} )}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}GCC diagnostic pop"{}} )}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_Pragma( "{}clang diagnostic push"{}} )}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_Pragma( "{}clang diagnostic pop"{}} )}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{comment}{// As of this writing, IBM XL's implementation of \_\_builtin\_constant\_p has a bug}}
\DoxyCodeLine{154 \textcolor{comment}{// which results in calls to destructors being emitted for each temporary,}}
\DoxyCodeLine{155 \textcolor{comment}{// without a matching initialization. In practice, this can result in something}}
\DoxyCodeLine{156 \textcolor{comment}{// like `std::string::\string~string` being called on an uninitialized value.}}
\DoxyCodeLine{157 \textcolor{comment}{//}}
\DoxyCodeLine{158 \textcolor{comment}{// For example, this code will likely segfault under IBM XL:}}
\DoxyCodeLine{159 \textcolor{comment}{// ```}}
\DoxyCodeLine{160 \textcolor{comment}{// REQUIRE(std::string("{}12"{}) + "{}34"{} == "{}1234"{})}}
\DoxyCodeLine{161 \textcolor{comment}{// ```}}
\DoxyCodeLine{162 \textcolor{comment}{//}}
\DoxyCodeLine{163 \textcolor{comment}{// Therefore, `CATCH\_INTERNAL\_IGNORE\_BUT\_WARN` is not implemented.}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#  if !defined(\_\_ibmxl\_\_) \&\& !defined(\_\_CUDACC\_\_)}}
\DoxyCodeLine{165 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...) (void)\_\_builtin\_constant\_p(\_\_VA\_ARGS\_\_) }\textcolor{comment}{/* NOLINT(cppcoreguidelines-\/pro-\/type-\/vararg, hicpp-\/vararg) */}\textcolor{preprocessor}{}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{169 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wexit-\/time-\/destructors\(\backslash\)"{}"{}} ) \(\backslash\)}
\DoxyCodeLine{170          \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wglobal-\/constructors\(\backslash\)"{}"{})}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{173 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wparentheses\(\backslash\)"{}"{}} )}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{176 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/variable\(\backslash\)"{}"{}} )}
\DoxyCodeLine{177 }
\DoxyCodeLine{178 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wgnu-\/zero-\/variadic-\/macro-\/arguments\(\backslash\)"{}"{}} )}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{182 \textcolor{preprocessor}{         \_Pragma( "{}clang diagnostic ignored \(\backslash\)"{}-\/Wunused-\/template\(\backslash\)"{}"{}} )}
\DoxyCodeLine{183 }
\DoxyCodeLine{184 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{185 }
\DoxyCodeLine{187 \textcolor{comment}{// Assume that non-\/Windows platforms support posix signals by default}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{189 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{191 }
\DoxyCodeLine{193 \textcolor{comment}{// We know some environments not to support full POSIX signals}}
\DoxyCodeLine{194 \textcolor{preprocessor}{\#if defined(\_\_CYGWIN\_\_) || defined(\_\_QNX\_\_) || defined(\_\_EMSCRIPTEN\_\_) || defined(\_\_DJGPP\_\_)}}
\DoxyCodeLine{195 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{197 }
\DoxyCodeLine{198 \textcolor{preprocessor}{\#ifdef \_\_OS400\_\_}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#       define CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{202 }
\DoxyCodeLine{204 \textcolor{comment}{// Android somehow still does not support std::to\_string}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#if defined(\_\_ANDROID\_\_)}}
\DoxyCodeLine{206 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{209 }
\DoxyCodeLine{211 \textcolor{comment}{// Not all Windows environments support SEH properly}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#if defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{215 }
\DoxyCodeLine{217 \textcolor{comment}{// PS4}}
\DoxyCodeLine{218 \textcolor{preprocessor}{\#if defined(\_\_ORBIS\_\_)}}
\DoxyCodeLine{219 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE}}
\DoxyCodeLine{220 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{221 }
\DoxyCodeLine{223 \textcolor{comment}{// Cygwin}}
\DoxyCodeLine{224 \textcolor{preprocessor}{\#ifdef \_\_CYGWIN\_\_}}
\DoxyCodeLine{225 }
\DoxyCodeLine{226 \textcolor{comment}{// Required for some versions of Cygwin to declare gettimeofday}}
\DoxyCodeLine{227 \textcolor{comment}{// see: http://stackoverflow.com/questions/36901803/gettimeofday-\/not-\/declared-\/in-\/this-\/scope-\/cygwin}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#   define \_BSD\_SOURCE}}
\DoxyCodeLine{229 \textcolor{comment}{// some versions of cygwin (most) do not support std::to\_string. Use the libstd check.}}
\DoxyCodeLine{230 \textcolor{comment}{// https://gcc.gnu.org/onlinedocs/gcc-\/4.8.2/libstdc++/api/a01053\_source.html line 2812-\/2813}}
\DoxyCodeLine{231 \textcolor{preprocessor}{\# if !((\_\_cplusplus >= 201103L) \&\& defined(\_GLIBCXX\_USE\_C99) \(\backslash\)}}
\DoxyCodeLine{232 \textcolor{preprocessor}{           \&\& !defined(\_GLIBCXX\_HAVE\_BROKEN\_VSWPRINTF))}}
\DoxyCodeLine{233 }
\DoxyCodeLine{234 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING}}
\DoxyCodeLine{235 }
\DoxyCodeLine{236 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{237 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_CYGWIN\_\_}}
\DoxyCodeLine{238 }
\DoxyCodeLine{240 \textcolor{comment}{// Visual C++}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \_\_pragma( warning(push) )}}
\DoxyCodeLine{244 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION  \_\_pragma( warning(pop) )}}
\DoxyCodeLine{245 }
\DoxyCodeLine{246 \textcolor{comment}{// Universal Windows platform does not support SEH}}
\DoxyCodeLine{247 \textcolor{comment}{// Or console colours (or console at all...)}}
\DoxyCodeLine{248 \textcolor{preprocessor}{\#  if defined(WINAPI\_FAMILY) \&\& (WINAPI\_FAMILY == WINAPI\_FAMILY\_APP)}}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{250 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{251 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{252 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254 \textcolor{comment}{// MSVC traditional preprocessor needs some workaround for \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{255 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 0 means new conformant preprocessor}}
\DoxyCodeLine{256 \textcolor{comment}{// \_MSVC\_TRADITIONAL == 1 means old traditional non-\/conformant preprocessor}}
\DoxyCodeLine{257 \textcolor{preprocessor}{\#  if !defined(\_\_clang\_\_) }\textcolor{comment}{// Handle Clang masquerading for msvc}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#    if !defined(\_MSVC\_TRADITIONAL) || (defined(\_MSVC\_TRADITIONAL) \&\& \_MSVC\_TRADITIONAL)}}
\DoxyCodeLine{259 \textcolor{preprocessor}{\#      define CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#    endif }\textcolor{comment}{// MSVC\_TRADITIONAL}}
\DoxyCodeLine{261 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// \_\_clang\_\_}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{264 }
\DoxyCodeLine{265 \textcolor{preprocessor}{\#if defined(\_REENTRANT) || defined(\_MSC\_VER)}}
\DoxyCodeLine{266 \textcolor{comment}{// Enable async processing, as -\/pthread is specified or no additional linking is required}}
\DoxyCodeLine{267 \textcolor{preprocessor}{\# define CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{268 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_MSC\_VER}}
\DoxyCodeLine{269 }
\DoxyCodeLine{271 \textcolor{comment}{// Check if we are compiled with -\/fno-\/exceptions or equivalent}}
\DoxyCodeLine{272 \textcolor{preprocessor}{\#if defined(\_\_EXCEPTIONS) || defined(\_\_cpp\_exceptions) || defined(\_CPPUNWIND)}}
\DoxyCodeLine{273 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED}}
\DoxyCodeLine{274 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{275 }
\DoxyCodeLine{277 \textcolor{comment}{// DJGPP}}
\DoxyCodeLine{278 \textcolor{preprocessor}{\#ifdef \_\_DJGPP\_\_}}
\DoxyCodeLine{279 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR}}
\DoxyCodeLine{280 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_DJGPP\_\_}}
\DoxyCodeLine{281 }
\DoxyCodeLine{283 \textcolor{comment}{// Embarcadero C++Build}}
\DoxyCodeLine{284 \textcolor{preprocessor}{\#if defined(\_\_BORLANDC\_\_)}}
\DoxyCodeLine{285 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{286 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{287 }
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{comment}{// Use of \_\_COUNTER\_\_ is suppressed during code analysis in}}
\DoxyCodeLine{291 \textcolor{comment}{// CLion/AppCode 2017.2.x and former, because \_\_COUNTER\_\_ is not properly}}
\DoxyCodeLine{292 \textcolor{comment}{// handled by it.}}
\DoxyCodeLine{293 \textcolor{comment}{// Otherwise all supported compilers support COUNTER macro,}}
\DoxyCodeLine{294 \textcolor{comment}{// but user still might want to turn it off}}
\DoxyCodeLine{295 \textcolor{preprocessor}{\#if ( !defined(\_\_JETBRAINS\_IDE\_\_) || \_\_JETBRAINS\_IDE\_\_ >= 20170300L )}}
\DoxyCodeLine{296 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_COUNTER}}
\DoxyCodeLine{297 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{298 }
\DoxyCodeLine{300 }
\DoxyCodeLine{301 \textcolor{comment}{// RTX is a special version of Windows that is real time.}}
\DoxyCodeLine{302 \textcolor{comment}{// This means that it is detected as Windows, but does not provide}}
\DoxyCodeLine{303 \textcolor{comment}{// the same set of capabilities as real Windows does.}}
\DoxyCodeLine{304 \textcolor{preprocessor}{\#if defined(UNDER\_RTSS) || defined(RTX64\_BUILD)}}
\DoxyCodeLine{305 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH}}
\DoxyCodeLine{306 \textcolor{preprocessor}{    \#define CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC}}
\DoxyCodeLine{307 \textcolor{preprocessor}{    \#define CATCH\_CONFIG\_COLOUR\_NONE}}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{309 }
\DoxyCodeLine{310 \textcolor{preprocessor}{\#if !defined(\_GLIBCXX\_USE\_C99\_MATH\_TR1)}}
\DoxyCodeLine{311 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{312 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{comment}{// Various stdlib support checks that require \_\_has\_include}}
\DoxyCodeLine{315 \textcolor{preprocessor}{\#if defined(\_\_has\_include)}}
\DoxyCodeLine{316   \textcolor{comment}{// Check if string\_view is available and usable}}
\DoxyCodeLine{317 \textcolor{preprocessor}{  \#if \_\_has\_include(<string\_view>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{318 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{319 \textcolor{preprocessor}{  \#endif}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321   \textcolor{comment}{// Check if optional is available and usable}}
\DoxyCodeLine{322 \textcolor{preprocessor}{  \#  if \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{323 \textcolor{preprocessor}{  \#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{324 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<optional>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326   \textcolor{comment}{// Check if byte is available and usable}}
\DoxyCodeLine{327 \textcolor{preprocessor}{  \#  if \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{328 \textcolor{preprocessor}{  \#    include <cstddef>}}
\DoxyCodeLine{329 \textcolor{preprocessor}{  \#    if defined(\_\_cpp\_lib\_byte) \&\& (\_\_cpp\_lib\_byte > 0)}}
\DoxyCodeLine{330 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{331 \textcolor{preprocessor}{  \#    endif}}
\DoxyCodeLine{332 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<cstddef>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \textcolor{comment}{// Check if variant is available and usable}}
\DoxyCodeLine{335 \textcolor{preprocessor}{  \#  if \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{336 \textcolor{preprocessor}{  \#    if defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{337          \textcolor{comment}{// work around clang bug with libstdc++ https://bugs.llvm.org/show\_bug.cgi?id=31852}}
\DoxyCodeLine{338          \textcolor{comment}{// fix should be in clang 8, workaround in libstdc++ 8.2}}
\DoxyCodeLine{339 \textcolor{preprocessor}{  \#      include <ciso646>}}
\DoxyCodeLine{340 \textcolor{preprocessor}{  \#      if defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{341 \textcolor{preprocessor}{  \#        define CATCH\_CONFIG\_NO\_CPP17\_VARIANT}}
\DoxyCodeLine{342 \textcolor{preprocessor}{  \#      else}}
\DoxyCodeLine{343 \textcolor{preprocessor}{  \#        define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{344 \textcolor{preprocessor}{  \#      endif }\textcolor{comment}{// defined(\_\_GLIBCXX\_\_) \&\& defined(\_GLIBCXX\_RELEASE) \&\& (\_GLIBCXX\_RELEASE < 9)}}
\DoxyCodeLine{345 \textcolor{preprocessor}{  \#    else}}
\DoxyCodeLine{346 \textcolor{preprocessor}{  \#      define CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{347 \textcolor{preprocessor}{  \#    endif }\textcolor{comment}{// defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 8)}}
\DoxyCodeLine{348 \textcolor{preprocessor}{  \#  endif }\textcolor{comment}{// \_\_has\_include(<variant>) \&\& defined(CATCH\_CPP17\_OR\_GREATER)}}
\DoxyCodeLine{349 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(\_\_has\_include)}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_COUNTER) \&\& !defined(CATCH\_CONFIG\_NO\_COUNTER) \&\& !defined(CATCH\_CONFIG\_COUNTER)}}
\DoxyCodeLine{352 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{354 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_NO\_WINDOWS\_SEH) \&\& !defined(CATCH\_CONFIG\_WINDOWS\_SEH) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WINDOWS\_SEH)}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{356 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{357 \textcolor{comment}{// This is set by default, because we assume that unix compilers are posix-\/signal-\/compatible by default.}}
\DoxyCodeLine{358 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POSIX\_SIGNALS) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_NO\_POSIX\_SIGNALS) \&\& !defined(CATCH\_CONFIG\_POSIX\_SIGNALS)}}
\DoxyCodeLine{359 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{360 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{361 \textcolor{comment}{// This is set by default, because we assume that compilers with no wchar\_t support are just rare exceptions.}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_NO\_WCHAR) \&\& !defined(CATCH\_CONFIG\_WCHAR)}}
\DoxyCodeLine{363 \textcolor{preprocessor}{\#   define CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_NO\_CPP11\_TO\_STRING) \&\& !defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{367 \textcolor{preprocessor}{\#    define CATCH\_CONFIG\_CPP11\_TO\_STRING}}
\DoxyCodeLine{368 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{369 }
\DoxyCodeLine{370 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_OPTIONAL) \&\& !defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{371 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_OPTIONAL}}
\DoxyCodeLine{372 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{373 }
\DoxyCodeLine{374 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_STRING\_VIEW) \&\& !defined(CATCH\_CONFIG\_CPP17\_STRING\_VIEW)}}
\DoxyCodeLine{375 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{376 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_VARIANT) \&\& !defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{379 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_VARIANT}}
\DoxyCodeLine{380 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{381 }
\DoxyCodeLine{382 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_BYTE) \&\& !defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{383 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_BYTE}}
\DoxyCodeLine{384 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{385 }
\DoxyCodeLine{386 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{387 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_NEW\_CAPTURE) \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NO\_NEW\_CAPTURE) \&\& !defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{391 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{392 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{393 }
\DoxyCodeLine{394 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_CONFIG\_EXCEPTIONS\_ENABLED) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{395 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_DISABLE\_EXCEPTIONS}}
\DoxyCodeLine{396 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_NO\_POLYFILL\_ISNAN) \&\& !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{399 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_POLYFILL\_ISNAN}}
\DoxyCodeLine{400 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{401 }
\DoxyCodeLine{402 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_USE\_ASYNC)  \&\& !defined(CATCH\_INTERNAL\_CONFIG\_NO\_ASYNC) \&\& !defined(CATCH\_CONFIG\_NO\_USE\_ASYNC) \&\& !defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{403 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_USE\_ASYNC}}
\DoxyCodeLine{404 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{405 }
\DoxyCodeLine{406 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_NO\_ANDROID\_LOGWRITE) \&\& !defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{407 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ANDROID\_LOGWRITE}}
\DoxyCodeLine{408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_NO\_GLOBAL\_NEXTAFTER) \&\& !defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{411 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_GLOBAL\_NEXTAFTER}}
\DoxyCodeLine{412 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{413 }
\DoxyCodeLine{414 \textcolor{comment}{// Even if we do not think the compiler has that warning, we still have}}
\DoxyCodeLine{415 \textcolor{comment}{// to provide a macro that can be used by the code.}}
\DoxyCodeLine{416 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{417 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{418 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{419 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION)}}
\DoxyCodeLine{420 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{421 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{422 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS)}}
\DoxyCodeLine{423 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS}}
\DoxyCodeLine{424 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{425 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS)}}
\DoxyCodeLine{426 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}}
\DoxyCodeLine{427 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{428 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS)}}
\DoxyCodeLine{429 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS}}
\DoxyCodeLine{430 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{431 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS)}}
\DoxyCodeLine{432 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS}}
\DoxyCodeLine{433 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{434 }
\DoxyCodeLine{435 \textcolor{comment}{// The goal of this macro is to avoid evaluation of the arguments, but}}
\DoxyCodeLine{436 \textcolor{comment}{// still have the compiler warn on problems inside...}}
\DoxyCodeLine{437 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_IGNORE\_BUT\_WARN)}}
\DoxyCodeLine{438 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(...)}}
\DoxyCodeLine{439 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{440 }
\DoxyCodeLine{441 \textcolor{preprocessor}{\#if defined(\_\_APPLE\_\_) \&\& defined(\_\_apple\_build\_version\_\_) \&\& (\_\_clang\_major\_\_ < 10)}}
\DoxyCodeLine{442 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{443 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_) \&\& (\_\_clang\_major\_\_ < 5)}}
\DoxyCodeLine{444 \textcolor{preprocessor}{\#   undef CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{445 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{preprocessor}{\#if !defined(CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS)}}
\DoxyCodeLine{448 \textcolor{preprocessor}{\#   define CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS}}
\DoxyCodeLine{449 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{452 \textcolor{preprocessor}{\#define CATCH\_TRY if ((true))}}
\DoxyCodeLine{453 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL if ((false))}}
\DoxyCodeLine{454 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) if ((false))}}
\DoxyCodeLine{455 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{456 \textcolor{preprocessor}{\#define CATCH\_TRY try}}
\DoxyCodeLine{457 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ALL catch (...)}}
\DoxyCodeLine{458 \textcolor{preprocessor}{\#define CATCH\_CATCH\_ANON(type) catch (type)}}
\DoxyCodeLine{459 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{460 }
\DoxyCodeLine{461 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_NO\_TRADITIONAL\_MSVC\_PREPROCESSOR) \&\& !defined(CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR)}}
\DoxyCodeLine{462 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{463 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{464 }
\DoxyCodeLine{465 \textcolor{comment}{// end catch\_compiler\_capabilities.h}}
\DoxyCodeLine{466 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line ) name\#\#line}}
\DoxyCodeLine{467 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, line ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE2( name, line )}}
\DoxyCodeLine{468 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_COUNTER}}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_COUNTER\_\_ )}}
\DoxyCodeLine{470 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{471 \textcolor{preprocessor}{\#  define INTERNAL\_CATCH\_UNIQUE\_NAME( name ) INTERNAL\_CATCH\_UNIQUE\_NAME\_LINE( name, \_\_LINE\_\_ )}}
\DoxyCodeLine{472 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{475 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{476 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{477 }
\DoxyCodeLine{478 \textcolor{comment}{// We need a dummy global operator<< so we can bring it into Catch namespace later}}
\DoxyCodeLine{479 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}} \{\};}
\DoxyCodeLine{480 std::ostream\& operator<<(std::ostream\&, \mbox{\hyperlink{struct_catch__global__namespace__dummy}{Catch\_global\_namespace\_dummy}});}
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{483 }
\DoxyCodeLine{484     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_case_sensitive}{CaseSensitive}} \{ \textcolor{keyword}{enum} Choice \{}
\DoxyCodeLine{485         Yes,}
\DoxyCodeLine{486         No}
\DoxyCodeLine{487     \}; \};}
\DoxyCodeLine{488 }
\DoxyCodeLine{489     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{490         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \textcolor{keyword}{const}\& )              = \textcolor{keyword}{delete};}
\DoxyCodeLine{491         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \&\& )                  = \textcolor{keyword}{delete};}
\DoxyCodeLine{492         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{493         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{494 }
\DoxyCodeLine{495     \textcolor{keyword}{protected}:}
\DoxyCodeLine{496         \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}}();}
\DoxyCodeLine{497         \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_non_copyable}{\string~NonCopyable}}();}
\DoxyCodeLine{498     \};}
\DoxyCodeLine{499 }
\DoxyCodeLine{500     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \{}
\DoxyCodeLine{501 }
\DoxyCodeLine{502         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{503         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \_file, std::size\_t \_line ) noexcept}
\DoxyCodeLine{504         :   file( \_file ),}
\DoxyCodeLine{505             line( \_line )}
\DoxyCodeLine{506         \{\}}
\DoxyCodeLine{507 }
\DoxyCodeLine{508         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other )            = \textcolor{keywordflow}{default};}
\DoxyCodeLine{509         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{510         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\&\& )              \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{511         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\& operator = ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}}\&\& ) \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{512 }
\DoxyCodeLine{513         \textcolor{keywordtype}{bool} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} file[0] == \textcolor{charliteral}{'\(\backslash\)0'}; \}}
\DoxyCodeLine{514         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{515         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept};}
\DoxyCodeLine{516 }
\DoxyCodeLine{517         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* file;}
\DoxyCodeLine{518         std::size\_t line;}
\DoxyCodeLine{519     \};}
\DoxyCodeLine{520 }
\DoxyCodeLine{521     std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{522 }
\DoxyCodeLine{523     \textcolor{comment}{// Bring in operator<< from global namespace into Catch namespace}}
\DoxyCodeLine{524     \textcolor{comment}{// This is necessary because the overload of operator<< above makes}}
\DoxyCodeLine{525     \textcolor{comment}{// lookup stop at namespace Catch}}
\DoxyCodeLine{526     using ::operator<<;}
\DoxyCodeLine{527 }
\DoxyCodeLine{528     \textcolor{comment}{// Use this in variadic streaming macros to allow}}
\DoxyCodeLine{529     \textcolor{comment}{//    >> +StreamEndStop}}
\DoxyCodeLine{530     \textcolor{comment}{// as well as}}
\DoxyCodeLine{531     \textcolor{comment}{//    >> stuff +StreamEndStop}}
\DoxyCodeLine{532     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_stream_end_stop}{StreamEndStop}} \{}
\DoxyCodeLine{533         std::string operator+() \textcolor{keyword}{const};}
\DoxyCodeLine{534     \};}
\DoxyCodeLine{535     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{536     T \textcolor{keyword}{const}\& operator + ( T \textcolor{keyword}{const}\& value, \mbox{\hyperlink{struct_catch_1_1_stream_end_stop}{StreamEndStop}} ) \{}
\DoxyCodeLine{537         \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{538     \}}
\DoxyCodeLine{539 \}}
\DoxyCodeLine{540 }
\DoxyCodeLine{541 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_LINEINFO \(\backslash\)}}
\DoxyCodeLine{542 \textcolor{preprocessor}{    ::Catch::SourceLineInfo( \_\_FILE\_\_, static\_cast<std::size\_t>( \_\_LINE\_\_ ) )}}
\DoxyCodeLine{543 }
\DoxyCodeLine{544 \textcolor{comment}{// end catch\_common.h}}
\DoxyCodeLine{545 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{546 }
\DoxyCodeLine{547     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_registrar_for_tag_aliases}{RegistrarForTagAliases}} \{}
\DoxyCodeLine{548         \mbox{\hyperlink{struct_catch_1_1_registrar_for_tag_aliases}{RegistrarForTagAliases}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{549     \};}
\DoxyCodeLine{550 }
\DoxyCodeLine{551 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{552 }
\DoxyCodeLine{553 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TAG\_ALIAS( alias, spec ) \(\backslash\)}}
\DoxyCodeLine{554 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{555 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{556 \textcolor{preprocessor}{    namespace\{ Catch::RegistrarForTagAliases INTERNAL\_CATCH\_UNIQUE\_NAME( AutoRegisterTagAlias )( alias, spec, CATCH\_INTERNAL\_LINEINFO ); \} \(\backslash\)}}
\DoxyCodeLine{557 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.h}}
\DoxyCodeLine{560 \textcolor{comment}{// start catch\_test\_registry.h}}
\DoxyCodeLine{561 }
\DoxyCodeLine{562 \textcolor{comment}{// start catch\_interfaces\_testcase.h}}
\DoxyCodeLine{563 }
\DoxyCodeLine{564 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{565 }
\DoxyCodeLine{566 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{567 }
\DoxyCodeLine{568     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{569 }
\DoxyCodeLine{570     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}} \{}
\DoxyCodeLine{571         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke () \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{572         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{\string~ITestInvoker}}();}
\DoxyCodeLine{573     \};}
\DoxyCodeLine{574 }
\DoxyCodeLine{575     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}};}
\DoxyCodeLine{576     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}};}
\DoxyCodeLine{577 }
\DoxyCodeLine{578     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{ITestCaseRegistry}} \{}
\DoxyCodeLine{579         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{\string~ITestCaseRegistry}}();}
\DoxyCodeLine{580         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{581         \textcolor{keyword}{virtual} std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{582     \};}
\DoxyCodeLine{583 }
\DoxyCodeLine{584     \textcolor{keywordtype}{bool} isThrowSafe( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testCase, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{585     \textcolor{keywordtype}{bool} matchTest( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{586     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{587     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( \mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{588 }
\DoxyCodeLine{589 \}}
\DoxyCodeLine{590 }
\DoxyCodeLine{591 \textcolor{comment}{// end catch\_interfaces\_testcase.h}}
\DoxyCodeLine{592 \textcolor{comment}{// start catch\_stringref.h}}
\DoxyCodeLine{593 }
\DoxyCodeLine{594 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{595 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{596 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{597 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{598 }
\DoxyCodeLine{599 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{600 }
\DoxyCodeLine{604     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \{}
\DoxyCodeLine{605     \textcolor{keyword}{public}:}
\DoxyCodeLine{606         \textcolor{keyword}{using} size\_type = std::size\_t;}
\DoxyCodeLine{607         \textcolor{keyword}{using} const\_iterator = \textcolor{keyword}{const} \textcolor{keywordtype}{char}*;}
\DoxyCodeLine{608 }
\DoxyCodeLine{609     \textcolor{keyword}{private}:}
\DoxyCodeLine{610         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const} s\_empty = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{611 }
\DoxyCodeLine{612         \textcolor{keywordtype}{char} \textcolor{keyword}{const}* m\_start = s\_empty;}
\DoxyCodeLine{613         size\_type m\_size = 0;}
\DoxyCodeLine{614 }
\DoxyCodeLine{615     \textcolor{keyword}{public}: \textcolor{comment}{// construction}}
\DoxyCodeLine{616         \textcolor{keyword}{constexpr} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}() \textcolor{keyword}{noexcept} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{617 }
\DoxyCodeLine{618         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{619 }
\DoxyCodeLine{620         \textcolor{keyword}{constexpr} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, size\_type size ) noexcept}
\DoxyCodeLine{621         :   m\_start( rawChars ),}
\DoxyCodeLine{622             m\_size( size )}
\DoxyCodeLine{623         \{\}}
\DoxyCodeLine{624 }
\DoxyCodeLine{625         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( std::string \textcolor{keyword}{const}\& stdString ) noexcept}
\DoxyCodeLine{626         :   m\_start( stdString.c\_str() ),}
\DoxyCodeLine{627             m\_size( stdString.size() )}
\DoxyCodeLine{628         \{\}}
\DoxyCodeLine{629 }
\DoxyCodeLine{630         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} std::string()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{631             \textcolor{keywordflow}{return} std::string(m\_start, m\_size);}
\DoxyCodeLine{632         \}}
\DoxyCodeLine{633 }
\DoxyCodeLine{634     \textcolor{keyword}{public}: \textcolor{comment}{// operators}}
\DoxyCodeLine{635         \textcolor{keyword}{auto} operator == ( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> bool;}
\DoxyCodeLine{636         \textcolor{keyword}{auto} operator != (\mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{637             \textcolor{keywordflow}{return} !(*\textcolor{keyword}{this} == other);}
\DoxyCodeLine{638         \}}
\DoxyCodeLine{639 }
\DoxyCodeLine{640         \textcolor{keyword}{auto} operator[] ( size\_type index ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{641             assert(index < m\_size);}
\DoxyCodeLine{642             \textcolor{keywordflow}{return} m\_start[index];}
\DoxyCodeLine{643         \}}
\DoxyCodeLine{644 }
\DoxyCodeLine{645     \textcolor{keyword}{public}: \textcolor{comment}{// named queries}}
\DoxyCodeLine{646         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} empty() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{647             \textcolor{keywordflow}{return} m\_size == 0;}
\DoxyCodeLine{648         \}}
\DoxyCodeLine{649         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> size\_type \{}
\DoxyCodeLine{650             \textcolor{keywordflow}{return} m\_size;}
\DoxyCodeLine{651         \}}
\DoxyCodeLine{652 }
\DoxyCodeLine{653         \textcolor{comment}{// Returns the current start pointer. If the StringRef is not}}
\DoxyCodeLine{654         \textcolor{comment}{// null-\/terminated, throws std::domain\_exception}}
\DoxyCodeLine{655         \textcolor{keyword}{auto} c\_str() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{656 }
\DoxyCodeLine{657     \textcolor{keyword}{public}: \textcolor{comment}{// substrings and searches}}
\DoxyCodeLine{658         \textcolor{comment}{// Returns a substring of [start, start + length).}}
\DoxyCodeLine{659         \textcolor{comment}{// If start + length > size(), then the substring is [start, size()).}}
\DoxyCodeLine{660         \textcolor{comment}{// If start > size(), then the substring is empty.}}
\DoxyCodeLine{661         \textcolor{keyword}{auto} substr( size\_type start, size\_type length ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}};}
\DoxyCodeLine{662 }
\DoxyCodeLine{663         \textcolor{comment}{// Returns the current start pointer. May not be null-\/terminated.}}
\DoxyCodeLine{664         \textcolor{keyword}{auto} data() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \textcolor{keyword}{const}*;}
\DoxyCodeLine{665 }
\DoxyCodeLine{666         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} isNullTerminated() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{667             \textcolor{keywordflow}{return} m\_start[m\_size] == \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{668         \}}
\DoxyCodeLine{669 }
\DoxyCodeLine{670     \textcolor{keyword}{public}: \textcolor{comment}{// iterators}}
\DoxyCodeLine{671         \textcolor{keyword}{constexpr} const\_iterator begin()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start; \}}
\DoxyCodeLine{672         \textcolor{keyword}{constexpr} const\_iterator end()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_start + m\_size; \}}
\DoxyCodeLine{673     \};}
\DoxyCodeLine{674 }
\DoxyCodeLine{675     \textcolor{keyword}{auto} operator += ( std::string\& lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::string\&;}
\DoxyCodeLine{676     \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& sr ) -\/> std::ostream\&;}
\DoxyCodeLine{677 }
\DoxyCodeLine{678     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \{}
\DoxyCodeLine{679         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}( rawChars, size );}
\DoxyCodeLine{680     \}}
\DoxyCodeLine{681 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{682 }
\DoxyCodeLine{683 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_catch\_sr( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars, std::size\_t size ) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{class_catch_1_1_string_ref}{Catch::StringRef}} \{}
\DoxyCodeLine{684     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_string_ref}{Catch::StringRef}}( rawChars, size );}
\DoxyCodeLine{685 \}}
\DoxyCodeLine{686 }
\DoxyCodeLine{687 \textcolor{comment}{// end catch\_stringref.h}}
\DoxyCodeLine{688 \textcolor{comment}{// start catch\_preprocessor.hpp}}
\DoxyCodeLine{689 }
\DoxyCodeLine{690 }
\DoxyCodeLine{691 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL0(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{692 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL1(...) CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(CATCH\_RECURSION\_LEVEL0(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{693 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL2(...) CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(CATCH\_RECURSION\_LEVEL1(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{694 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL3(...) CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(CATCH\_RECURSION\_LEVEL2(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{695 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL4(...) CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(CATCH\_RECURSION\_LEVEL3(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{696 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL5(...) CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(CATCH\_RECURSION\_LEVEL4(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{697 }
\DoxyCodeLine{698 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{699 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND\_VARGS(...) \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{700 \textcolor{comment}{// MSVC needs more evaluations}}
\DoxyCodeLine{701 \textcolor{preprocessor}{\#define CATCH\_RECURSION\_LEVEL6(...) CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{702 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL6(CATCH\_RECURSION\_LEVEL6(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{703 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{704 \textcolor{preprocessor}{\#define CATCH\_RECURSE(...)  CATCH\_RECURSION\_LEVEL5(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{705 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{706 }
\DoxyCodeLine{707 \textcolor{preprocessor}{\#define CATCH\_REC\_END(...)}}
\DoxyCodeLine{708 \textcolor{preprocessor}{\#define CATCH\_REC\_OUT}}
\DoxyCodeLine{709 }
\DoxyCodeLine{710 \textcolor{preprocessor}{\#define CATCH\_EMPTY()}}
\DoxyCodeLine{711 \textcolor{preprocessor}{\#define CATCH\_DEFER(id) id CATCH\_EMPTY()}}
\DoxyCodeLine{712 }
\DoxyCodeLine{713 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END2() 0, CATCH\_REC\_END}}
\DoxyCodeLine{714 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END1(...) CATCH\_REC\_GET\_END2}}
\DoxyCodeLine{715 \textcolor{preprocessor}{\#define CATCH\_REC\_GET\_END(...) CATCH\_REC\_GET\_END1}}
\DoxyCodeLine{716 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT0(test, next, ...) next CATCH\_REC\_OUT}}
\DoxyCodeLine{717 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT1(test, next) CATCH\_DEFER ( CATCH\_REC\_NEXT0 ) ( test, next, 0)}}
\DoxyCodeLine{718 \textcolor{preprocessor}{\#define CATCH\_REC\_NEXT(test, next)  CATCH\_REC\_NEXT1(CATCH\_REC\_GET\_END test, next)}}
\DoxyCodeLine{719 }
\DoxyCodeLine{720 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{721 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1(f, x, peek, ...) , f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{722 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2(f, x, peek, ...)   f(x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1) ) ( f, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{723 }
\DoxyCodeLine{724 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST0\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{725 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST1\_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST0\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{726 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST2\_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH\_DEFER ( CATCH\_REC\_NEXT(peek, CATCH\_REC\_LIST1\_UD) ) ( f, userdata, peek, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{727 }
\DoxyCodeLine{728 \textcolor{comment}{// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,}}
\DoxyCodeLine{729 \textcolor{comment}{// and passes userdata as the first parameter to each invocation,}}
\DoxyCodeLine{730 \textcolor{comment}{// e.g. CATCH\_REC\_LIST\_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)}}
\DoxyCodeLine{731 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST\_UD(f, userdata, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2\_UD(f, userdata, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{732 }
\DoxyCodeLine{733 \textcolor{preprocessor}{\#define CATCH\_REC\_LIST(f, ...) CATCH\_RECURSE(CATCH\_REC\_LIST2(f, \_\_VA\_ARGS\_\_, ()()(), ()()(), ()()(), 0))}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND1(param) INTERNAL\_CATCH\_EXPAND2(param)}}
\DoxyCodeLine{736 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_EXPAND2(...) INTERNAL\_CATCH\_NO\#\# \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{737 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEF(...) INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_}}
\DoxyCodeLine{738 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{739 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE(...) INTERNAL\_CATCH\_STRINGIZE2(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{740 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{741 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{742 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param))}}
\DoxyCodeLine{743 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{744 \textcolor{comment}{// MSVC is adding extra space and needs another indirection to expand INTERNAL\_CATCH\_NOINTERNAL\_CATCH\_DEF}}
\DoxyCodeLine{745 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE2(...) INTERNAL\_CATCH\_STRINGIZE3(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{746 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE3(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{747 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS(param) (INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_REMOVE\_PARENS(param)) + 1)}}
\DoxyCodeLine{748 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{749 }
\DoxyCodeLine{750 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE2(...) ns\_\#\#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{751 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_NAMESPACE(name) INTERNAL\_CATCH\_MAKE\_NAMESPACE2(name)}}
\DoxyCodeLine{752 }
\DoxyCodeLine{753 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS(...) INTERNAL\_CATCH\_EXPAND1(INTERNAL\_CATCH\_DEF \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{754 }
\DoxyCodeLine{755 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{756 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>())}}
\DoxyCodeLine{757 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{759 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(...) INTERNAL\_CATCH\_EXPAND\_VARGS(decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(\_\_VA\_ARGS\_\_)>()))}}
\DoxyCodeLine{760 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LIST(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST2(INTERNAL\_CATCH\_REMOVE\_PARENS(\_\_VA\_ARGS\_\_)))}}
\DoxyCodeLine{761 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{762 }
\DoxyCodeLine{763 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(...)\(\backslash\)}}
\DoxyCodeLine{764 \textcolor{preprocessor}{    CATCH\_REC\_LIST(INTERNAL\_CATCH\_MAKE\_TYPE\_LIST,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_0) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0)}}
\DoxyCodeLine{767 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_0, \_1) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG(\_1)}}
\DoxyCodeLine{768 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_0, \_1, \_2) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG(\_1, \_2)}}
\DoxyCodeLine{769 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_0, \_1, \_2, \_3) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG(\_1, \_2, \_3)}}
\DoxyCodeLine{770 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_0, \_1, \_2, \_3, \_4) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG(\_1, \_2, \_3, \_4)}}
\DoxyCodeLine{771 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_0, \_1, \_2, \_3, \_4, \_5) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG(\_1, \_2, \_3, \_4, \_5)}}
\DoxyCodeLine{772 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG(\_1, \_2, \_3, \_4, \_5, \_6)}}
\DoxyCodeLine{773 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7)}}
\DoxyCodeLine{774 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8)}}
\DoxyCodeLine{775 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9)}}
\DoxyCodeLine{776 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10) INTERNAL\_CATCH\_REMOVE\_PARENS(\_0), INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG(\_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10)}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_0, \_1, \_2, \_3, \_4, \_5, \_6, \_7, \_8, \_9, \_10, N, ...) N}}
\DoxyCodeLine{779 }
\DoxyCodeLine{780 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{781 \textcolor{preprocessor}{    template<typename...> struct TypeList \{\};\(\backslash\)}}
\DoxyCodeLine{782 \textcolor{preprocessor}{    template<typename...Ts>\(\backslash\)}}
\DoxyCodeLine{783 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TypeList<Ts...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{784 \textcolor{preprocessor}{    template<template<typename...> class...> struct TemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{785 \textcolor{preprocessor}{    template<template<typename...> class...Cs>\(\backslash\)}}
\DoxyCodeLine{786 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> TemplateTypeList<Cs...> \{ return \{\}; \}\(\backslash\)}}
\DoxyCodeLine{787 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{788 \textcolor{preprocessor}{    struct append;\(\backslash\)}}
\DoxyCodeLine{789 \textcolor{preprocessor}{    template<typename...>\(\backslash\)}}
\DoxyCodeLine{790 \textcolor{preprocessor}{    struct rewrap;\(\backslash\)}}
\DoxyCodeLine{791 \textcolor{preprocessor}{    template<template<typename...> class, typename...>\(\backslash\)}}
\DoxyCodeLine{792 \textcolor{preprocessor}{    struct create;\(\backslash\)}}
\DoxyCodeLine{793 \textcolor{preprocessor}{    template<template<typename...> class, typename>\(\backslash\)}}
\DoxyCodeLine{794 \textcolor{preprocessor}{    struct convert;\(\backslash\)}}
\DoxyCodeLine{795 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{796 \textcolor{preprocessor}{    template<typename T> \(\backslash\)}}
\DoxyCodeLine{797 \textcolor{preprocessor}{    struct append<T> \{ using type = T; \};\(\backslash\)}}
\DoxyCodeLine{798 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{799 \textcolor{preprocessor}{    struct append<L1<E1...>, L2<E2...>, Rest...> \{ using type = typename append<L1<E1...,E2...>, Rest...>::type; \};\(\backslash\)}}
\DoxyCodeLine{800 \textcolor{preprocessor}{    template< template<typename...> class L1, typename...E1, typename...Rest>\(\backslash\)}}
\DoxyCodeLine{801 \textcolor{preprocessor}{    struct append<L1<E1...>, TypeList<mpl\_::na>, Rest...> \{ using type = L1<E1...>; \};\(\backslash\)}}
\DoxyCodeLine{802 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{803 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, typename...elems>\(\backslash\)}}
\DoxyCodeLine{804 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<elems...>> \{ using type = TypeList<Container<elems...>>; \};\(\backslash\)}}
\DoxyCodeLine{805 \textcolor{preprocessor}{    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\(\backslash\)}}
\DoxyCodeLine{806 \textcolor{preprocessor}{    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> \{ using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{807 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{808 \textcolor{preprocessor}{    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{809 \textcolor{preprocessor}{    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; \};\(\backslash\)}}
\DoxyCodeLine{810 \textcolor{preprocessor}{    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\(\backslash\)}}
\DoxyCodeLine{811 \textcolor{preprocessor}{    struct convert<Final, List<Ts...>> \{ using type = typename append<Final<>,TypeList<Ts>...>::type; \};}}
\DoxyCodeLine{812 }
\DoxyCodeLine{813 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_1(signature, ...)\(\backslash\)}}
\DoxyCodeLine{814 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> struct Nttp\{\};\(\backslash\)}}
\DoxyCodeLine{815 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{816 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> Nttp<\_\_VA\_ARGS\_\_> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{817 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...> struct NttpTemplateTypeList\{\};\(\backslash\)}}
\DoxyCodeLine{818 \textcolor{preprocessor}{    template<template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Cs>\(\backslash\)}}
\DoxyCodeLine{819 \textcolor{preprocessor}{    constexpr auto get\_wrapper() noexcept -\/> NttpTemplateTypeList<Cs...> \{ return \{\}; \} \(\backslash\)}}
\DoxyCodeLine{820 \textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{821 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{822 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>> \{ using type = TypeList<Container<\_\_VA\_ARGS\_\_>>; \};\(\backslash\)}}
\DoxyCodeLine{823 \textcolor{preprocessor}{    template< template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class Container, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class List, INTERNAL\_CATCH\_REMOVE\_PARENS(signature), typename...Elements>\(\backslash\)}}
\DoxyCodeLine{824 \textcolor{preprocessor}{    struct rewrap<NttpTemplateTypeList<Container>, List<\_\_VA\_ARGS\_\_>, Elements...> \{ using type = typename append<TypeList<Container<\_\_VA\_ARGS\_\_>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; \};\(\backslash\)}}
\DoxyCodeLine{825 \textcolor{preprocessor}{    template<template <typename...> class Final, template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> class...Containers, typename...Types>\(\backslash\)}}
\DoxyCodeLine{826 \textcolor{preprocessor}{    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> \{ using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; \};}}
\DoxyCodeLine{827 }
\DoxyCodeLine{828 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{829 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{830 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{831 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{832 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{833 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{835 }
\DoxyCodeLine{836 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0(TestName)}}
\DoxyCodeLine{837 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{838 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{839 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{840 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X(TestName, signature,...)\(\backslash\)}}
\DoxyCodeLine{841 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{842 \textcolor{preprocessor}{    static void TestName()}}
\DoxyCodeLine{843 }
\DoxyCodeLine{844 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER0(TestFunc, signature)\(\backslash\)}}
\DoxyCodeLine{845 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{846 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{847 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{848 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<Type>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{849 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{850 }
\DoxyCodeLine{851 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER(TestFunc, signature, ...)\(\backslash\)}}
\DoxyCodeLine{852 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{853 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{854 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{855 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestFunc<\_\_VA\_ARGS\_\_>), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), nameAndTags);\(\backslash\)}}
\DoxyCodeLine{856 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{859 \textcolor{preprocessor}{    template<typename Type>\(\backslash\)}}
\DoxyCodeLine{860 \textcolor{preprocessor}{    void reg\_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{861 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{862 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<Type>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{863 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{864 }
\DoxyCodeLine{865 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{866 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)>\(\backslash\)}}
\DoxyCodeLine{867 \textcolor{preprocessor}{    void reg\_test(Nttp<\_\_VA\_ARGS\_\_>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\(\backslash\)}}
\DoxyCodeLine{868 \textcolor{preprocessor}{    \{\(\backslash\)}}
\DoxyCodeLine{869 \textcolor{preprocessor}{        Catch::AutoReg( Catch::makeTestInvoker(\&TestName<\_\_VA\_ARGS\_\_>::test), CATCH\_INTERNAL\_LINEINFO, className, nameAndTags);\(\backslash\)}}
\DoxyCodeLine{870 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{871 }
\DoxyCodeLine{872 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0(TestName, ClassName)}}
\DoxyCodeLine{873 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1(TestName, ClassName, signature)\(\backslash\)}}
\DoxyCodeLine{874 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{875 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<TestType> \{ \(\backslash\)}}
\DoxyCodeLine{876 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{877 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{878 }
\DoxyCodeLine{879 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X(TestName, ClassName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{880 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{881 \textcolor{preprocessor}{    struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName)<\_\_VA\_ARGS\_\_> \{ \(\backslash\)}}
\DoxyCodeLine{882 \textcolor{preprocessor}{        void test();\(\backslash\)}}
\DoxyCodeLine{883 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{884 }
\DoxyCodeLine{885 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0(TestName)}}
\DoxyCodeLine{886 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1(TestName, signature)\(\backslash\)}}
\DoxyCodeLine{887 \textcolor{preprocessor}{    template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{888 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<TestType>::test()}}
\DoxyCodeLine{889 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X(TestName, signature, ...)\(\backslash\)}}
\DoxyCodeLine{890 \textcolor{preprocessor}{    template<INTERNAL\_CATCH\_REMOVE\_PARENS(signature)> \(\backslash\)}}
\DoxyCodeLine{891 \textcolor{preprocessor}{    void INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)::TestName<\_\_VA\_ARGS\_\_>::test()}}
\DoxyCodeLine{892 }
\DoxyCodeLine{893 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{894 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0}}
\DoxyCodeLine{895 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1(\_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_),INTERNAL\_CATCH\_NTTP\_1( \_\_VA\_ARGS\_\_), INTERNAL\_CATCH\_NTTP\_0)}}
\DoxyCodeLine{896 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{897 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{898 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{899 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{900 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{901 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_)}
\DoxyCodeLine{902 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{903 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{904 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_0(signature)}}
\DoxyCodeLine{905 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_1,INTERNAL\_CATCH\_NTTP\_1, INTERNAL\_CATCH\_NTTP\_0)( \_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{906 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{907 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD0)(TestName, ClassName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{908 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0, INTERNAL\_CATCH\_NTTP\_REGISTER\_METHOD0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{909 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER, INTERNAL\_CATCH\_NTTP\_REGISTER0, INTERNAL\_CATCH\_NTTP\_REGISTER0)(TestFunc, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{910 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DEFINE\_SIG\_TEST1, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{911 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestName, ...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL( "{}dummy"{}}, \_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X,INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_X, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST1, INTERNAL\_CATCH\_DECLARE\_SIG\_TEST0)(TestName, \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{912 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REMOVE\_PARENS\_GEN(...) INTERNAL\_CATCH\_EXPAND\_VARGS(INTERNAL\_CATCH\_VA\_NARGS\_IMPL(\_\_VA\_ARGS\_\_, INTERNAL\_CATCH\_REMOVE\_PARENS\_11\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_10\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_9\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_8\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_7\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_6\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_5\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_4\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_3\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_2\_ARG,INTERNAL\_CATCH\_REMOVE\_PARENS\_1\_ARG)(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{913 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{914 }
\DoxyCodeLine{915 \textcolor{comment}{// end catch\_preprocessor.hpp}}
\DoxyCodeLine{916 \textcolor{comment}{// start catch\_meta.hpp}}
\DoxyCodeLine{917 }
\DoxyCodeLine{918 }
\DoxyCodeLine{919 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{920 }
\DoxyCodeLine{921 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{922     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{923     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false}} : std::false\_type \{\};}
\DoxyCodeLine{924 }
\DoxyCodeLine{925     \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1true__given}{true\_given}} : std::true\_type \{\};}
\DoxyCodeLine{926     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable__tester}{is\_callable\_tester}} \{}
\DoxyCodeLine{927         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{928         \mbox{\hyperlink{struct_catch_1_1true__given}{true\_given<decltype(std::declval<Fun>}}()(std::declval<Args>()...))> \textcolor{keyword}{static} test(\textcolor{keywordtype}{int});}
\DoxyCodeLine{929         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{930         std::false\_type \textcolor{keyword}{static} test(...);}
\DoxyCodeLine{931     \};}
\DoxyCodeLine{932 }
\DoxyCodeLine{933     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{934     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable}{is\_callable}};}
\DoxyCodeLine{935 }
\DoxyCodeLine{936     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{937     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__callable}{is\_callable}}<Fun(Args...)> : decltype(is\_callable\_tester::test<Fun, Args...>(0)) \{\};}
\DoxyCodeLine{938 }
\DoxyCodeLine{939 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_is\_invocable) \&\& \_\_cpp\_lib\_is\_invocable >= 201703}}
\DoxyCodeLine{940     \textcolor{comment}{// std::result\_of is deprecated in C++17 and removed in C++20. Hence, it is}}
\DoxyCodeLine{941     \textcolor{comment}{// replaced with std::invoke\_result here.}}
\DoxyCodeLine{942     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{943     \textcolor{keyword}{using} FunctionReturnType = std::remove\_reference\_t<std::remove\_cv\_t<std::invoke\_result\_t<Func, U...>>>;}
\DoxyCodeLine{944 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{945     \textcolor{comment}{// Keep ::type here because we still support C++11}}
\DoxyCodeLine{946     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... U>}
\DoxyCodeLine{947     \textcolor{keyword}{using} FunctionReturnType = \textcolor{keyword}{typename} std::remove\_reference<\textcolor{keyword}{typename} std::remove\_cv<\textcolor{keyword}{typename} std::result\_of<Func(U...)>::type>::type>::type;}
\DoxyCodeLine{948 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{951 }
\DoxyCodeLine{952 \textcolor{keyword}{namespace }mpl\_\{}
\DoxyCodeLine{953     \textcolor{keyword}{struct }na;}
\DoxyCodeLine{954 \}}
\DoxyCodeLine{955 }
\DoxyCodeLine{956 \textcolor{comment}{// end catch\_meta.hpp}}
\DoxyCodeLine{957 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{958 }
\DoxyCodeLine{959 \textcolor{keyword}{template}<\textcolor{keyword}{typename} C>}
\DoxyCodeLine{960 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}} \{}
\DoxyCodeLine{961     void (C::*m\_testAsMethod)();}
\DoxyCodeLine{962 \textcolor{keyword}{public}:}
\DoxyCodeLine{963     \mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod}}( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept : m\_testAsMethod( testAsMethod ) \{\}}
\DoxyCodeLine{964 }
\DoxyCodeLine{965     \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{966         C obj;}
\DoxyCodeLine{967         (obj.*m\_testAsMethod)();}
\DoxyCodeLine{968     \}}
\DoxyCodeLine{969 \};}
\DoxyCodeLine{970 }
\DoxyCodeLine{971 \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}*;}
\DoxyCodeLine{972 }
\DoxyCodeLine{973 template<typename C>}
\DoxyCodeLine{974 auto makeTestInvoker( \textcolor{keywordtype}{void} (C::*testAsMethod)() ) noexcept -\/> \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* \{}
\DoxyCodeLine{975     \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) \mbox{\hyperlink{class_catch_1_1_test_invoker_as_method}{TestInvokerAsMethod<C>}}( testAsMethod );}
\DoxyCodeLine{976 \}}
\DoxyCodeLine{977 }
\DoxyCodeLine{978 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \{}
\DoxyCodeLine{979     \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& name\_ = \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}(), \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& tags\_ = \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}}() ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{980     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} name;}
\DoxyCodeLine{981     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} tags;}
\DoxyCodeLine{982 \};}
\DoxyCodeLine{983 }
\DoxyCodeLine{984 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_auto_reg}{AutoReg}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{985     \mbox{\hyperlink{struct_catch_1_1_auto_reg}{AutoReg}}( \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* invoker, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& classOrMethod, \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{986     \mbox{\hyperlink{struct_catch_1_1_auto_reg}{\string~AutoReg}}();}
\DoxyCodeLine{987 \};}
\DoxyCodeLine{988 }
\DoxyCodeLine{989 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{990 }
\DoxyCodeLine{991 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{992 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{993 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{994 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION( TestName, ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{995 \textcolor{preprocessor}{        namespace\{                        \(\backslash\)}}
\DoxyCodeLine{996 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{997 \textcolor{preprocessor}{                void test();              \(\backslash\)}}
\DoxyCodeLine{998 \textcolor{preprocessor}{            \};                            \(\backslash\)}}
\DoxyCodeLine{999 \textcolor{preprocessor}{        \}                                 \(\backslash\)}}
\DoxyCodeLine{1000 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{1001 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( TestName, TestFunc, Name, Tags, Signature, ... )  \(\backslash\)}}
\DoxyCodeLine{1002 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1003 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \(\backslash\)}}
\DoxyCodeLine{1004 \textcolor{preprocessor}{        namespace\{                                                                                  \(\backslash\)}}
\DoxyCodeLine{1005 \textcolor{preprocessor}{            namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                      \(\backslash\)}}
\DoxyCodeLine{1006 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1007 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1008 \textcolor{preprocessor}{        \}                                                                                           \(\backslash\)}}
\DoxyCodeLine{1009 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1010 }
\DoxyCodeLine{1011 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1012 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1013 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1014 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1015 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1016 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1017 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1018 }
\DoxyCodeLine{1019 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1020 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1021 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1022 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1023 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1024 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1025 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1026 }
\DoxyCodeLine{1027 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1028 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1029 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1030 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1031 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1032 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1033 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1034 }
\DoxyCodeLine{1035 \textcolor{preprocessor}{    \#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1036 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1037 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1038 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{1039 \textcolor{preprocessor}{        \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1040 \textcolor{preprocessor}{            INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1041 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{1042 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1043 }
\DoxyCodeLine{1045 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE2( TestName, ... ) \(\backslash\)}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{        static void TestName(); \(\backslash\)}}
\DoxyCodeLine{1047 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1048 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1049 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&TestName ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1050 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1051 \textcolor{preprocessor}{        static void TestName()}}
\DoxyCodeLine{1052 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TESTCASE( ... ) \(\backslash\)}}
\DoxyCodeLine{1053 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TESTCASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1054 }
\DoxyCodeLine{1056 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( QualifiedMethod, ... ) \(\backslash\)}}
\DoxyCodeLine{1057 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1058 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1059 \textcolor{preprocessor}{        namespace\{ Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( \&QualifiedMethod ), CATCH\_INTERNAL\_LINEINFO, "{}\&"{}} \#QualifiedMethod, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); \} \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1060 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1061 }
\DoxyCodeLine{1063 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( TestName, ClassName, ... )\(\backslash\)}}
\DoxyCodeLine{1064 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1065 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1066 \textcolor{preprocessor}{        namespace\{ \(\backslash\)}}
\DoxyCodeLine{1067 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName) \{ \(\backslash\)}}
\DoxyCodeLine{1068 \textcolor{preprocessor}{                void test(); \(\backslash\)}}
\DoxyCodeLine{1069 \textcolor{preprocessor}{            \}; \(\backslash\)}}
\DoxyCodeLine{1070 \textcolor{preprocessor}{            Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar ) ( Catch::makeTestInvoker( \&TestName::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1071 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{1072 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1073 \textcolor{preprocessor}{        void TestName::test()}}
\DoxyCodeLine{1074 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEST\_CASE\_METHOD( ClassName, ... ) \(\backslash\)}}
\DoxyCodeLine{1075 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEST\_CASE\_METHOD2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), ClassName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1076 }
\DoxyCodeLine{1078 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, ... ) \(\backslash\)}}
\DoxyCodeLine{1079 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1080 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1081 \textcolor{preprocessor}{        Catch::AutoReg INTERNAL\_CATCH\_UNIQUE\_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ \_\_VA\_ARGS\_\_ \} ); }\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1082 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1085 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1086 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1087 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1088 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1089 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1090 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DECLARE\_SIG\_TEST(TestFunc, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1091 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1092 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1093 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1094 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1095 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_GEN(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1096 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1097 \textcolor{preprocessor}{            struct TestName\{\(\backslash\)}}
\DoxyCodeLine{1098 \textcolor{preprocessor}{                TestName()\{\(\backslash\)}}
\DoxyCodeLine{1099 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1100 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1101 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1102 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1104 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1105 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1106 \textcolor{preprocessor}{            TestName<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1107 \textcolor{preprocessor}{            return 0;\(\backslash\)}}
\DoxyCodeLine{1108 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1109 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1110 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1111 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1112 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST(TestFunc,INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1113 }
\DoxyCodeLine{1114 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1115 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1116 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1117 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1118 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE(Name, Tags, ...) \(\backslash\)}}
\DoxyCodeLine{1119 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename TestType, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1120 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1121 }
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1123 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1124 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1125 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1126 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG(Name, Tags, Signature, ...) \(\backslash\)}}
\DoxyCodeLine{1127 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1128 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1129 }
\DoxyCodeLine{1130 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \(\backslash\)}}
\DoxyCodeLine{1131 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION                      \(\backslash\)}}
\DoxyCodeLine{1132 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS                      \(\backslash\)}}
\DoxyCodeLine{1133 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS                \(\backslash\)}}
\DoxyCodeLine{1134 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS              \(\backslash\)}}
\DoxyCodeLine{1135 \textcolor{preprocessor}{        template<typename TestType> static void TestFuncName();       \(\backslash\)}}
\DoxyCodeLine{1136 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1137 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName) \{                                     \(\backslash\)}}
\DoxyCodeLine{1138 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                                                  \(\backslash\)}}
\DoxyCodeLine{1139 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))         \(\backslash\)}}
\DoxyCodeLine{1140 \textcolor{preprocessor}{            template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1141 \textcolor{preprocessor}{            struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1142 \textcolor{preprocessor}{                void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1143 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1144 \textcolor{preprocessor}{                    using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1145 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1146 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1147 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1148 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFuncName<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1149 \textcolor{preprocessor}{                \}                                                     \(\backslash\)}}
\DoxyCodeLine{1150 \textcolor{preprocessor}{            \};                                                        \(\backslash\)}}
\DoxyCodeLine{1151 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1152 \textcolor{preprocessor}{                using TestInit = typename create<TestName, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type; \(\backslash\)}}
\DoxyCodeLine{1153 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1154 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1155 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1156 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1157 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1158 \textcolor{preprocessor}{        \}                                                             \(\backslash\)}}
\DoxyCodeLine{1159 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1160 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1161 \textcolor{preprocessor}{        static void TestFuncName()}}
\DoxyCodeLine{1162 }
\DoxyCodeLine{1163 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1164 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1165 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename T,\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1166 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1167 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE(Name, Tags, ...)\(\backslash\)}}
\DoxyCodeLine{1168 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1169 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1170 }
\DoxyCodeLine{1171 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1172 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1173 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{1174 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1175 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG(Name, Tags, Signature, ...)\(\backslash\)}}
\DoxyCodeLine{1176 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1177 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2(TestName, TestFunc, Name, Tags, TmplList)\(\backslash\)}}
\DoxyCodeLine{1180 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1181 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1182 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1183 \textcolor{preprocessor}{        template<typename TestType> static void TestFunc();       \(\backslash\)}}
\DoxyCodeLine{1184 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1185 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{\(\backslash\)}}
\DoxyCodeLine{1186 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1187 \textcolor{preprocessor}{        template<typename... Types>                               \(\backslash\)}}
\DoxyCodeLine{1188 \textcolor{preprocessor}{        struct TestName \{                                         \(\backslash\)}}
\DoxyCodeLine{1189 \textcolor{preprocessor}{            void reg\_tests() \{                                          \(\backslash\)}}
\DoxyCodeLine{1190 \textcolor{preprocessor}{                int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1191 \textcolor{preprocessor}{                using expander = int[];                           \(\backslash\)}}
\DoxyCodeLine{1192 \textcolor{preprocessor}{                (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestFunc<Types> ), CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{\(\backslash\)}}
\DoxyCodeLine{1193 \textcolor{preprocessor}{            \}                                                     \(\backslash\)}}
\DoxyCodeLine{1194 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1195 \textcolor{preprocessor}{        static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{ \(\backslash\)}}
\DoxyCodeLine{1196 \textcolor{preprocessor}{                using TestInit = typename convert<TestName, TmplList>::type; \(\backslash\)}}
\DoxyCodeLine{1197 \textcolor{preprocessor}{                TestInit t;                                           \(\backslash\)}}
\DoxyCodeLine{1198 \textcolor{preprocessor}{                t.reg\_tests();                                        \(\backslash\)}}
\DoxyCodeLine{1199 \textcolor{preprocessor}{                return 0;                                             \(\backslash\)}}
\DoxyCodeLine{1200 \textcolor{preprocessor}{            \}();                                                      \(\backslash\)}}
\DoxyCodeLine{1201 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1202 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION                       \(\backslash\)}}
\DoxyCodeLine{1203 \textcolor{preprocessor}{        template<typename TestType>                                   \(\backslash\)}}
\DoxyCodeLine{1204 \textcolor{preprocessor}{        static void TestFunc()}}
\DoxyCodeLine{1205 }
\DoxyCodeLine{1206 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1207 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), Name, Tags, TmplList )}}
\DoxyCodeLine{1208 }
\DoxyCodeLine{1209 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1210 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1211 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1212 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1213 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1214 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1215 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1216 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1217 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1218 \textcolor{preprocessor}{            INTERNAL\_CATCH\_DECLARE\_SIG\_TEST\_METHOD(TestName, ClassName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature));\(\backslash\)}}
\DoxyCodeLine{1219 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_REG\_METHOD\_GEN(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1220 \textcolor{preprocessor}{            template<typename...Types> \(\backslash\)}}
\DoxyCodeLine{1221 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1222 \textcolor{preprocessor}{                TestNameClass()\{\(\backslash\)}}
\DoxyCodeLine{1223 \textcolor{preprocessor}{                    int index = 0;                                    \(\backslash\)}}
\DoxyCodeLine{1224 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, \_\_VA\_ARGS\_\_)\};\(\backslash\)}}
\DoxyCodeLine{1225 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1226 \textcolor{preprocessor}{                    (void)expander\{(reg\_test(Types\{\}, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index]), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1228 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1229 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1230 \textcolor{preprocessor}{                TestNameClass<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(\_\_VA\_ARGS\_\_)>();\(\backslash\)}}
\DoxyCodeLine{1231 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1232 \textcolor{preprocessor}{        \}();\(\backslash\)}}
\DoxyCodeLine{1233 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1234 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1235 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1236 \textcolor{preprocessor}{        INTERNAL\_CATCH\_DEFINE\_SIG\_TEST\_METHOD(TestName, INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))}}
\DoxyCodeLine{1237 }
\DoxyCodeLine{1238 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1239 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1240 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1241 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1242 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( ClassName, Name, Tags,... ) \(\backslash\)}}
\DoxyCodeLine{1243 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1244 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1245 }
\DoxyCodeLine{1246 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1247 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1248 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1249 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1250 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... ) \(\backslash\)}}
\DoxyCodeLine{1251 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_C\_L\_A\_S\_S\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ) , ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1252 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1253 }
\DoxyCodeLine{1254 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\(\backslash\)}}
\DoxyCodeLine{1255 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1256 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1257 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_ZERO\_VARIADIC\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1258 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1259 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1260 \textcolor{preprocessor}{            struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1261 \textcolor{preprocessor}{                void test();\(\backslash\)}}
\DoxyCodeLine{1262 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1263 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1264 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestNameClass) \{\(\backslash\)}}
\DoxyCodeLine{1265 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN                  \(\backslash\)}}
\DoxyCodeLine{1266 \textcolor{preprocessor}{            INTERNAL\_CATCH\_NTTP\_GEN(INTERNAL\_CATCH\_REMOVE\_PARENS(Signature))\(\backslash\)}}
\DoxyCodeLine{1267 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1268 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1269 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1270 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1271 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1272 \textcolor{preprocessor}{                    constexpr char const* tmpl\_types[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes))\};\(\backslash\)}}
\DoxyCodeLine{1273 \textcolor{preprocessor}{                    constexpr char const* types\_list[] = \{CATCH\_REC\_LIST(INTERNAL\_CATCH\_STRINGIZE\_WITHOUT\_PARENS, INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))\};\(\backslash\)}}
\DoxyCodeLine{1274 \textcolor{preprocessor}{                    constexpr auto num\_types = sizeof(types\_list) / sizeof(types\_list[0]);\(\backslash\)}}
\DoxyCodeLine{1275 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(tmpl\_types[index / num\_types]) + "{}<"{} + std::string(types\_list[index \% num\_types]) + "{}>"{}, Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1276 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1277 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1278 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1279 \textcolor{preprocessor}{                using TestInit = typename create<TestNameClass, decltype(get\_wrapper<INTERNAL\_CATCH\_REMOVE\_PARENS(TmplTypes)>()), TypeList<INTERNAL\_CATCH\_MAKE\_TYPE\_LISTS\_FROM\_TYPES(INTERNAL\_CATCH\_REMOVE\_PARENS(TypesList))>>::type;\(\backslash\)}}
\DoxyCodeLine{1280 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1281 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1282 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1283 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1284 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1285 \textcolor{preprocessor}{        \}\(\backslash\)}}
\DoxyCodeLine{1286 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1287 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1288 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1289 }
\DoxyCodeLine{1290 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1291 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1292 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, typename T, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1293 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1294 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( ClassName, Name, Tags, ... )\(\backslash\)}}
\DoxyCodeLine{1295 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, typename T,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1296 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{1299 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1300 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, Signature, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{1301 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1302 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( ClassName, Name, Tags, Signature, ... )\(\backslash\)}}
\DoxyCodeLine{1303 \textcolor{preprocessor}{        INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, Signature,\_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{1304 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1305 }
\DoxyCodeLine{1306 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1307 \textcolor{preprocessor}{        CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1308 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1309 \textcolor{preprocessor}{        CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_TEMPLATE\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{1310 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1311 \textcolor{preprocessor}{        struct TestName : INTERNAL\_CATCH\_REMOVE\_PARENS(ClassName <TestType>) \{ \(\backslash\)}}
\DoxyCodeLine{1312 \textcolor{preprocessor}{            void test();\(\backslash\)}}
\DoxyCodeLine{1313 \textcolor{preprocessor}{        \};\(\backslash\)}}
\DoxyCodeLine{1314 \textcolor{preprocessor}{        namespace \{\(\backslash\)}}
\DoxyCodeLine{1315 \textcolor{preprocessor}{        namespace INTERNAL\_CATCH\_MAKE\_NAMESPACE(TestName)\{ \(\backslash\)}}
\DoxyCodeLine{1316 \textcolor{preprocessor}{            INTERNAL\_CATCH\_TYPE\_GEN\(\backslash\)}}
\DoxyCodeLine{1317 \textcolor{preprocessor}{            template<typename...Types>\(\backslash\)}}
\DoxyCodeLine{1318 \textcolor{preprocessor}{            struct TestNameClass\{\(\backslash\)}}
\DoxyCodeLine{1319 \textcolor{preprocessor}{                void reg\_tests()\{\(\backslash\)}}
\DoxyCodeLine{1320 \textcolor{preprocessor}{                    int index = 0;\(\backslash\)}}
\DoxyCodeLine{1321 \textcolor{preprocessor}{                    using expander = int[];\(\backslash\)}}
\DoxyCodeLine{1322 \textcolor{preprocessor}{                    (void)expander\{(Catch::AutoReg( Catch::makeTestInvoker( \&TestName<Types>::test ), CATCH\_INTERNAL\_LINEINFO, \#ClassName, Catch::NameAndTags\{ Name "{} -\/ "{}} + std::string(INTERNAL\_CATCH\_STRINGIZE(TmplList)) + "{} -\/ "{} + std::to\_string(index), Tags \} ), index++)... \};\textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{1323 \textcolor{preprocessor}{                \}\(\backslash\)}}
\DoxyCodeLine{1324 \textcolor{preprocessor}{            \};\(\backslash\)}}
\DoxyCodeLine{1325 \textcolor{preprocessor}{            static int INTERNAL\_CATCH\_UNIQUE\_NAME( globalRegistrar ) = []()\{\(\backslash\)}}
\DoxyCodeLine{1326 \textcolor{preprocessor}{                using TestInit = typename convert<TestNameClass, TmplList>::type;\(\backslash\)}}
\DoxyCodeLine{1327 \textcolor{preprocessor}{                TestInit t;\(\backslash\)}}
\DoxyCodeLine{1328 \textcolor{preprocessor}{                t.reg\_tests();\(\backslash\)}}
\DoxyCodeLine{1329 \textcolor{preprocessor}{                return 0;\(\backslash\)}}
\DoxyCodeLine{1330 \textcolor{preprocessor}{            \}(); \(\backslash\)}}
\DoxyCodeLine{1331 \textcolor{preprocessor}{        \}\}\(\backslash\)}}
\DoxyCodeLine{1332 \textcolor{preprocessor}{        CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{1333 \textcolor{preprocessor}{        template<typename TestType> \(\backslash\)}}
\DoxyCodeLine{1334 \textcolor{preprocessor}{        void TestName<TestType>::test()}}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD(ClassName, Name, Tags, TmplList) \(\backslash\)}}
\DoxyCodeLine{1337 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD\_2( INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_ ), INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_M\_P\_L\_A\_T\_E\_\_\_\_T\_E\_S\_T\_\_\_\_F\_U\_N\_C\_\_\_\_ ), ClassName, Name, Tags, TmplList )}}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{comment}{// end catch\_test\_registry.h}}
\DoxyCodeLine{1340 \textcolor{comment}{// start catch\_capture.hpp}}
\DoxyCodeLine{1341 }
\DoxyCodeLine{1342 \textcolor{comment}{// start catch\_assertionhandler.h}}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 \textcolor{comment}{// start catch\_assertioninfo.h}}
\DoxyCodeLine{1345 }
\DoxyCodeLine{1346 \textcolor{comment}{// start catch\_result\_type.h}}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1349 }
\DoxyCodeLine{1350     \textcolor{comment}{// ResultWas::OfType enum}}
\DoxyCodeLine{1351     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_result_was}{ResultWas}} \{ \textcolor{keyword}{enum} OfType \{}
\DoxyCodeLine{1352         Unknown = -\/1,}
\DoxyCodeLine{1353         Ok = 0,}
\DoxyCodeLine{1354         Info = 1,}
\DoxyCodeLine{1355         Warning = 2,}
\DoxyCodeLine{1356 }
\DoxyCodeLine{1357         FailureBit = 0x10,}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359         ExpressionFailed = FailureBit | 1,}
\DoxyCodeLine{1360         ExplicitFailure = FailureBit | 2,}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362         Exception = 0x100 | FailureBit,}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364         ThrewException = Exception | 1,}
\DoxyCodeLine{1365         DidntThrowException = Exception | 2,}
\DoxyCodeLine{1366 }
\DoxyCodeLine{1367         FatalErrorCondition = 0x200 | FailureBit}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369     \}; \};}
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType );}
\DoxyCodeLine{1372     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1373 }
\DoxyCodeLine{1374     \textcolor{comment}{// ResultDisposition::Flags enum}}
\DoxyCodeLine{1375     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_result_disposition}{ResultDisposition}} \{ \textcolor{keyword}{enum} Flags \{}
\DoxyCodeLine{1376         Normal = 0x01,}
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378         ContinueOnFailure = 0x02,   \textcolor{comment}{// Failures fail test, but execution continues}}
\DoxyCodeLine{1379         FalseTest = 0x04,           \textcolor{comment}{// Prefix expression with !}}
\DoxyCodeLine{1380         SuppressFail = 0x08         \textcolor{comment}{// Failures are reported but do not fail the test}}
\DoxyCodeLine{1381     \}; \};}
\DoxyCodeLine{1382 }
\DoxyCodeLine{1383     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );}
\DoxyCodeLine{1384 }
\DoxyCodeLine{1385     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1386     \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} isFalseTest( \textcolor{keywordtype}{int} flags ) \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::FalseTest ) != 0; \}}
\DoxyCodeLine{1387     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags );}
\DoxyCodeLine{1388 }
\DoxyCodeLine{1389 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1390 }
\DoxyCodeLine{1391 \textcolor{comment}{// end catch\_result\_type.h}}
\DoxyCodeLine{1392 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1393 }
\DoxyCodeLine{1394     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}}}
\DoxyCodeLine{1395     \{}
\DoxyCodeLine{1396         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName;}
\DoxyCodeLine{1397         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{1398         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} capturedExpression;}
\DoxyCodeLine{1399         ResultDisposition::Flags resultDisposition;}
\DoxyCodeLine{1400 }
\DoxyCodeLine{1401         \textcolor{comment}{// We want to delete this constructor but a compiler bug in 4.8 means}}
\DoxyCodeLine{1402         \textcolor{comment}{// the struct is then treated as non-\/aggregate}}
\DoxyCodeLine{1403         \textcolor{comment}{//AssertionInfo() = delete;}}
\DoxyCodeLine{1404     \};}
\DoxyCodeLine{1405 }
\DoxyCodeLine{1406 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{1407 }
\DoxyCodeLine{1408 \textcolor{comment}{// end catch\_assertioninfo.h}}
\DoxyCodeLine{1409 \textcolor{comment}{// start catch\_decomposer.h}}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411 \textcolor{comment}{// start catch\_tostring.h}}
\DoxyCodeLine{1412 }
\DoxyCodeLine{1413 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1414 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1415 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{1416 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{1417 \textcolor{comment}{// start catch\_stream.h}}
\DoxyCodeLine{1418 }
\DoxyCodeLine{1419 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{1420 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{1421 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{1422 }
\DoxyCodeLine{1423 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1424 }
\DoxyCodeLine{1425     std::ostream\& cout();}
\DoxyCodeLine{1426     std::ostream\& cerr();}
\DoxyCodeLine{1427     std::ostream\& clog();}
\DoxyCodeLine{1428 }
\DoxyCodeLine{1429     \textcolor{keyword}{class }StringRef;}
\DoxyCodeLine{1430 }
\DoxyCodeLine{1431     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_stream}{IStream}} \{}
\DoxyCodeLine{1432         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_stream}{\string~IStream}}();}
\DoxyCodeLine{1433         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{1434     \};}
\DoxyCodeLine{1435 }
\DoxyCodeLine{1436     \textcolor{keyword}{auto} makeStream( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const} \&filename ) -\/> \mbox{\hyperlink{struct_catch_1_1_i_stream}{IStream}} \textcolor{keyword}{const}*;}
\DoxyCodeLine{1437 }
\DoxyCodeLine{1438     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{1439         std::size\_t m\_index;}
\DoxyCodeLine{1440         std::ostream* m\_oss;}
\DoxyCodeLine{1441     \textcolor{keyword}{public}:}
\DoxyCodeLine{1442         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}}();}
\DoxyCodeLine{1443         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{\string~ReusableStringStream}}();}
\DoxyCodeLine{1444 }
\DoxyCodeLine{1445         \textcolor{keyword}{auto} str() \textcolor{keyword}{const} -\/> std::string;}
\DoxyCodeLine{1446 }
\DoxyCodeLine{1447         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1448         \textcolor{keyword}{auto} operator << ( T \textcolor{keyword}{const}\& value ) -\/> \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}}\& \{}
\DoxyCodeLine{1449             *m\_oss << value;}
\DoxyCodeLine{1450             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1451         \}}
\DoxyCodeLine{1452         \textcolor{keyword}{auto} get() -\/> std::ostream\& \{ \textcolor{keywordflow}{return} *m\_oss; \}}
\DoxyCodeLine{1453     \};}
\DoxyCodeLine{1454 \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456 \textcolor{comment}{// end catch\_stream.h}}
\DoxyCodeLine{1457 \textcolor{comment}{// start catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1458 }
\DoxyCodeLine{1459 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{1460 }
\DoxyCodeLine{1461 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1464         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{EnumInfo}} \{}
\DoxyCodeLine{1465             \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_name;}
\DoxyCodeLine{1466             std::vector<std::pair<int, StringRef>> m\_values;}
\DoxyCodeLine{1467 }
\DoxyCodeLine{1468             \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{\string~EnumInfo}}();}
\DoxyCodeLine{1469 }
\DoxyCodeLine{1470             \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} lookup( \textcolor{keywordtype}{int} value ) \textcolor{keyword}{const};}
\DoxyCodeLine{1471         \};}
\DoxyCodeLine{1472     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1473 }
\DoxyCodeLine{1474     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{IMutableEnumValuesRegistry}} \{}
\DoxyCodeLine{1475         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{\string~IMutableEnumValuesRegistry}}();}
\DoxyCodeLine{1476 }
\DoxyCodeLine{1477         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} enumName, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} allEnums, std::vector<int> \textcolor{keyword}{const}\& values ) = 0;}
\DoxyCodeLine{1478 }
\DoxyCodeLine{1479         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1480         \mbox{\hyperlink{struct_catch_1_1_detail_1_1_enum_info}{Detail::EnumInfo}} \textcolor{keyword}{const}\& registerEnum( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} enumName, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} allEnums, std::initializer\_list<E> values ) \{}
\DoxyCodeLine{1481             \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(int) >= \textcolor{keyword}{sizeof}(E), \textcolor{stringliteral}{"{}Cannot serialize enum to int"{}});}
\DoxyCodeLine{1482             std::vector<int> intValues;}
\DoxyCodeLine{1483             intValues.reserve( values.size() );}
\DoxyCodeLine{1484             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} enumValue : values )}
\DoxyCodeLine{1485                 intValues.push\_back( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( enumValue ) );}
\DoxyCodeLine{1486             \textcolor{keywordflow}{return} registerEnum( enumName, allEnums, intValues );}
\DoxyCodeLine{1487         \}}
\DoxyCodeLine{1488     \};}
\DoxyCodeLine{1489 }
\DoxyCodeLine{1490 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492 \textcolor{comment}{// end catch\_interfaces\_enum\_values\_registry.h}}
\DoxyCodeLine{1493 }
\DoxyCodeLine{1494 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1495 \textcolor{preprocessor}{\#include <string\_view>}}
\DoxyCodeLine{1496 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1499 \textcolor{comment}{// start catch\_objc\_arc.hpp}}
\DoxyCodeLine{1500 }
\DoxyCodeLine{1501 \textcolor{preprocessor}{\#import <Foundation/Foundation.h>}}
\DoxyCodeLine{1502 }
\DoxyCodeLine{1503 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{1504 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED \_\_has\_feature(objc\_arc)}}
\DoxyCodeLine{1505 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1506 \textcolor{preprocessor}{\#define CATCH\_ARC\_ENABLED 0}}
\DoxyCodeLine{1507 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1508 }
\DoxyCodeLine{1509 \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj );}
\DoxyCodeLine{1510 \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel );}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{1513 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* obj ) \{}
\DoxyCodeLine{1514     [obj release];}
\DoxyCodeLine{1515 \}}
\DoxyCodeLine{1516 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1517     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1518         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1519     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1520 \}}
\DoxyCodeLine{1521 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED}}
\DoxyCodeLine{1522 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG}}
\DoxyCodeLine{1523 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1524 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} arcSafeRelease( NSObject* )\{\}}
\DoxyCodeLine{1525 \textcolor{keyword}{inline} \textcolor{keywordtype}{id} performOptionalSelector( \textcolor{keywordtype}{id} obj, \textcolor{keywordtype}{SEL} sel ) \{}
\DoxyCodeLine{1526 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1527 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{1528 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Warc-\/performSelector-\/leaks"{}}}
\DoxyCodeLine{1529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1530     \textcolor{keywordflow}{if}( [obj respondsToSelector: sel] )}
\DoxyCodeLine{1531         \textcolor{keywordflow}{return} [obj performSelector: sel];}
\DoxyCodeLine{1532 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{1533 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{1534 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1535     \textcolor{keywordflow}{return} nil;}
\DoxyCodeLine{1536 \}}
\DoxyCodeLine{1537 \textcolor{preprocessor}{\#define CATCH\_UNSAFE\_UNRETAINED \_\_unsafe\_unretained}}
\DoxyCodeLine{1538 \textcolor{preprocessor}{\#define CATCH\_ARC\_STRONG \_\_strong}}
\DoxyCodeLine{1539 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1540 }
\DoxyCodeLine{1541 \textcolor{comment}{// end catch\_objc\_arc.hpp}}
\DoxyCodeLine{1542 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1543 }
\DoxyCodeLine{1544 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{1545 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{1546 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// We attempt to stream a function (address) by const\&, which MSVC complains about but is harmless}}
\DoxyCodeLine{1547 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1550     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1551 }
\DoxyCodeLine{1552         \textcolor{keyword}{extern} \textcolor{keyword}{const} std::string unprintableString;}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554         std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size );}
\DoxyCodeLine{1555 }
\DoxyCodeLine{1556         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1557         std::string rawMemoryToString( \textcolor{keyword}{const} T\& \textcolor{keywordtype}{object} ) \{}
\DoxyCodeLine{1558           \textcolor{keywordflow}{return} rawMemoryToString( \&\textcolor{keywordtype}{object}, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{object}) );}
\DoxyCodeLine{1559         \}}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1562         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_detail_1_1_is_stream_insertable}{IsStreamInsertable}} \{}
\DoxyCodeLine{1563             \textcolor{keyword}{template}<\textcolor{keyword}{typename} Stream, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{1564             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(\textcolor{keywordtype}{int})}
\DoxyCodeLine{1565                 -\/> \textcolor{keyword}{decltype}(std::declval<Stream\&>() << std::declval<U>(), std::true\_type());}
\DoxyCodeLine{1566 }
\DoxyCodeLine{1567             \textcolor{keyword}{template}<\textcolor{keyword}{typename}, \textcolor{keyword}{typename}>}
\DoxyCodeLine{1568             \textcolor{keyword}{static} \textcolor{keyword}{auto} test(...)-\/>std::false\_type;}
\DoxyCodeLine{1569 }
\DoxyCodeLine{1570         \textcolor{keyword}{public}:}
\DoxyCodeLine{1571             \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{decltype}(test<std::ostream, const T\&>(0))::value;}
\DoxyCodeLine{1572         \};}
\DoxyCodeLine{1573 }
\DoxyCodeLine{1574         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1575         std::string convertUnknownEnumToString( E e );}
\DoxyCodeLine{1576 }
\DoxyCodeLine{1577         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1578         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1579             !std::is\_enum<T>::value \&\& !std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1580         std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{1581             \textcolor{keywordflow}{return} Detail::unprintableString;}
\DoxyCodeLine{1582         \}}
\DoxyCodeLine{1583         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1584         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1585             !std::is\_enum<T>::value \&\& std::is\_base\_of<std::exception, T>::value,}
\DoxyCodeLine{1586          std::string>::type convertUnstreamable(T \textcolor{keyword}{const}\& ex) \{}
\DoxyCodeLine{1587             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{1588         \}}
\DoxyCodeLine{1589 }
\DoxyCodeLine{1590         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1591         \textcolor{keyword}{typename} std::enable\_if<}
\DoxyCodeLine{1592             std::is\_enum<T>::value}
\DoxyCodeLine{1593         , std::string>::type convertUnstreamable( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{1594             \textcolor{keywordflow}{return} convertUnknownEnumToString( value );}
\DoxyCodeLine{1595         \}}
\DoxyCodeLine{1596 }
\DoxyCodeLine{1597 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1599         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1600         std::string clrReferenceToString( T\string^ ref ) \{}
\DoxyCodeLine{1601             \textcolor{keywordflow}{if} (ref == \textcolor{keyword}{nullptr})}
\DoxyCodeLine{1602                 \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}null"{}});}
\DoxyCodeLine{1603             \textcolor{keyword}{auto} bytes = System::Text::Encoding::UTF8-\/>GetBytes(ref-\/>ToString());}
\DoxyCodeLine{1604             cli::pin\_ptr<System::Byte> p = \&bytes[0];}
\DoxyCodeLine{1605             \textcolor{keywordflow}{return} std::string(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(p), bytes-\/>Length);}
\DoxyCodeLine{1606         \}}
\DoxyCodeLine{1607 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1608 }
\DoxyCodeLine{1609     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1610 }
\DoxyCodeLine{1611     \textcolor{comment}{// If we decide for C++14, change these to enable\_if\_ts}}
\DoxyCodeLine{1612     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1613     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}} \{}
\DoxyCodeLine{1614         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1615         \textcolor{keyword}{static}}
\DoxyCodeLine{1616         \textcolor{keyword}{typename} std::enable\_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1617             convert(\textcolor{keyword}{const} Fake\& value) \{}
\DoxyCodeLine{1618                 \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} rss;}
\DoxyCodeLine{1619                 \textcolor{comment}{// NB: call using the function-\/like syntax to avoid ambiguity with}}
\DoxyCodeLine{1620                 \textcolor{comment}{// user-\/defined templated operator<< under clang.}}
\DoxyCodeLine{1621                 rss.operator<<(value);}
\DoxyCodeLine{1622                 \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1623         \}}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fake = T>}
\DoxyCodeLine{1626         \textcolor{keyword}{static}}
\DoxyCodeLine{1627         \textcolor{keyword}{typename} std::enable\_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type}
\DoxyCodeLine{1628             convert( \textcolor{keyword}{const} Fake\& value ) \{}
\DoxyCodeLine{1629 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_FALLBACK\_STRINGIFIER)}}
\DoxyCodeLine{1630             \textcolor{keywordflow}{return} Detail::convertUnstreamable(value);}
\DoxyCodeLine{1631 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1632             \textcolor{keywordflow}{return} CATCH\_CONFIG\_FALLBACK\_STRINGIFIER(value);}
\DoxyCodeLine{1633 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1634         \}}
\DoxyCodeLine{1635     \};}
\DoxyCodeLine{1636 }
\DoxyCodeLine{1637     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1638 }
\DoxyCodeLine{1639         \textcolor{comment}{// This function dispatches all stringification requests inside of Catch.}}
\DoxyCodeLine{1640         \textcolor{comment}{// Should be preferably called fully qualified, like ::Catch::Detail::stringify}}
\DoxyCodeLine{1641         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1642         std::string stringify(\textcolor{keyword}{const} T\& e) \{}
\DoxyCodeLine{1643             return ::Catch::StringMaker<typename std::remove\_cv<typename std::remove\_reference<T>::type>::type>::convert(e);}
\DoxyCodeLine{1644         \}}
\DoxyCodeLine{1645 }
\DoxyCodeLine{1646         \textcolor{keyword}{template}<\textcolor{keyword}{typename} E>}
\DoxyCodeLine{1647         std::string convertUnknownEnumToString( E e ) \{}
\DoxyCodeLine{1648             return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}typename std::underlying\_type<E>::type\textcolor{keyword}{>}(e));}
\DoxyCodeLine{1649         \}}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1652         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1653         std::string stringify( T\string^ e ) \{}
\DoxyCodeLine{1654             return ::Catch::StringMaker<T\string^>::convert(e);}
\DoxyCodeLine{1655         \}}
\DoxyCodeLine{1656 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1657 }
\DoxyCodeLine{1658     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1659 }
\DoxyCodeLine{1660     \textcolor{comment}{// Some predefined specializations}}
\DoxyCodeLine{1661 }
\DoxyCodeLine{1662     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1663     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::string> \{}
\DoxyCodeLine{1664         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::string\& str);}
\DoxyCodeLine{1665     \};}
\DoxyCodeLine{1666 }
\DoxyCodeLine{1667 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1668     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1669     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::string\_view> \{}
\DoxyCodeLine{1670         \textcolor{keyword}{static} std::string convert(std::string\_view str);}
\DoxyCodeLine{1671     \};}
\DoxyCodeLine{1672 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1673 }
\DoxyCodeLine{1674     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1675     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char const *> \{}
\DoxyCodeLine{1676         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1677     \};}
\DoxyCodeLine{1678     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1679     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char *> \{}
\DoxyCodeLine{1680         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} * str);}
\DoxyCodeLine{1681     \};}
\DoxyCodeLine{1682 }
\DoxyCodeLine{1683 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{1684     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1685     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::wstring> \{}
\DoxyCodeLine{1686         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::wstring\& wstr);}
\DoxyCodeLine{1687     \};}
\DoxyCodeLine{1688 }
\DoxyCodeLine{1689 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{1690     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1691     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::wstring\_view> \{}
\DoxyCodeLine{1692         \textcolor{keyword}{static} std::string convert(std::wstring\_view str);}
\DoxyCodeLine{1693     \};}
\DoxyCodeLine{1694 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{1695 }
\DoxyCodeLine{1696     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1697     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<wchar\_t const *> \{}
\DoxyCodeLine{1698         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str);}
\DoxyCodeLine{1699     \};}
\DoxyCodeLine{1700     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1701     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<wchar\_t *> \{}
\DoxyCodeLine{1702         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{wchar\_t} * str);}
\DoxyCodeLine{1703     \};}
\DoxyCodeLine{1704 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1705 }
\DoxyCodeLine{1706     \textcolor{comment}{// TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,}}
\DoxyCodeLine{1707     \textcolor{comment}{//      while keeping string semantics?}}
\DoxyCodeLine{1708     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1709     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char[SZ]> \{}
\DoxyCodeLine{1710         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1711             return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{1712         \}}
\DoxyCodeLine{1713     \};}
\DoxyCodeLine{1714     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1715     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<signed char[SZ]> \{}
\DoxyCodeLine{1716         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1717             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1718         \}}
\DoxyCodeLine{1719     \};}
\DoxyCodeLine{1720     \textcolor{keyword}{template}<\textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{1721     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned char[SZ]> \{}
\DoxyCodeLine{1722         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{1723             return ::Catch::Detail::stringify(std::string\{ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(str) \});}
\DoxyCodeLine{1724         \}}
\DoxyCodeLine{1725     \};}
\DoxyCodeLine{1726 }
\DoxyCodeLine{1727 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1728     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1729     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::byte> \{}
\DoxyCodeLine{1730         \textcolor{keyword}{static} std::string convert(std::byte value);}
\DoxyCodeLine{1731     \};}
\DoxyCodeLine{1732 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{1733     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1734     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<int> \{}
\DoxyCodeLine{1735         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1736     \};}
\DoxyCodeLine{1737     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1738     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<long> \{}
\DoxyCodeLine{1739         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1740     \};}
\DoxyCodeLine{1741     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1742     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<long long> \{}
\DoxyCodeLine{1743         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1744     \};}
\DoxyCodeLine{1745     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1746     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned int> \{}
\DoxyCodeLine{1747         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value);}
\DoxyCodeLine{1748     \};}
\DoxyCodeLine{1749     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1750     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned long> \{}
\DoxyCodeLine{1751         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1752     \};}
\DoxyCodeLine{1753     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1754     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned long long> \{}
\DoxyCodeLine{1755         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value);}
\DoxyCodeLine{1756     \};}
\DoxyCodeLine{1757 }
\DoxyCodeLine{1758     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1759     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<bool> \{}
\DoxyCodeLine{1760         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{bool} b);}
\DoxyCodeLine{1761     \};}
\DoxyCodeLine{1762 }
\DoxyCodeLine{1763     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1764     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<char> \{}
\DoxyCodeLine{1765         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1766     \};}
\DoxyCodeLine{1767     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1768     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<signed char> \{}
\DoxyCodeLine{1769         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1770     \};}
\DoxyCodeLine{1771     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1772     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<unsigned char> \{}
\DoxyCodeLine{1773         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c);}
\DoxyCodeLine{1774     \};}
\DoxyCodeLine{1775 }
\DoxyCodeLine{1776     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1777     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<std::nullptr\_t> \{}
\DoxyCodeLine{1778         \textcolor{keyword}{static} std::string convert(std::nullptr\_t);}
\DoxyCodeLine{1779     \};}
\DoxyCodeLine{1780 }
\DoxyCodeLine{1781     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1782     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<float> \{}
\DoxyCodeLine{1783         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{float} value);}
\DoxyCodeLine{1784         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1785     \};}
\DoxyCodeLine{1786 }
\DoxyCodeLine{1787     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1788     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<double> \{}
\DoxyCodeLine{1789         \textcolor{keyword}{static} std::string convert(\textcolor{keywordtype}{double} value);}
\DoxyCodeLine{1790         \textcolor{keyword}{static} \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{1791     \};}
\DoxyCodeLine{1792 }
\DoxyCodeLine{1793     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1794     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T*> \{}
\DoxyCodeLine{1795         \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{1796         \textcolor{keyword}{static} std::string convert(U* p) \{}
\DoxyCodeLine{1797             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1798                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1799             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1800                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1801             \}}
\DoxyCodeLine{1802         \}}
\DoxyCodeLine{1803     \};}
\DoxyCodeLine{1804 }
\DoxyCodeLine{1805     \textcolor{keyword}{template} <\textcolor{keyword}{typename} R, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{1806     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<R C::*> \{}
\DoxyCodeLine{1807         \textcolor{keyword}{static} std::string convert(R C::* p) \{}
\DoxyCodeLine{1808             \textcolor{keywordflow}{if} (p) \{}
\DoxyCodeLine{1809                 return ::Catch::Detail::rawMemoryToString(p);}
\DoxyCodeLine{1810             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1811                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{1812             \}}
\DoxyCodeLine{1813         \}}
\DoxyCodeLine{1814     \};}
\DoxyCodeLine{1815 }
\DoxyCodeLine{1816 \textcolor{preprocessor}{\#if defined(\_MANAGED)}}
\DoxyCodeLine{1817     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1818     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T\string^> \{}
\DoxyCodeLine{1819         \textcolor{keyword}{static} std::string convert( T\string^ ref ) \{}
\DoxyCodeLine{1820             return ::Catch::Detail::clrReferenceToString(ref);}
\DoxyCodeLine{1821         \}}
\DoxyCodeLine{1822     \};}
\DoxyCodeLine{1823 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1824 }
\DoxyCodeLine{1825     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1826         \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} Sentinel = InputIterator>}
\DoxyCodeLine{1827         std::string rangeToString(InputIterator first, Sentinel last) \{}
\DoxyCodeLine{1828             ReusableStringStream rss;}
\DoxyCodeLine{1829             rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{1830             \textcolor{keywordflow}{if} (first != last) \{}
\DoxyCodeLine{1831                 rss << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1832                 \textcolor{keywordflow}{for} (++first; first != last; ++first)}
\DoxyCodeLine{1833                     rss << \textcolor{stringliteral}{"{}, "{}} << ::Catch::Detail::stringify(*first);}
\DoxyCodeLine{1834             \}}
\DoxyCodeLine{1835             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1836             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1837         \}}
\DoxyCodeLine{1838     \}}
\DoxyCodeLine{1839 }
\DoxyCodeLine{1840 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{1841     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1842     \textcolor{keyword}{struct }StringMaker<NSString*> \{}
\DoxyCodeLine{1843         \textcolor{keyword}{static} std::string convert(NSString * nsstring) \{}
\DoxyCodeLine{1844             \textcolor{keywordflow}{if} (!nsstring)}
\DoxyCodeLine{1845                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nil"{}};}
\DoxyCodeLine{1846             \textcolor{keywordflow}{return} std::string(\textcolor{stringliteral}{"{}@"{}}) + [nsstring UTF8String];}
\DoxyCodeLine{1847         \}}
\DoxyCodeLine{1848     \};}
\DoxyCodeLine{1849     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1850     \textcolor{keyword}{struct }StringMaker<NSObject*> \{}
\DoxyCodeLine{1851         \textcolor{keyword}{static} std::string convert(NSObject* nsObject) \{}
\DoxyCodeLine{1852             return ::Catch::Detail::stringify([nsObject description]);}
\DoxyCodeLine{1853         \}}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855     \};}
\DoxyCodeLine{1856     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1857         \textcolor{keyword}{inline} std::string stringify( NSString* nsstring ) \{}
\DoxyCodeLine{1858             \textcolor{keywordflow}{return} StringMaker<NSString*>::convert( nsstring );}
\DoxyCodeLine{1859         \}}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861     \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{1862 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{1863 }
\DoxyCodeLine{1864 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1867 \textcolor{comment}{// Separate std-\/lib types stringification, so it can be selectively enabled}}
\DoxyCodeLine{1868 \textcolor{comment}{// This means that we do not bring in}}
\DoxyCodeLine{1869 }
\DoxyCodeLine{1870 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_ALL\_STRINGMAKERS)}}
\DoxyCodeLine{1871 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1872 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1873 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1874 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{1875 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1876 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1877 }
\DoxyCodeLine{1878 \textcolor{comment}{// Separate std::pair specialization}}
\DoxyCodeLine{1879 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER)}}
\DoxyCodeLine{1880 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{1881 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1882     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T1, \textcolor{keyword}{typename} T2>}
\DoxyCodeLine{1883     \textcolor{keyword}{struct }StringMaker<std::pair<T1, T2> > \{}
\DoxyCodeLine{1884         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::pair<T1, T2>\& pair) \{}
\DoxyCodeLine{1885             ReusableStringStream rss;}
\DoxyCodeLine{1886             rss << \textcolor{stringliteral}{"{}\{ "{}}}
\DoxyCodeLine{1887                 << ::Catch::Detail::stringify(pair.first)}
\DoxyCodeLine{1888                 << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{1889                 << ::Catch::Detail::stringify(pair.second)}
\DoxyCodeLine{1890                 << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1891             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1892         \}}
\DoxyCodeLine{1893     \};}
\DoxyCodeLine{1894 \}}
\DoxyCodeLine{1895 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_PAIR\_STRINGMAKER}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_OPTIONAL)}}
\DoxyCodeLine{1898 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{1899 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1900     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1901     \textcolor{keyword}{struct }StringMaker<std::optional<T> > \{}
\DoxyCodeLine{1902         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::optional<T>\& optional) \{}
\DoxyCodeLine{1903             ReusableStringStream rss;}
\DoxyCodeLine{1904             \textcolor{keywordflow}{if} (optional.has\_value()) \{}
\DoxyCodeLine{1905                 rss << ::Catch::Detail::stringify(*optional);}
\DoxyCodeLine{1906             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1907                 rss << \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1908             \}}
\DoxyCodeLine{1909             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1910         \}}
\DoxyCodeLine{1911     \};}
\DoxyCodeLine{1912 \}}
\DoxyCodeLine{1913 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_OPTIONAL\_STRINGMAKER}}
\DoxyCodeLine{1914 }
\DoxyCodeLine{1915 \textcolor{comment}{// Separate std::tuple specialization}}
\DoxyCodeLine{1916 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER)}}
\DoxyCodeLine{1917 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{1918 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1919     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{1920         \textcolor{keyword}{template}<}
\DoxyCodeLine{1921             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1922             std::size\_t N = 0,}
\DoxyCodeLine{1923             \textcolor{keywordtype}{bool} = (N < std::tuple\_size<Tuple>::value)}
\DoxyCodeLine{1924             >}
\DoxyCodeLine{1925             \textcolor{keyword}{struct} TupleElementPrinter \{}
\DoxyCodeLine{1926             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\& tuple, std::ostream\& os) \{}
\DoxyCodeLine{1927                 os << (N ? \textcolor{stringliteral}{"{}, "{}} : \textcolor{stringliteral}{"{} "{}})}
\DoxyCodeLine{1928                     << ::Catch::Detail::stringify(std::get<N>(tuple));}
\DoxyCodeLine{1929                 TupleElementPrinter<Tuple, N + 1>::print(tuple, os);}
\DoxyCodeLine{1930             \}}
\DoxyCodeLine{1931         \};}
\DoxyCodeLine{1932 }
\DoxyCodeLine{1933         \textcolor{keyword}{template}<}
\DoxyCodeLine{1934             \textcolor{keyword}{typename} Tuple,}
\DoxyCodeLine{1935             std::size\_t N}
\DoxyCodeLine{1936         >}
\DoxyCodeLine{1937             \textcolor{keyword}{struct }TupleElementPrinter<Tuple, N, false> \{}
\DoxyCodeLine{1938             \textcolor{keyword}{static} \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} Tuple\&, std::ostream\&) \{\}}
\DoxyCodeLine{1939         \};}
\DoxyCodeLine{1940 }
\DoxyCodeLine{1941     \}}
\DoxyCodeLine{1942 }
\DoxyCodeLine{1943     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...Types>}
\DoxyCodeLine{1944     \textcolor{keyword}{struct }StringMaker<std::tuple<Types...>> \{}
\DoxyCodeLine{1945         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::tuple<Types...>\& tuple) \{}
\DoxyCodeLine{1946             ReusableStringStream rss;}
\DoxyCodeLine{1947             rss << \textcolor{charliteral}{'\{'};}
\DoxyCodeLine{1948             Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());}
\DoxyCodeLine{1949             rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{1950             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{1951         \}}
\DoxyCodeLine{1952     \};}
\DoxyCodeLine{1953 \}}
\DoxyCodeLine{1954 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_TUPLE\_STRINGMAKER}}
\DoxyCodeLine{1955 }
\DoxyCodeLine{1956 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER) \&\& defined(CATCH\_CONFIG\_CPP17\_VARIANT)}}
\DoxyCodeLine{1957 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{1958 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1959     \textcolor{keyword}{template}<>}
\DoxyCodeLine{1960     \textcolor{keyword}{struct }StringMaker<std::monostate> \{}
\DoxyCodeLine{1961         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::monostate\&) \{}
\DoxyCodeLine{1962             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{ \}"{}};}
\DoxyCodeLine{1963         \}}
\DoxyCodeLine{1964     \};}
\DoxyCodeLine{1965 }
\DoxyCodeLine{1966     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Elements>}
\DoxyCodeLine{1967     \textcolor{keyword}{struct }StringMaker<std::variant<Elements...>> \{}
\DoxyCodeLine{1968         \textcolor{keyword}{static} std::string convert(\textcolor{keyword}{const} std::variant<Elements...>\& variant) \{}
\DoxyCodeLine{1969             \textcolor{keywordflow}{if} (variant.valueless\_by\_exception()) \{}
\DoxyCodeLine{1970                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{valueless variant\}"{}};}
\DoxyCodeLine{1971             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1972                 \textcolor{keywordflow}{return} std::visit(}
\DoxyCodeLine{1973                     [](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& value) \{}
\DoxyCodeLine{1974                         return ::Catch::Detail::stringify(value);}
\DoxyCodeLine{1975                     \},}
\DoxyCodeLine{1976                     variant}
\DoxyCodeLine{1977                 );}
\DoxyCodeLine{1978             \}}
\DoxyCodeLine{1979         \}}
\DoxyCodeLine{1980     \};}
\DoxyCodeLine{1981 \}}
\DoxyCodeLine{1982 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_VARIANT\_STRINGMAKER}}
\DoxyCodeLine{1983 }
\DoxyCodeLine{1984 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{1985     \textcolor{comment}{// Import begin/ end from std here}}
\DoxyCodeLine{1986     \textcolor{keyword}{using} std::begin;}
\DoxyCodeLine{1987     \textcolor{keyword}{using} std::end;}
\DoxyCodeLine{1988 }
\DoxyCodeLine{1989     \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1990         \textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{1991         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1void__type}{void\_type}} \{}
\DoxyCodeLine{1992             \textcolor{keyword}{using} type = void;}
\DoxyCodeLine{1993         \};}
\DoxyCodeLine{1994 }
\DoxyCodeLine{1995         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1996         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{is\_range\_impl}} : std::false\_type \{}
\DoxyCodeLine{1997         \};}
\DoxyCodeLine{1998 }
\DoxyCodeLine{1999         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2000         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{is\_range\_impl<T, typename void\_type<decltype(begin(std::declval<T>}}()))>::type> : std::true\_type \{}
\DoxyCodeLine{2001         \};}
\DoxyCodeLine{2002     \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2003 }
\DoxyCodeLine{2004     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2005     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__range}{is\_range}} : \mbox{\hyperlink{struct_catch_1_1detail_1_1is__range__impl}{detail::is\_range\_impl}}<T> \{}
\DoxyCodeLine{2006     \};}
\DoxyCodeLine{2007 }
\DoxyCodeLine{2008 \textcolor{preprocessor}{\#if defined(\_MANAGED) }\textcolor{comment}{// Managed types are never ranges}}
\DoxyCodeLine{2009     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2010     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1is__range}{is\_range}}<T\string^> \{}
\DoxyCodeLine{2011         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} value = \textcolor{keyword}{false};}
\DoxyCodeLine{2012     \};}
\DoxyCodeLine{2013 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2014 }
\DoxyCodeLine{2015     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{2016     std::string rangeToString( Range \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2017         return ::Catch::Detail::rangeToString( begin( range ), end( range ) );}
\DoxyCodeLine{2018     \}}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020     \textcolor{comment}{// Handle vector<bool> specially}}
\DoxyCodeLine{2021     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{2022     std::string rangeToString( std::vector<bool, Allocator> \textcolor{keyword}{const}\& v ) \{}
\DoxyCodeLine{2023         ReusableStringStream rss;}
\DoxyCodeLine{2024         rss << \textcolor{stringliteral}{"{}\{ "{}};}
\DoxyCodeLine{2025         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{2026         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{bool} b : v ) \{}
\DoxyCodeLine{2027             \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{2028                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{2029             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2030                 rss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{2031             rss << ::Catch::Detail::stringify( b );}
\DoxyCodeLine{2032         \}}
\DoxyCodeLine{2033         rss << \textcolor{stringliteral}{"{} \}"{}};}
\DoxyCodeLine{2034         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2035     \}}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037     \textcolor{keyword}{template}<\textcolor{keyword}{typename} R>}
\DoxyCodeLine{2038     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<R, typename std::enable\_if<is\_range<R>::value \&\& !::Catch::Detail::IsStreamInsertable<R>::value>::type> \{}
\DoxyCodeLine{2039         \textcolor{keyword}{static} std::string convert( R \textcolor{keyword}{const}\& range ) \{}
\DoxyCodeLine{2040             \textcolor{keywordflow}{return} rangeToString( range );}
\DoxyCodeLine{2041         \}}
\DoxyCodeLine{2042     \};}
\DoxyCodeLine{2043 }
\DoxyCodeLine{2044     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} SZ>}
\DoxyCodeLine{2045     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<T[SZ]> \{}
\DoxyCodeLine{2046         \textcolor{keyword}{static} std::string convert(T \textcolor{keyword}{const}(\&arr)[SZ]) \{}
\DoxyCodeLine{2047             \textcolor{keywordflow}{return} rangeToString(arr);}
\DoxyCodeLine{2048         \}}
\DoxyCodeLine{2049     \};}
\DoxyCodeLine{2050 }
\DoxyCodeLine{2051 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2052 }
\DoxyCodeLine{2053 \textcolor{comment}{// Separate std::chrono::duration specialization}}
\DoxyCodeLine{2054 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{2055 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{2056 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{2057 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2062 \textcolor{keyword}{struct }ratio\_string \{}
\DoxyCodeLine{2063     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2064 \};}
\DoxyCodeLine{2065 }
\DoxyCodeLine{2066 \textcolor{keyword}{template} <\textcolor{keyword}{class} Ratio>}
\DoxyCodeLine{2067 std::string ratio\_string<Ratio>::symbol() \{}
\DoxyCodeLine{2068     \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{Catch::ReusableStringStream}} rss;}
\DoxyCodeLine{2069     rss << \textcolor{charliteral}{'['} << Ratio::num << \textcolor{charliteral}{'/'}}
\DoxyCodeLine{2070         << Ratio::den << \textcolor{charliteral}{']'};}
\DoxyCodeLine{2071     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2072 \}}
\DoxyCodeLine{2073 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2074 \textcolor{keyword}{struct }ratio\_string<std::atto> \{}
\DoxyCodeLine{2075     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2076 \};}
\DoxyCodeLine{2077 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2078 \textcolor{keyword}{struct }ratio\_string<std::femto> \{}
\DoxyCodeLine{2079     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2080 \};}
\DoxyCodeLine{2081 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2082 \textcolor{keyword}{struct }ratio\_string<std::pico> \{}
\DoxyCodeLine{2083     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2084 \};}
\DoxyCodeLine{2085 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2086 \textcolor{keyword}{struct }ratio\_string<std::nano> \{}
\DoxyCodeLine{2087     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2088 \};}
\DoxyCodeLine{2089 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2090 \textcolor{keyword}{struct }ratio\_string<std::micro> \{}
\DoxyCodeLine{2091     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2092 \};}
\DoxyCodeLine{2093 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2094 \textcolor{keyword}{struct }ratio\_string<std::milli> \{}
\DoxyCodeLine{2095     \textcolor{keyword}{static} std::string symbol();}
\DoxyCodeLine{2096 \};}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2099     \textcolor{comment}{// std::chrono::duration specializations}}
\DoxyCodeLine{2100     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Ratio>}
\DoxyCodeLine{2101     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, Ratio>> \{}
\DoxyCodeLine{2102         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, Ratio> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2103             ReusableStringStream rss;}
\DoxyCodeLine{2104             rss << duration.count() << \textcolor{charliteral}{' '} << ratio\_string<Ratio>::symbol() << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{2105             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2106         \}}
\DoxyCodeLine{2107     \};}
\DoxyCodeLine{2108     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2109     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<1>>> \{}
\DoxyCodeLine{2110         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<1>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2111             ReusableStringStream rss;}
\DoxyCodeLine{2112             rss << duration.count() << \textcolor{stringliteral}{"{} s"{}};}
\DoxyCodeLine{2113             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2114         \}}
\DoxyCodeLine{2115     \};}
\DoxyCodeLine{2116     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2117     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<60>>> \{}
\DoxyCodeLine{2118         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<60>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2119             ReusableStringStream rss;}
\DoxyCodeLine{2120             rss << duration.count() << \textcolor{stringliteral}{"{} m"{}};}
\DoxyCodeLine{2121             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2122         \}}
\DoxyCodeLine{2123     \};}
\DoxyCodeLine{2124     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2125     \textcolor{keyword}{struct }StringMaker<std::chrono::duration<Value, std::ratio<3600>>> \{}
\DoxyCodeLine{2126         \textcolor{keyword}{static} std::string convert(std::chrono::duration<Value, std::ratio<3600>> \textcolor{keyword}{const}\& duration) \{}
\DoxyCodeLine{2127             ReusableStringStream rss;}
\DoxyCodeLine{2128             rss << duration.count() << \textcolor{stringliteral}{"{} h"{}};}
\DoxyCodeLine{2129             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{2130         \}}
\DoxyCodeLine{2131     \};}
\DoxyCodeLine{2132 }
\DoxyCodeLine{2134     \textcolor{comment}{// std::chrono::time\_point specialization}}
\DoxyCodeLine{2135     \textcolor{comment}{// Generic time\_point cannot be specialized, only std::chrono::time\_point<system\_clock>}}
\DoxyCodeLine{2136     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2137     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<Clock, Duration>> \{}
\DoxyCodeLine{2138         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<Clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2139             return ::Catch::Detail::stringify(time\_point.time\_since\_epoch()) + \textcolor{stringliteral}{"{} since epoch"{}};}
\DoxyCodeLine{2140         \}}
\DoxyCodeLine{2141     \};}
\DoxyCodeLine{2142     \textcolor{comment}{// std::chrono::time\_point<system\_clock> specialization}}
\DoxyCodeLine{2143     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{2144     \textcolor{keyword}{struct }StringMaker<std::chrono::time\_point<std::chrono::system\_clock, Duration>> \{}
\DoxyCodeLine{2145         \textcolor{keyword}{static} std::string convert(std::chrono::time\_point<std::chrono::system\_clock, Duration> \textcolor{keyword}{const}\& time\_point) \{}
\DoxyCodeLine{2146             \textcolor{keyword}{auto} converted = std::chrono::system\_clock::to\_time\_t(time\_point);}
\DoxyCodeLine{2147 }
\DoxyCodeLine{2148 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2149             std::tm timeInfo = \{\};}
\DoxyCodeLine{2150             gmtime\_s(\&timeInfo, \&converted);}
\DoxyCodeLine{2151 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2152             std::tm* timeInfo = std::gmtime(\&converted);}
\DoxyCodeLine{2153 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2154 }
\DoxyCodeLine{2155             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{2156             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{2157             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{2158 }
\DoxyCodeLine{2159 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2160             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{2161 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2162             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{2163 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2164             \textcolor{keywordflow}{return} std::string(timeStamp);}
\DoxyCodeLine{2165         \}}
\DoxyCodeLine{2166     \};}
\DoxyCodeLine{2167 \}}
\DoxyCodeLine{2168 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{2169 }
\DoxyCodeLine{2170 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, ... ) \(\backslash\)}}
\DoxyCodeLine{2171 \textcolor{preprocessor}{namespace Catch \{ \(\backslash\)}}
\DoxyCodeLine{2172 \textcolor{preprocessor}{    template<> struct StringMaker<enumName> \{ \(\backslash\)}}
\DoxyCodeLine{2173 \textcolor{preprocessor}{        static std::string convert( enumName value ) \{ \(\backslash\)}}
\DoxyCodeLine{2174 \textcolor{preprocessor}{            static const auto\& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( \#enumName, \#\_\_VA\_ARGS\_\_, \{ \_\_VA\_ARGS\_\_ \} ); \(\backslash\)}}
\DoxyCodeLine{2175 \textcolor{preprocessor}{            return static\_cast<std::string>(enumInfo.lookup( static\_cast<int>( value ) )); \(\backslash\)}}
\DoxyCodeLine{2176 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2177 \textcolor{preprocessor}{    \}; \(\backslash\)}}
\DoxyCodeLine{2178 \textcolor{preprocessor}{\}}}
\DoxyCodeLine{2179 }
\DoxyCodeLine{2180 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_ENUM( enumName, ... ) INTERNAL\_CATCH\_REGISTER\_ENUM( enumName, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2181 }
\DoxyCodeLine{2182 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2183 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2184 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2185 }
\DoxyCodeLine{2186 \textcolor{comment}{// end catch\_tostring.h}}
\DoxyCodeLine{2187 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{2188 }
\DoxyCodeLine{2189 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2190 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{2191 \textcolor{preprocessor}{\#pragma warning(disable:4389) }\textcolor{comment}{// '==' : signed/unsigned mismatch}}
\DoxyCodeLine{2192 \textcolor{preprocessor}{\#pragma warning(disable:4018) }\textcolor{comment}{// more "{}signed/unsigned mismatch"{}}}
\DoxyCodeLine{2193 \textcolor{preprocessor}{\#pragma warning(disable:4312) }\textcolor{comment}{// Converting int to T* using reinterpret\_cast (issue on x64 platform)}}
\DoxyCodeLine{2194 \textcolor{preprocessor}{\#pragma warning(disable:4180) }\textcolor{comment}{// qualifier applied to function type has no meaning}}
\DoxyCodeLine{2195 \textcolor{preprocessor}{\#pragma warning(disable:4800) }\textcolor{comment}{// Forcing result to true or false}}
\DoxyCodeLine{2196 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2197 }
\DoxyCodeLine{2198 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2201         \textcolor{keyword}{auto} isBinaryExpression() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_isBinaryExpression; \}}
\DoxyCodeLine{2202         \textcolor{keyword}{auto} getResult() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} m\_result; \}}
\DoxyCodeLine{2203         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2204 }
\DoxyCodeLine{2205         \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}( \textcolor{keywordtype}{bool} isBinaryExpression, \textcolor{keywordtype}{bool} result )}
\DoxyCodeLine{2206         :   m\_isBinaryExpression( isBinaryExpression ),}
\DoxyCodeLine{2207             m\_result( result )}
\DoxyCodeLine{2208         \{\}}
\DoxyCodeLine{2209 }
\DoxyCodeLine{2210         \textcolor{comment}{// We don't actually need a virtual destructor, but many static analysers}}
\DoxyCodeLine{2211         \textcolor{comment}{// complain if it's not here :-\/(}}
\DoxyCodeLine{2212         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{\string~ITransientExpression}}();}
\DoxyCodeLine{2213 }
\DoxyCodeLine{2214         \textcolor{keywordtype}{bool} m\_isBinaryExpression;}
\DoxyCodeLine{2215         \textcolor{keywordtype}{bool} m\_result;}
\DoxyCodeLine{2216 }
\DoxyCodeLine{2217     \};}
\DoxyCodeLine{2218 }
\DoxyCodeLine{2219     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} op, std::string \textcolor{keyword}{const}\& rhs );}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2222     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr}}  : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2223         LhsT m\_lhs;}
\DoxyCodeLine{2224         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_op;}
\DoxyCodeLine{2225         RhsT m\_rhs;}
\DoxyCodeLine{2226 }
\DoxyCodeLine{2227         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2228             formatReconstructedExpression}
\DoxyCodeLine{2229                     ( os, Catch::Detail::stringify( m\_lhs ), m\_op, Catch::Detail::stringify( m\_rhs ) );}
\DoxyCodeLine{2230         \}}
\DoxyCodeLine{2231 }
\DoxyCodeLine{2232     \textcolor{keyword}{public}:}
\DoxyCodeLine{2233         \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr}}( \textcolor{keywordtype}{bool} comparisonResult, LhsT lhs, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} op, RhsT rhs )}
\DoxyCodeLine{2234         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{true}, comparisonResult \},}
\DoxyCodeLine{2235             m\_lhs( lhs ),}
\DoxyCodeLine{2236             m\_op( op ),}
\DoxyCodeLine{2237             m\_rhs( rhs )}
\DoxyCodeLine{2238         \{\}}
\DoxyCodeLine{2239 }
\DoxyCodeLine{2240         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2241         \textcolor{keyword}{auto} operator \&\& ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2242             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2243             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2244             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2245         \}}
\DoxyCodeLine{2246 }
\DoxyCodeLine{2247         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2248         \textcolor{keyword}{auto} operator || ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2249             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2250             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2251             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2252         \}}
\DoxyCodeLine{2253 }
\DoxyCodeLine{2254         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2255         \textcolor{keyword}{auto} operator == ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2256             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2257             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2258             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2259         \}}
\DoxyCodeLine{2260 }
\DoxyCodeLine{2261         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2262         \textcolor{keyword}{auto} operator != ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2263             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2264             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2265             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2266         \}}
\DoxyCodeLine{2267 }
\DoxyCodeLine{2268         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2269         \textcolor{keyword}{auto} operator > ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2270             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2271             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2272             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2273         \}}
\DoxyCodeLine{2274 }
\DoxyCodeLine{2275         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2276         \textcolor{keyword}{auto} operator < ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2277             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2278             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2279             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2280         \}}
\DoxyCodeLine{2281 }
\DoxyCodeLine{2282         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2283         \textcolor{keyword}{auto} operator >= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2284             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2285             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2286             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2287         \}}
\DoxyCodeLine{2288 }
\DoxyCodeLine{2289         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2290         \textcolor{keyword}{auto} operator <= ( T ) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2291             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<T>::value}},}
\DoxyCodeLine{2292             \textcolor{stringliteral}{"{}chained comparisons are not supported inside assertions, "{}}}
\DoxyCodeLine{2293             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2294         \}}
\DoxyCodeLine{2295     \};}
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2298     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{2299         LhsT m\_lhs;}
\DoxyCodeLine{2300 }
\DoxyCodeLine{2301         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{2302             os << Catch::Detail::stringify( m\_lhs );}
\DoxyCodeLine{2303         \}}
\DoxyCodeLine{2304 }
\DoxyCodeLine{2305     \textcolor{keyword}{public}:}
\DoxyCodeLine{2306         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr}}( LhsT lhs )}
\DoxyCodeLine{2307         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{false}, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs) \},}
\DoxyCodeLine{2308             m\_lhs( lhs )}
\DoxyCodeLine{2309         \{\}}
\DoxyCodeLine{2310     \};}
\DoxyCodeLine{2311 }
\DoxyCodeLine{2312     \textcolor{comment}{// Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)}}
\DoxyCodeLine{2313     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2314     \textcolor{keyword}{auto} compareEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs == rhs); \}}
\DoxyCodeLine{2315     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2316     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2317     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2318     \textcolor{keyword}{auto} compareEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs == \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2319     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2320     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2321     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2322     \textcolor{keyword}{auto} compareEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) == rhs; \}}
\DoxyCodeLine{2323 }
\DoxyCodeLine{2324     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT, \textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2325     \textcolor{keyword}{auto} compareNotEqual( LhsT \textcolor{keyword}{const}\& lhs, RhsT\&\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(lhs != rhs); \}}
\DoxyCodeLine{2326     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2327     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{int} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2328     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2329     \textcolor{keyword}{auto} compareNotEqual( T* \textcolor{keyword}{const}\& lhs, \textcolor{keywordtype}{long} rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} lhs != \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( rhs ); \}}
\DoxyCodeLine{2330     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2331     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{int} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2332     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2333     \textcolor{keyword}{auto} compareNotEqual( \textcolor{keywordtype}{long} lhs, T* \textcolor{keyword}{const}\& rhs ) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{void} const*\textcolor{keyword}{>}( lhs ) != rhs; \}}
\DoxyCodeLine{2334 }
\DoxyCodeLine{2335     \textcolor{keyword}{template}<\textcolor{keyword}{typename} LhsT>}
\DoxyCodeLine{2336     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs}} \{}
\DoxyCodeLine{2337         LhsT m\_lhs;}
\DoxyCodeLine{2338     \textcolor{keyword}{public}:}
\DoxyCodeLine{2339         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs}}( LhsT lhs ) : m\_lhs( lhs ) \{\}}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2342         \textcolor{keyword}{auto} operator == ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2343             \textcolor{keywordflow}{return} \{ compareEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2344         \}}
\DoxyCodeLine{2345         \textcolor{keyword}{auto} operator == ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2346             \textcolor{keywordflow}{return} \{ m\_lhs == rhs, m\_lhs, \textcolor{stringliteral}{"{}=="{}}, rhs \};}
\DoxyCodeLine{2347         \}}
\DoxyCodeLine{2348 }
\DoxyCodeLine{2349         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2350         \textcolor{keyword}{auto} operator != ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2351             \textcolor{keywordflow}{return} \{ compareNotEqual( m\_lhs, rhs ), m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2352         \}}
\DoxyCodeLine{2353         \textcolor{keyword}{auto} operator != ( \textcolor{keywordtype}{bool} rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, bool>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2354             \textcolor{keywordflow}{return} \{ m\_lhs != rhs, m\_lhs, \textcolor{stringliteral}{"{}!="{}}, rhs \};}
\DoxyCodeLine{2355         \}}
\DoxyCodeLine{2356 }
\DoxyCodeLine{2357         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2358         \textcolor{keyword}{auto} operator > ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2359             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs > rhs), m\_lhs, \textcolor{stringliteral}{"{}>"{}}, rhs \};}
\DoxyCodeLine{2360         \}}
\DoxyCodeLine{2361         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2362         \textcolor{keyword}{auto} operator < ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2363             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs < rhs), m\_lhs, \textcolor{stringliteral}{"{}<"{}}, rhs \};}
\DoxyCodeLine{2364         \}}
\DoxyCodeLine{2365         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2366         \textcolor{keyword}{auto} operator >= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2367             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs >= rhs), m\_lhs, \textcolor{stringliteral}{"{}>="{}}, rhs \};}
\DoxyCodeLine{2368         \}}
\DoxyCodeLine{2369         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2370         \textcolor{keyword}{auto} operator <= ( RhsT \textcolor{keyword}{const}\& rhs ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2371             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs <= rhs), m\_lhs, \textcolor{stringliteral}{"{}<="{}}, rhs \};}
\DoxyCodeLine{2372         \}}
\DoxyCodeLine{2373         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2374         \textcolor{keyword}{auto} operator | (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2375             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs | rhs), m\_lhs, \textcolor{stringliteral}{"{}|"{}}, rhs \};}
\DoxyCodeLine{2376         \}}
\DoxyCodeLine{2377         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2378         \textcolor{keyword}{auto} operator \& (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2379             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \& rhs), m\_lhs, \textcolor{stringliteral}{"{}\&"{}}, rhs \};}
\DoxyCodeLine{2380         \}}
\DoxyCodeLine{2381         \textcolor{keyword}{template} <\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2382         \textcolor{keyword}{auto} operator \string^ (RhsT \textcolor{keyword}{const}\& rhs) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2383             \textcolor{keywordflow}{return} \{ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(m\_lhs \string^ rhs), m\_lhs, \textcolor{stringliteral}{"{}\string^"{}}, rhs \};}
\DoxyCodeLine{2384         \}}
\DoxyCodeLine{2385 }
\DoxyCodeLine{2386         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2387         \textcolor{keyword}{auto} operator \&\& ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2388             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2389             \textcolor{stringliteral}{"{}operator\&\& is not supported inside assertions, "{}}}
\DoxyCodeLine{2390             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2391         \}}
\DoxyCodeLine{2392 }
\DoxyCodeLine{2393         \textcolor{keyword}{template}<\textcolor{keyword}{typename} RhsT>}
\DoxyCodeLine{2394         \textcolor{keyword}{auto} operator || ( RhsT \textcolor{keyword}{const}\& ) -\/> \mbox{\hyperlink{class_catch_1_1_binary_expr}{BinaryExpr<LhsT, RhsT const\&>}} \textcolor{keyword}{const} \{}
\DoxyCodeLine{2395             \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{struct_catch_1_1always__false}{always\_false<RhsT>::value}},}
\DoxyCodeLine{2396             \textcolor{stringliteral}{"{}operator|| is not supported inside assertions, "{}}}
\DoxyCodeLine{2397             \textcolor{stringliteral}{"{}wrap the expression inside parentheses, or decompose it"{}});}
\DoxyCodeLine{2398         \}}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400         \textcolor{keyword}{auto} makeUnaryExpr() \textcolor{keyword}{const} -\/> \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr<LhsT>}} \{}
\DoxyCodeLine{2401             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_unary_expr}{UnaryExpr<LhsT>}}\{ m\_lhs \};}
\DoxyCodeLine{2402         \}}
\DoxyCodeLine{2403     \};}
\DoxyCodeLine{2404 }
\DoxyCodeLine{2405     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2406 }
\DoxyCodeLine{2407     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2408     \textcolor{keywordtype}{void} handleExpression( \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2409         handleExpression( expr.makeUnaryExpr() );}
\DoxyCodeLine{2410     \}}
\DoxyCodeLine{2411 }
\DoxyCodeLine{2412     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_decomposer}{Decomposer}} \{}
\DoxyCodeLine{2413         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2414         \textcolor{keyword}{auto} operator <= ( T \textcolor{keyword}{const}\& lhs ) -\/> \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T const\&>}} \{}
\DoxyCodeLine{2415             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T const\&>}}\{ lhs \};}
\DoxyCodeLine{2416         \}}
\DoxyCodeLine{2417 }
\DoxyCodeLine{2418         \textcolor{keyword}{auto} operator <=( \textcolor{keywordtype}{bool} value ) -\/> \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<bool>}} \{}
\DoxyCodeLine{2419             \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<bool>}}\{ value \};}
\DoxyCodeLine{2420         \}}
\DoxyCodeLine{2421     \};}
\DoxyCodeLine{2422 }
\DoxyCodeLine{2423 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2424 }
\DoxyCodeLine{2425 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{2426 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{2427 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2428 }
\DoxyCodeLine{2429 \textcolor{comment}{// end catch\_decomposer.h}}
\DoxyCodeLine{2430 \textcolor{comment}{// start catch\_interfaces\_capture.h}}
\DoxyCodeLine{2431 }
\DoxyCodeLine{2432 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2433 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{2434 }
\DoxyCodeLine{2435 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2436 }
\DoxyCodeLine{2437     \textcolor{keyword}{class }AssertionResult;}
\DoxyCodeLine{2438     \textcolor{keyword}{struct }AssertionInfo;}
\DoxyCodeLine{2439     \textcolor{keyword}{struct }SectionInfo;}
\DoxyCodeLine{2440     \textcolor{keyword}{struct }SectionEndInfo;}
\DoxyCodeLine{2441     \textcolor{keyword}{struct }MessageInfo;}
\DoxyCodeLine{2442     \textcolor{keyword}{struct }MessageBuilder;}
\DoxyCodeLine{2443     \textcolor{keyword}{struct }Counts;}
\DoxyCodeLine{2444     \textcolor{keyword}{struct }AssertionReaction;}
\DoxyCodeLine{2445     \textcolor{keyword}{struct }SourceLineInfo;}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447     \textcolor{keyword}{struct }ITransientExpression;}
\DoxyCodeLine{2448     \textcolor{keyword}{struct }IGeneratorTracker;}
\DoxyCodeLine{2449 }
\DoxyCodeLine{2450 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2451     \textcolor{keyword}{struct }BenchmarkInfo;}
\DoxyCodeLine{2452     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration = std::chrono::duration<\textcolor{keywordtype}{double}, std::nano>>}
\DoxyCodeLine{2453     \textcolor{keyword}{struct }BenchmarkStats;}
\DoxyCodeLine{2454 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2455 }
\DoxyCodeLine{2456     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}} \{}
\DoxyCodeLine{2457 }
\DoxyCodeLine{2458         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{\string~IResultCapture}}();}
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} sectionStarted(    \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \textcolor{keyword}{const}\& sectionInfo,}
\DoxyCodeLine{2461                                         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}}\& assertions ) = 0;}
\DoxyCodeLine{2462         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( \mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2463         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEndedEarly( \mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \textcolor{keyword}{const}\& endInfo ) = 0;}
\DoxyCodeLine{2464 }
\DoxyCodeLine{2465         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} acquireGeneratorTracker( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} generatorName, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) -\/> \mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{IGeneratorTracker}}\& = 0;}
\DoxyCodeLine{2466 }
\DoxyCodeLine{2467 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{2468         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) = 0;}
\DoxyCodeLine{2469         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2470         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) = 0;}
\DoxyCodeLine{2471         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) = 0;}
\DoxyCodeLine{2472 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{2473 }
\DoxyCodeLine{2474         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} pushScopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2475         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} popScopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& message ) = 0;}
\DoxyCodeLine{2476 }
\DoxyCodeLine{2477         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} emplaceUnscopedMessage( \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} \textcolor{keyword}{const}\& builder ) = 0;}
\DoxyCodeLine{2478 }
\DoxyCodeLine{2479         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleFatalErrorCondition( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} message ) = 0;}
\DoxyCodeLine{2480 }
\DoxyCodeLine{2481         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{2482                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2483                     \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{2484                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2485         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{2486                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2487                     ResultWas::OfType resultType,}
\DoxyCodeLine{2488                     \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2489                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2490         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{2491                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2492                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2493         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{2494                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{2495                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{2496                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}}\& reaction ) = 0;}
\DoxyCodeLine{2497         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{2498                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const}\& info ) = 0;}
\DoxyCodeLine{2499         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{2500                 (   \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{2501                     ResultWas::OfType resultType,}
\DoxyCodeLine{2502                     \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} \&reaction ) = 0;}
\DoxyCodeLine{2503 }
\DoxyCodeLine{2504         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} lastAssertionPassed() = 0;}
\DoxyCodeLine{2505         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionPassed() = 0;}
\DoxyCodeLine{2506 }
\DoxyCodeLine{2507         \textcolor{comment}{// Deprecated, do not use:}}
\DoxyCodeLine{2508         \textcolor{keyword}{virtual} std::string getCurrentTestName() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2509         \textcolor{keyword}{virtual} \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2510         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} exceptionEarlyReported() = 0;}
\DoxyCodeLine{2511     \};}
\DoxyCodeLine{2512 }
\DoxyCodeLine{2513     \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& getResultCapture();}
\DoxyCodeLine{2514 \}}
\DoxyCodeLine{2515 }
\DoxyCodeLine{2516 \textcolor{comment}{// end catch\_interfaces\_capture.h}}
\DoxyCodeLine{2517 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_test_failure_exception}{TestFailureException}}\{\};}
\DoxyCodeLine{2520     \textcolor{keyword}{struct }AssertionResultData;}
\DoxyCodeLine{2521     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}};}
\DoxyCodeLine{2522     \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2523 }
\DoxyCodeLine{2524     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \{}
\DoxyCodeLine{2525         \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}};}
\DoxyCodeLine{2526         \textcolor{keyword}{friend} \textcolor{keyword}{struct }AssertionStats;}
\DoxyCodeLine{2527         \textcolor{keyword}{friend} \textcolor{keyword}{class }RunContext;}
\DoxyCodeLine{2528 }
\DoxyCodeLine{2529         \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}* m\_transientExpression = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2530         \textcolor{keywordtype}{bool} m\_isNegated;}
\DoxyCodeLine{2531     \textcolor{keyword}{public}:}
\DoxyCodeLine{2532         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}( \textcolor{keywordtype}{bool} isNegated );}
\DoxyCodeLine{2533         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}( \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2534         \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2535 }
\DoxyCodeLine{2536         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << ( std::ostream\& os, \mbox{\hyperlink{class_catch_1_1_lazy_expression}{LazyExpression}} \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\&;}
\DoxyCodeLine{2539     \};}
\DoxyCodeLine{2540 }
\DoxyCodeLine{2541     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} \{}
\DoxyCodeLine{2542         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{2543         \textcolor{keywordtype}{bool} shouldThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{2544     \};}
\DoxyCodeLine{2545 }
\DoxyCodeLine{2546     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}} \{}
\DoxyCodeLine{2547         \mbox{\hyperlink{struct_catch_1_1_assertion_info}{AssertionInfo}} m\_assertionInfo;}
\DoxyCodeLine{2548         \mbox{\hyperlink{struct_catch_1_1_assertion_reaction}{AssertionReaction}} m\_reaction;}
\DoxyCodeLine{2549         \textcolor{keywordtype}{bool} m\_completed = \textcolor{keyword}{false};}
\DoxyCodeLine{2550         \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& m\_resultCapture;}
\DoxyCodeLine{2551 }
\DoxyCodeLine{2552     \textcolor{keyword}{public}:}
\DoxyCodeLine{2553         \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}}
\DoxyCodeLine{2554             (   \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2555                 \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2556                 \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} capturedExpression,}
\DoxyCodeLine{2557                 ResultDisposition::Flags resultDisposition );}
\DoxyCodeLine{2558         \mbox{\hyperlink{class_catch_1_1_assertion_handler}{\string~AssertionHandler}}() \{}
\DoxyCodeLine{2559             \textcolor{keywordflow}{if} ( !m\_completed ) \{}
\DoxyCodeLine{2560                 m\_resultCapture.handleIncomplete( m\_assertionInfo );}
\DoxyCodeLine{2561             \}}
\DoxyCodeLine{2562         \}}
\DoxyCodeLine{2563 }
\DoxyCodeLine{2564         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2565         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{class_catch_1_1_expr_lhs}{ExprLhs<T>}} \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{2566             handleExpr( expr.makeUnaryExpr() );}
\DoxyCodeLine{2567         \}}
\DoxyCodeLine{2568         \textcolor{keywordtype}{void} handleExpr( \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \textcolor{keyword}{const}\& expr );}
\DoxyCodeLine{2569 }
\DoxyCodeLine{2570         \textcolor{keywordtype}{void} handleMessage(ResultWas::OfType resultType, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{2571 }
\DoxyCodeLine{2572         \textcolor{keywordtype}{void} handleExceptionThrownAsExpected();}
\DoxyCodeLine{2573         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown();}
\DoxyCodeLine{2574         \textcolor{keywordtype}{void} handleExceptionNotThrownAsExpected();}
\DoxyCodeLine{2575         \textcolor{keywordtype}{void} handleThrowingCallSkipped();}
\DoxyCodeLine{2576         \textcolor{keywordtype}{void} handleUnexpectedInflightException();}
\DoxyCodeLine{2577 }
\DoxyCodeLine{2578         \textcolor{keywordtype}{void} complete();}
\DoxyCodeLine{2579         \textcolor{keywordtype}{void} setCompleted();}
\DoxyCodeLine{2580 }
\DoxyCodeLine{2581         \textcolor{comment}{// query}}
\DoxyCodeLine{2582         \textcolor{keyword}{auto} allowThrows() \textcolor{keyword}{const} -\/> bool;}
\DoxyCodeLine{2583     \};}
\DoxyCodeLine{2584 }
\DoxyCodeLine{2585     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}\& handler, std::string \textcolor{keyword}{const}\& str, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString );}
\DoxyCodeLine{2586 }
\DoxyCodeLine{2587 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589 \textcolor{comment}{// end catch\_assertionhandler.h}}
\DoxyCodeLine{2590 \textcolor{comment}{// start catch\_message.h}}
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2593 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{2594 }
\DoxyCodeLine{2595 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \{}
\DoxyCodeLine{2598         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}}(    \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{2599                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2600                         ResultWas::OfType \_type );}
\DoxyCodeLine{2601 }
\DoxyCodeLine{2602         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName;}
\DoxyCodeLine{2603         std::string message;}
\DoxyCodeLine{2604         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2605         ResultWas::OfType type;}
\DoxyCodeLine{2606         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sequence;}
\DoxyCodeLine{2607 }
\DoxyCodeLine{2608         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2609         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2610     \textcolor{keyword}{private}:}
\DoxyCodeLine{2611         \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} globalCount;}
\DoxyCodeLine{2612     \};}
\DoxyCodeLine{2613 }
\DoxyCodeLine{2614     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}} \{}
\DoxyCodeLine{2615 }
\DoxyCodeLine{2616         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2617         \mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2618             m\_stream << value;}
\DoxyCodeLine{2619             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2620         \}}
\DoxyCodeLine{2621 }
\DoxyCodeLine{2622         \mbox{\hyperlink{class_catch_1_1_reusable_string_stream}{ReusableStringStream}} m\_stream;}
\DoxyCodeLine{2623     \};}
\DoxyCodeLine{2624 }
\DoxyCodeLine{2625     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} : \mbox{\hyperlink{struct_catch_1_1_message_stream}{MessageStream}} \{}
\DoxyCodeLine{2626         \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{2627                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{2628                         ResultWas::OfType type );}
\DoxyCodeLine{2629 }
\DoxyCodeLine{2630         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2631         \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}}\& operator << ( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2632             m\_stream << value;}
\DoxyCodeLine{2633             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2634         \}}
\DoxyCodeLine{2635 }
\DoxyCodeLine{2636         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} m\_info;}
\DoxyCodeLine{2637     \};}
\DoxyCodeLine{2638 }
\DoxyCodeLine{2639     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}} \{}
\DoxyCodeLine{2640     \textcolor{keyword}{public}:}
\DoxyCodeLine{2641         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{struct_catch_1_1_message_builder}{MessageBuilder}} \textcolor{keyword}{const}\& builder );}
\DoxyCodeLine{2642         \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}\& duplicate ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2643         \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}( \mbox{\hyperlink{class_catch_1_1_scoped_message}{ScopedMessage}}\&\& old );}
\DoxyCodeLine{2644         \mbox{\hyperlink{class_catch_1_1_scoped_message}{\string~ScopedMessage}}();}
\DoxyCodeLine{2645 }
\DoxyCodeLine{2646         \mbox{\hyperlink{struct_catch_1_1_message_info}{MessageInfo}} m\_info;}
\DoxyCodeLine{2647         \textcolor{keywordtype}{bool} m\_moved;}
\DoxyCodeLine{2648     \};}
\DoxyCodeLine{2649 }
\DoxyCodeLine{2650     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_capturer}{Capturer}} \{}
\DoxyCodeLine{2651         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{2652         \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}\& m\_resultCapture = getResultCapture();}
\DoxyCodeLine{2653         \textcolor{keywordtype}{size\_t} m\_captured = 0;}
\DoxyCodeLine{2654     \textcolor{keyword}{public}:}
\DoxyCodeLine{2655         \mbox{\hyperlink{class_catch_1_1_capturer}{Capturer}}( \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} macroName, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} names );}
\DoxyCodeLine{2656         \mbox{\hyperlink{class_catch_1_1_capturer}{\string~Capturer}}();}
\DoxyCodeLine{2657 }
\DoxyCodeLine{2658         \textcolor{keywordtype}{void} captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value );}
\DoxyCodeLine{2659 }
\DoxyCodeLine{2660         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2661         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{2662             captureValue( index, Catch::Detail::stringify( value ) );}
\DoxyCodeLine{2663         \}}
\DoxyCodeLine{2664 }
\DoxyCodeLine{2665         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{2666         \textcolor{keywordtype}{void} captureValues( \textcolor{keywordtype}{size\_t} index, T \textcolor{keyword}{const}\& value, Ts \textcolor{keyword}{const}\&... values ) \{}
\DoxyCodeLine{2667             captureValue( index, Catch::Detail::stringify(value) );}
\DoxyCodeLine{2668             captureValues( index+1, values... );}
\DoxyCodeLine{2669         \}}
\DoxyCodeLine{2670     \};}
\DoxyCodeLine{2671 }
\DoxyCodeLine{2672 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2673 }
\DoxyCodeLine{2674 \textcolor{comment}{// end catch\_message.h}}
\DoxyCodeLine{2675 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_STRINGIFICATION)}}
\DoxyCodeLine{2678 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) \#\_\_VA\_ARGS\_\_}}
\DoxyCodeLine{2679 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2680 \textcolor{preprocessor}{  \#define CATCH\_INTERNAL\_STRINGIFY(...) "{}Disabled by CATCH\_CONFIG\_DISABLE\_STRINGIFICATION"{}}}
\DoxyCodeLine{2681 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2682 }
\DoxyCodeLine{2683 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_FAST\_COMPILE) || defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2686 \textcolor{comment}{// Another way to speed-\/up compilation is to omit local try-\/catch for REQUIRE*}}
\DoxyCodeLine{2687 \textcolor{comment}{// macros.}}
\DoxyCodeLine{2688 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY}}
\DoxyCodeLine{2689 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( capturer )}}
\DoxyCodeLine{2690 }
\DoxyCodeLine{2691 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_FAST\_COMPILE}}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRY try}}
\DoxyCodeLine{2694 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CATCH( handler ) catch(...) \{ handler.handleUnexpectedInflightException(); \}}}
\DoxyCodeLine{2695 }
\DoxyCodeLine{2696 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2697 }
\DoxyCodeLine{2698 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_REACT( handler ) handler.complete();}}
\DoxyCodeLine{2699 }
\DoxyCodeLine{2701 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TEST( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2702 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2703 \textcolor{preprocessor}{        CATCH\_INTERNAL\_IGNORE\_BUT\_WARN(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2704 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2705 \textcolor{preprocessor}{        INTERNAL\_CATCH\_TRY \{ \(\backslash\)}}
\DoxyCodeLine{2706 \textcolor{preprocessor}{            CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2707 \textcolor{preprocessor}{            CATCH\_INTERNAL\_SUPPRESS\_PARENTHESES\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2708 \textcolor{preprocessor}{            catchAssertionHandler.handleExpr( Catch::Decomposer() <= \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2709 \textcolor{preprocessor}{            CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2710 \textcolor{preprocessor}{        \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2711 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2712 \textcolor{preprocessor}{    \} while( (void)0, (false) \&\& static\_cast<bool>( !!(\_\_VA\_ARGS\_\_) ) )}}
\DoxyCodeLine{2713 }
\DoxyCodeLine{2715 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_IF( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2716 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2717 \textcolor{preprocessor}{    if( Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2718 }
\DoxyCodeLine{2720 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_ELSE( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2721 \textcolor{preprocessor}{    INTERNAL\_CATCH\_TEST( macroName, resultDisposition, \_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2722 \textcolor{preprocessor}{    if( !Catch::getResultCapture().lastAssertionPassed() )}}
\DoxyCodeLine{2723 }
\DoxyCodeLine{2725 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_NO\_THROW( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2726 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2727 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2728 \textcolor{preprocessor}{        try \{ \(\backslash\)}}
\DoxyCodeLine{2729 \textcolor{preprocessor}{            static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2730 \textcolor{preprocessor}{            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2731 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2732 \textcolor{preprocessor}{        catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2733 \textcolor{preprocessor}{            catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}}
\DoxyCodeLine{2734 \textcolor{preprocessor}{        \} \(\backslash\)}}
\DoxyCodeLine{2735 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2736 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2737 }
\DoxyCodeLine{2739 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS( macroName, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2740 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2741 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_), resultDisposition); \(\backslash\)}}
\DoxyCodeLine{2742 \textcolor{preprocessor}{        if( catchAssertionHandler.allowThrows() ) \(\backslash\)}}
\DoxyCodeLine{2743 \textcolor{preprocessor}{            try \{ \(\backslash\)}}
\DoxyCodeLine{2744 \textcolor{preprocessor}{                static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}}
\DoxyCodeLine{2745 \textcolor{preprocessor}{                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}}
\DoxyCodeLine{2746 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2747 \textcolor{preprocessor}{            catch( ... ) \{ \(\backslash\)}}
\DoxyCodeLine{2748 \textcolor{preprocessor}{                catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}}
\DoxyCodeLine{2749 \textcolor{preprocessor}{            \} \(\backslash\)}}
\DoxyCodeLine{2750 \textcolor{preprocessor}{        else \(\backslash\)}}
\DoxyCodeLine{2751 \textcolor{preprocessor}{            catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}}
\DoxyCodeLine{2752 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2753 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2754 }
\DoxyCodeLine{2756 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_AS( macroName, exceptionType, resultDisposition, expr ) \(\backslash\)}}
\DoxyCodeLine{2757 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2758 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(expr) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2759         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2760             try \{ \(\backslash\)}
\DoxyCodeLine{2761                 static\_cast<void>(expr); \(\backslash\)}
\DoxyCodeLine{2762                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2763             \} \(\backslash\)}
\DoxyCodeLine{2764             catch( exceptionType const\& ) \{ \(\backslash\)}
\DoxyCodeLine{2765                 catchAssertionHandler.handleExceptionThrownAsExpected(); \(\backslash\)}
\DoxyCodeLine{2766             \} \(\backslash\)}
\DoxyCodeLine{2767             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2768                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{2769             \} \(\backslash\)}
\DoxyCodeLine{2770         else \(\backslash\)}
\DoxyCodeLine{2771             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2772         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2773     \} while( false )}
\DoxyCodeLine{2774 }
\DoxyCodeLine{2776 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_MSG( macroName, messageType, resultDisposition, ... ) \(\backslash\)}}
\DoxyCodeLine{2777 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2778 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::StringRef(), resultDisposition ); \(\backslash\)}}
\DoxyCodeLine{2779 \textcolor{preprocessor}{        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << \_\_VA\_ARGS\_\_ + ::Catch::StreamEndStop() ).m\_stream.str() ); \(\backslash\)}}
\DoxyCodeLine{2780 \textcolor{preprocessor}{        INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}}
\DoxyCodeLine{2781 \textcolor{preprocessor}{    \} while( false )}}
\DoxyCodeLine{2782 }
\DoxyCodeLine{2784 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_CAPTURE( varName, macroName, ... ) \(\backslash\)}}
\DoxyCodeLine{2785 \textcolor{preprocessor}{    auto varName = Catch::Capturer( macroName, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info, \#\_\_VA\_ARGS\_\_ ); \(\backslash\)}}
\DoxyCodeLine{2786 \textcolor{preprocessor}{    varName.captureValues( 0, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{2787 }
\DoxyCodeLine{2789 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2790 \textcolor{preprocessor}{    Catch::ScopedMessage INTERNAL\_CATCH\_UNIQUE\_NAME( scopedMessage )( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log );}}
\DoxyCodeLine{2791 }
\DoxyCodeLine{2793 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_UNSCOPED\_INFO( macroName, log ) \(\backslash\)}}
\DoxyCodeLine{2794 \textcolor{preprocessor}{    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, Catch::ResultWas::Info ) << log )}}
\DoxyCodeLine{2795 }
\DoxyCodeLine{2797 \textcolor{comment}{// Although this is matcher-\/based, it can be used with just a string}}
\DoxyCodeLine{2798 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( macroName, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{2799 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{2800 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{2801         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{2802             try \{ \(\backslash\)}
\DoxyCodeLine{2803                 static\_cast<void>(\_\_VA\_ARGS\_\_); \(\backslash\)}
\DoxyCodeLine{2804                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{2805             \} \(\backslash\)}
\DoxyCodeLine{2806             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{2807                 Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, \#matcher\#\#\_catch\_sr ); \(\backslash\)}
\DoxyCodeLine{2808             \} \(\backslash\)}
\DoxyCodeLine{2809         else \(\backslash\)}
\DoxyCodeLine{2810             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{2811         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{2812     \} while( false )}
\DoxyCodeLine{2813 }
\DoxyCodeLine{2814 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816 \textcolor{comment}{// end catch\_capture.hpp}}
\DoxyCodeLine{2817 \textcolor{comment}{// start catch\_section.h}}
\DoxyCodeLine{2818 }
\DoxyCodeLine{2819 \textcolor{comment}{// start catch\_section\_info.h}}
\DoxyCodeLine{2820 }
\DoxyCodeLine{2821 \textcolor{comment}{// start catch\_totals.h}}
\DoxyCodeLine{2822 }
\DoxyCodeLine{2823 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{2824 }
\DoxyCodeLine{2825 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2826 }
\DoxyCodeLine{2827     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \{}
\DoxyCodeLine{2828         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} operator -\/ ( \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2829         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}}\& operator += ( \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2830 }
\DoxyCodeLine{2831         std::size\_t total() \textcolor{keyword}{const};}
\DoxyCodeLine{2832         \textcolor{keywordtype}{bool} allPassed() \textcolor{keyword}{const};}
\DoxyCodeLine{2833         \textcolor{keywordtype}{bool} allOk() \textcolor{keyword}{const};}
\DoxyCodeLine{2834 }
\DoxyCodeLine{2835         std::size\_t passed = 0;}
\DoxyCodeLine{2836         std::size\_t failed = 0;}
\DoxyCodeLine{2837         std::size\_t failedButOk = 0;}
\DoxyCodeLine{2838     \};}
\DoxyCodeLine{2839 }
\DoxyCodeLine{2840     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \{}
\DoxyCodeLine{2841 }
\DoxyCodeLine{2842         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} operator -\/ ( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{2843         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}}\& operator += ( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& other );}
\DoxyCodeLine{2844 }
\DoxyCodeLine{2845         \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} delta( \mbox{\hyperlink{struct_catch_1_1_totals}{Totals}} \textcolor{keyword}{const}\& prevTotals ) \textcolor{keyword}{const};}
\DoxyCodeLine{2846 }
\DoxyCodeLine{2847         \textcolor{keywordtype}{int} error = 0;}
\DoxyCodeLine{2848         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} assertions;}
\DoxyCodeLine{2849         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} testCases;}
\DoxyCodeLine{2850     \};}
\DoxyCodeLine{2851 \}}
\DoxyCodeLine{2852 }
\DoxyCodeLine{2853 \textcolor{comment}{// end catch\_totals.h}}
\DoxyCodeLine{2854 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2855 }
\DoxyCodeLine{2856 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2857 }
\DoxyCodeLine{2858     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \{}
\DoxyCodeLine{2859         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}}
\DoxyCodeLine{2860             (   \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2861                 std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{2862 }
\DoxyCodeLine{2863         \textcolor{comment}{// Deprecated}}
\DoxyCodeLine{2864         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}}
\DoxyCodeLine{2865             (   \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{2866                 std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{2867                 std::string \textcolor{keyword}{const}\& ) : \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}}( \_lineInfo, \_name ) \{\}}
\DoxyCodeLine{2868 }
\DoxyCodeLine{2869         std::string name;}
\DoxyCodeLine{2870         std::string description; \textcolor{comment}{// !Deprecated: this will always be empty}}
\DoxyCodeLine{2871         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{2872     \};}
\DoxyCodeLine{2873 }
\DoxyCodeLine{2874     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_section_end_info}{SectionEndInfo}} \{}
\DoxyCodeLine{2875         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} sectionInfo;}
\DoxyCodeLine{2876         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} prevAssertions;}
\DoxyCodeLine{2877         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{2878     \};}
\DoxyCodeLine{2879 }
\DoxyCodeLine{2880 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2881 }
\DoxyCodeLine{2882 \textcolor{comment}{// end catch\_section\_info.h}}
\DoxyCodeLine{2883 \textcolor{comment}{// start catch\_timer.h}}
\DoxyCodeLine{2884 }
\DoxyCodeLine{2885 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{2886 }
\DoxyCodeLine{2887 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2888 }
\DoxyCodeLine{2889     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t;}
\DoxyCodeLine{2890     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t;}
\DoxyCodeLine{2891 }
\DoxyCodeLine{2892     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_timer}{Timer}} \{}
\DoxyCodeLine{2893         uint64\_t m\_nanoseconds = 0;}
\DoxyCodeLine{2894     \textcolor{keyword}{public}:}
\DoxyCodeLine{2895         \textcolor{keywordtype}{void} start();}
\DoxyCodeLine{2896         \textcolor{keyword}{auto} getElapsedNanoseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2897         \textcolor{keyword}{auto} getElapsedMicroseconds() \textcolor{keyword}{const} -\/> uint64\_t;}
\DoxyCodeLine{2898         \textcolor{keyword}{auto} getElapsedMilliseconds() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{unsigned} int;}
\DoxyCodeLine{2899         \textcolor{keyword}{auto} getElapsedSeconds() \textcolor{keyword}{const} -\/> double;}
\DoxyCodeLine{2900     \};}
\DoxyCodeLine{2901 }
\DoxyCodeLine{2902 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{2903 }
\DoxyCodeLine{2904 \textcolor{comment}{// end catch\_timer.h}}
\DoxyCodeLine{2905 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2906 }
\DoxyCodeLine{2907 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2908 }
\DoxyCodeLine{2909     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_section}{Section}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{2910     \textcolor{keyword}{public}:}
\DoxyCodeLine{2911         \mbox{\hyperlink{class_catch_1_1_section}{Section}}( \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} \textcolor{keyword}{const}\& info );}
\DoxyCodeLine{2912         \mbox{\hyperlink{class_catch_1_1_section}{\string~Section}}();}
\DoxyCodeLine{2913 }
\DoxyCodeLine{2914         \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{2915         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const};}
\DoxyCodeLine{2916 }
\DoxyCodeLine{2917     \textcolor{keyword}{private}:}
\DoxyCodeLine{2918         \mbox{\hyperlink{struct_catch_1_1_section_info}{SectionInfo}} m\_info;}
\DoxyCodeLine{2919 }
\DoxyCodeLine{2920         std::string m\_name;}
\DoxyCodeLine{2921         \mbox{\hyperlink{struct_catch_1_1_counts}{Counts}} m\_assertions;}
\DoxyCodeLine{2922         \textcolor{keywordtype}{bool} m\_sectionIncluded;}
\DoxyCodeLine{2923         \mbox{\hyperlink{class_catch_1_1_timer}{Timer}} m\_timer;}
\DoxyCodeLine{2924     \};}
\DoxyCodeLine{2925 }
\DoxyCodeLine{2926 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2929 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2930 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2931 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, \_\_VA\_ARGS\_\_ ) ) \(\backslash\)}}
\DoxyCodeLine{2932 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2933 }
\DoxyCodeLine{2934 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_DYNAMIC\_SECTION( ... ) \(\backslash\)}}
\DoxyCodeLine{2935 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{2936 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_UNUSED\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{2937 \textcolor{preprocessor}{    if( Catch::Section const\& INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_Section ) = Catch::SectionInfo( CATCH\_INTERNAL\_LINEINFO, (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str() ) ) \(\backslash\)}}
\DoxyCodeLine{2938 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{2939 }
\DoxyCodeLine{2940 \textcolor{comment}{// end catch\_section.h}}
\DoxyCodeLine{2941 \textcolor{comment}{// start catch\_interfaces\_exception.h}}
\DoxyCodeLine{2942 }
\DoxyCodeLine{2943 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2944 }
\DoxyCodeLine{2945 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{2946 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{2947 }
\DoxyCodeLine{2948 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{2949 }
\DoxyCodeLine{2950     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{2951     \textcolor{keyword}{struct }ITestCaseRegistry;}
\DoxyCodeLine{2952     \textcolor{keyword}{struct }IExceptionTranslatorRegistry;}
\DoxyCodeLine{2953     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{2954     \textcolor{keyword}{struct }IReporterRegistry;}
\DoxyCodeLine{2955     \textcolor{keyword}{struct }IReporterFactory;}
\DoxyCodeLine{2956     \textcolor{keyword}{struct }ITagAliasRegistry;}
\DoxyCodeLine{2957     \textcolor{keyword}{struct }IMutableEnumValuesRegistry;}
\DoxyCodeLine{2958 }
\DoxyCodeLine{2959     \textcolor{keyword}{class }StartupExceptionRegistry;}
\DoxyCodeLine{2960 }
\DoxyCodeLine{2961     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{2962 }
\DoxyCodeLine{2963     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{IRegistryHub}} \{}
\DoxyCodeLine{2964         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{\string~IRegistryHub}}();}
\DoxyCodeLine{2965 }
\DoxyCodeLine{2966         \textcolor{keyword}{virtual} IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2967         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_test_case_registry}{ITestCaseRegistry}} \textcolor{keyword}{const}\& getTestCaseRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2968         \textcolor{keyword}{virtual} ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2969         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{IExceptionTranslatorRegistry}} \textcolor{keyword}{const}\& getExceptionTranslatorRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2970 }
\DoxyCodeLine{2971         \textcolor{keyword}{virtual} StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{2972     \};}
\DoxyCodeLine{2973 }
\DoxyCodeLine{2974     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{IMutableRegistryHub}} \{}
\DoxyCodeLine{2975         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{\string~IMutableRegistryHub}}();}
\DoxyCodeLine{2976         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2977         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) = 0;}
\DoxyCodeLine{2978         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{2979         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}}* translator ) = 0;}
\DoxyCodeLine{2980         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo ) = 0;}
\DoxyCodeLine{2981         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerStartupException() \textcolor{keyword}{noexcept} = 0;}
\DoxyCodeLine{2982         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_enum_values_registry}{IMutableEnumValuesRegistry}}\& getMutableEnumValuesRegistry() = 0;}
\DoxyCodeLine{2983     \};}
\DoxyCodeLine{2984 }
\DoxyCodeLine{2985     \mbox{\hyperlink{struct_catch_1_1_i_registry_hub}{IRegistryHub}} \textcolor{keyword}{const}\& getRegistryHub();}
\DoxyCodeLine{2986     \mbox{\hyperlink{struct_catch_1_1_i_mutable_registry_hub}{IMutableRegistryHub}}\& getMutableRegistryHub();}
\DoxyCodeLine{2987     \textcolor{keywordtype}{void} cleanUp();}
\DoxyCodeLine{2988     std::string translateActiveException();}
\DoxyCodeLine{2989 }
\DoxyCodeLine{2990 \}}
\DoxyCodeLine{2991 }
\DoxyCodeLine{2992 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.h}}
\DoxyCodeLine{2993 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{2994 \textcolor{preprocessor}{    \#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( translatorName, signature) \(\backslash\)}}
\DoxyCodeLine{2995 \textcolor{preprocessor}{        static std::string translatorName( signature )}}
\DoxyCodeLine{2996 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2997 }
\DoxyCodeLine{2998 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{2999 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3000 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3001 }
\DoxyCodeLine{3002 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3003     \textcolor{keyword}{using} exceptionTranslateFunction = std::string(*)();}
\DoxyCodeLine{3004 }
\DoxyCodeLine{3005     \textcolor{keyword}{struct }IExceptionTranslator;}
\DoxyCodeLine{3006     \textcolor{keyword}{using} ExceptionTranslators = std::vector<std::unique\_ptr<IExceptionTranslator const>>;}
\DoxyCodeLine{3007 }
\DoxyCodeLine{3008     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3009         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{\string~IExceptionTranslator}}();}
\DoxyCodeLine{3010         \textcolor{keyword}{virtual} std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3011     \};}
\DoxyCodeLine{3012 }
\DoxyCodeLine{3013     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{IExceptionTranslatorRegistry}} \{}
\DoxyCodeLine{3014         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator_registry}{\string~IExceptionTranslatorRegistry}}();}
\DoxyCodeLine{3015 }
\DoxyCodeLine{3016         \textcolor{keyword}{virtual} std::string translateActiveException() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3017     \};}
\DoxyCodeLine{3018 }
\DoxyCodeLine{3019     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_exception_translator_registrar}{ExceptionTranslatorRegistrar}} \{}
\DoxyCodeLine{3020         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3021         \textcolor{keyword}{class }ExceptionTranslator : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_exception_translator}{IExceptionTranslator}} \{}
\DoxyCodeLine{3022         \textcolor{keyword}{public}:}
\DoxyCodeLine{3023 }
\DoxyCodeLine{3024             ExceptionTranslator( std::string(*translateFunction)( T\& ) )}
\DoxyCodeLine{3025             : m\_translateFunction( translateFunction )}
\DoxyCodeLine{3026             \{\}}
\DoxyCodeLine{3027 }
\DoxyCodeLine{3028             std::string translate( ExceptionTranslators::const\_iterator it, ExceptionTranslators::const\_iterator itEnd )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3029 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3030                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3031 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{3032                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{3033                     \textcolor{keywordflow}{if}( it == itEnd )}
\DoxyCodeLine{3034                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{3035                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3036                         \textcolor{keywordflow}{return} (*it)-\/>translate( it+1, itEnd );}
\DoxyCodeLine{3037                 \}}
\DoxyCodeLine{3038                 \textcolor{keywordflow}{catch}( T\& ex ) \{}
\DoxyCodeLine{3039                     \textcolor{keywordflow}{return} m\_translateFunction( ex );}
\DoxyCodeLine{3040                 \}}
\DoxyCodeLine{3041 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3042             \}}
\DoxyCodeLine{3043 }
\DoxyCodeLine{3044         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3045             std::string(*m\_translateFunction)( T\& );}
\DoxyCodeLine{3046         \};}
\DoxyCodeLine{3047 }
\DoxyCodeLine{3048     \textcolor{keyword}{public}:}
\DoxyCodeLine{3049         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3050         \mbox{\hyperlink{class_catch_1_1_exception_translator_registrar}{ExceptionTranslatorRegistrar}}( std::string(*translateFunction)( T\& ) ) \{}
\DoxyCodeLine{3051             getMutableRegistryHub().registerTranslator}
\DoxyCodeLine{3052                 ( \textcolor{keyword}{new} ExceptionTranslator<T>( translateFunction ) );}
\DoxyCodeLine{3053         \}}
\DoxyCodeLine{3054     \};}
\DoxyCodeLine{3055 \}}
\DoxyCodeLine{3056 }
\DoxyCodeLine{3058 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( translatorName, signature ) \(\backslash\)}}
\DoxyCodeLine{3059 \textcolor{preprocessor}{    static std::string translatorName( signature ); \(\backslash\)}}
\DoxyCodeLine{3060 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3061 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS \(\backslash\)}}
\DoxyCodeLine{3062 \textcolor{preprocessor}{    namespace\{ Catch::ExceptionTranslatorRegistrar INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionRegistrar )( \&translatorName ); \} \(\backslash\)}}
\DoxyCodeLine{3063 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION \(\backslash\)}}
\DoxyCodeLine{3064 \textcolor{preprocessor}{    static std::string translatorName( signature )}}
\DoxyCodeLine{3065 }
\DoxyCodeLine{3066 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION2( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{3067 }
\DoxyCodeLine{3068 \textcolor{comment}{// end catch\_interfaces\_exception.h}}
\DoxyCodeLine{3069 \textcolor{comment}{// start catch\_approx.h}}
\DoxyCodeLine{3070 }
\DoxyCodeLine{3071 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{3072 }
\DoxyCodeLine{3073 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3074 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3075 }
\DoxyCodeLine{3076     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \{}
\DoxyCodeLine{3077     \textcolor{keyword}{private}:}
\DoxyCodeLine{3078         \textcolor{keywordtype}{bool} equalityComparisonImpl(\textcolor{keywordtype}{double} other) \textcolor{keyword}{const};}
\DoxyCodeLine{3079         \textcolor{comment}{// Validates the new margin (margin >= 0)}}
\DoxyCodeLine{3080         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3081         \textcolor{keywordtype}{void} setMargin(\textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3082         \textcolor{comment}{// Validates the new epsilon (0 < epsilon < 1)}}
\DoxyCodeLine{3083         \textcolor{comment}{// out-\/of-\/line to avoid including stdexcept in the header}}
\DoxyCodeLine{3084         \textcolor{keywordtype}{void} setEpsilon(\textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3085 }
\DoxyCodeLine{3086     \textcolor{keyword}{public}:}
\DoxyCodeLine{3087         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} ( \textcolor{keywordtype}{double} value );}
\DoxyCodeLine{3088 }
\DoxyCodeLine{3089         \textcolor{keyword}{static} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} custom();}
\DoxyCodeLine{3090 }
\DoxyCodeLine{3091         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} operator-\/() \textcolor{keyword}{const};}
\DoxyCodeLine{3092 }
\DoxyCodeLine{3093         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3094         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} operator()( T \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{3095             \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} approx( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value) );}
\DoxyCodeLine{3096             approx.m\_epsilon = m\_epsilon;}
\DoxyCodeLine{3097             approx.m\_margin = m\_margin;}
\DoxyCodeLine{3098             approx.m\_scale = m\_scale;}
\DoxyCodeLine{3099             \textcolor{keywordflow}{return} approx;}
\DoxyCodeLine{3100         \}}
\DoxyCodeLine{3101 }
\DoxyCodeLine{3102         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3103         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( T \textcolor{keyword}{const}\& value ): \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{3104         \{\}}
\DoxyCodeLine{3105 }
\DoxyCodeLine{3106         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3107         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \textcolor{keyword}{const} T\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3108             \textcolor{keyword}{auto} lhs\_v = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs);}
\DoxyCodeLine{3109             \textcolor{keywordflow}{return} rhs.equalityComparisonImpl(lhs\_v);}
\DoxyCodeLine{3110         \}}
\DoxyCodeLine{3111 }
\DoxyCodeLine{3112         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3113         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, \textcolor{keyword}{const} T\& rhs ) \{}
\DoxyCodeLine{3114             \textcolor{keywordflow}{return} operator==( rhs, lhs );}
\DoxyCodeLine{3115         \}}
\DoxyCodeLine{3116 }
\DoxyCodeLine{3117         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3118         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3119             \textcolor{keywordflow}{return} !operator==( lhs, rhs );}
\DoxyCodeLine{3120         \}}
\DoxyCodeLine{3121 }
\DoxyCodeLine{3122         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3123         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator != ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3124             \textcolor{keywordflow}{return} !operator==( rhs, lhs );}
\DoxyCodeLine{3125         \}}
\DoxyCodeLine{3126 }
\DoxyCodeLine{3127         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3128         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3129             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) < rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3130         \}}
\DoxyCodeLine{3131 }
\DoxyCodeLine{3132         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3133         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator <= ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3134             \textcolor{keywordflow}{return} lhs.m\_value < \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3135         \}}
\DoxyCodeLine{3136 }
\DoxyCodeLine{3137         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3138         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( T \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3139             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(lhs) > rhs.m\_value || lhs == rhs;}
\DoxyCodeLine{3140         \}}
\DoxyCodeLine{3141 }
\DoxyCodeLine{3142         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3143         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator >= ( \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} \textcolor{keyword}{const}\& lhs, T \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{3144             \textcolor{keywordflow}{return} lhs.m\_value > \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(rhs) || lhs == rhs;}
\DoxyCodeLine{3145         \}}
\DoxyCodeLine{3146 }
\DoxyCodeLine{3147         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3148         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3149             \textcolor{keywordtype}{double} epsilonAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newEpsilon);}
\DoxyCodeLine{3150             setEpsilon(epsilonAsDouble);}
\DoxyCodeLine{3151             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3152         \}}
\DoxyCodeLine{3153 }
\DoxyCodeLine{3154         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3155         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3156             \textcolor{keywordtype}{double} marginAsDouble = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newMargin);}
\DoxyCodeLine{3157             setMargin(marginAsDouble);}
\DoxyCodeLine{3158             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3159         \}}
\DoxyCodeLine{3160 }
\DoxyCodeLine{3161         template <typename T, typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3162         \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3163             m\_scale = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(newScale);}
\DoxyCodeLine{3164             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3165         \}}
\DoxyCodeLine{3166 }
\DoxyCodeLine{3167         std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3168 }
\DoxyCodeLine{3169     \textcolor{keyword}{private}:}
\DoxyCodeLine{3170         \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3171         \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3172         \textcolor{keywordtype}{double} m\_scale;}
\DoxyCodeLine{3173         \textcolor{keywordtype}{double} m\_value;}
\DoxyCodeLine{3174     \};}
\DoxyCodeLine{3175 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{3176 }
\DoxyCodeLine{3177 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{3178     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val);}
\DoxyCodeLine{3179     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}} \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val);}
\DoxyCodeLine{3180 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{3181 }
\DoxyCodeLine{3182 \textcolor{keyword}{template}<>}
\DoxyCodeLine{3183 \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_string_maker}{StringMaker}}<Catch::\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Detail::Approx}}> \{}
\DoxyCodeLine{3184     \textcolor{keyword}{static} std::string convert(\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value);}
\DoxyCodeLine{3185 \};}
\DoxyCodeLine{3186 }
\DoxyCodeLine{3187 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{3188 }
\DoxyCodeLine{3189 \textcolor{comment}{// end catch\_approx.h}}
\DoxyCodeLine{3190 \textcolor{comment}{// start catch\_string\_manip.h}}
\DoxyCodeLine{3191 }
\DoxyCodeLine{3192 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3193 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{3194 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3195 }
\DoxyCodeLine{3196 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3197 }
\DoxyCodeLine{3198     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix );}
\DoxyCodeLine{3199     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix );}
\DoxyCodeLine{3200     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix );}
\DoxyCodeLine{3201     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix );}
\DoxyCodeLine{3202     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix );}
\DoxyCodeLine{3203     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s );}
\DoxyCodeLine{3204     std::string toLower( std::string \textcolor{keyword}{const}\& s );}
\DoxyCodeLine{3206     std::string trim( std::string \textcolor{keyword}{const}\& str );}
\DoxyCodeLine{3208     StringRef trim(StringRef ref);}
\DoxyCodeLine{3209 }
\DoxyCodeLine{3210     \textcolor{comment}{// !!! Be aware, returns refs into original string -\/ make sure original string outlives them}}
\DoxyCodeLine{3211     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter );}
\DoxyCodeLine{3212     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis );}
\DoxyCodeLine{3213 }
\DoxyCodeLine{3214     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}} \{}
\DoxyCodeLine{3215         \mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}}( std::size\_t count, std::string \textcolor{keyword}{const}\& label );}
\DoxyCodeLine{3216 }
\DoxyCodeLine{3217         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, \mbox{\hyperlink{struct_catch_1_1pluralise}{pluralise}} \textcolor{keyword}{const}\& pluraliser );}
\DoxyCodeLine{3218 }
\DoxyCodeLine{3219         std::size\_t m\_count;}
\DoxyCodeLine{3220         std::string m\_label;}
\DoxyCodeLine{3221     \};}
\DoxyCodeLine{3222 \}}
\DoxyCodeLine{3223 }
\DoxyCodeLine{3224 \textcolor{comment}{// end catch\_string\_manip.h}}
\DoxyCodeLine{3225 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{3226 \textcolor{comment}{// start catch\_capture\_matchers.h}}
\DoxyCodeLine{3227 }
\DoxyCodeLine{3228 \textcolor{comment}{// start catch\_matchers.h}}
\DoxyCodeLine{3229 }
\DoxyCodeLine{3230 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3231 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3232 }
\DoxyCodeLine{3233 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3234 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3235     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{3236 }
\DoxyCodeLine{3237         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAllOf;}
\DoxyCodeLine{3238         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchAnyOf;}
\DoxyCodeLine{3239         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT> \textcolor{keyword}{struct }MatchNotOf;}
\DoxyCodeLine{3240 }
\DoxyCodeLine{3241         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \{}
\DoxyCodeLine{3242         \textcolor{keyword}{public}:}
\DoxyCodeLine{3243             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3244             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} ( \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3245             \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}\& operator = ( \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}} \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{3246             std::string toString() \textcolor{keyword}{const};}
\DoxyCodeLine{3247 }
\DoxyCodeLine{3248         \textcolor{keyword}{protected}:}
\DoxyCodeLine{3249             \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{\string~MatcherUntypedBase}}();}
\DoxyCodeLine{3250             \textcolor{keyword}{virtual} std::string describe() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3251             \textcolor{keyword}{mutable} std::string m\_cachedToString;}
\DoxyCodeLine{3252         \};}
\DoxyCodeLine{3253 }
\DoxyCodeLine{3254 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3255 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{3256 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wnon-\/virtual-\/dtor"{}}}
\DoxyCodeLine{3257 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3258 }
\DoxyCodeLine{3259         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ObjectT>}
\DoxyCodeLine{3260         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}} \{}
\DoxyCodeLine{3261             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( ObjectT \textcolor{keyword}{const}\& arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3262         \};}
\DoxyCodeLine{3263 }
\DoxyCodeLine{3264 \textcolor{preprocessor}{\#if defined(\_\_OBJC\_\_)}}
\DoxyCodeLine{3265         \textcolor{comment}{// Hack to fix Catch GH issue \#1661. Could use id for generic Object support.}}
\DoxyCodeLine{3266         \textcolor{comment}{// use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation}}
\DoxyCodeLine{3267         \textcolor{keyword}{template}<>}
\DoxyCodeLine{3268         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}}<NSString*> \{}
\DoxyCodeLine{3269             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} match( NSString* arg ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3270         \};}
\DoxyCodeLine{3271 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3272 }
\DoxyCodeLine{3273 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{3274 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{3275 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3276 }
\DoxyCodeLine{3277         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3278         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} : \mbox{\hyperlink{class_catch_1_1_matchers_1_1_impl_1_1_matcher_untyped_base}{MatcherUntypedBase}}, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_method}{MatcherMethod}}<T> \{}
\DoxyCodeLine{3279 }
\DoxyCodeLine{3280             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}} operator \&\& ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3281             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf<T>}} operator || ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{3282             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf<T>}} operator ! () \textcolor{keyword}{const};}
\DoxyCodeLine{3283         \};}
\DoxyCodeLine{3284 }
\DoxyCodeLine{3285         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3286         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3287             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3288                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3289                     \textcolor{keywordflow}{if} (!matcher-\/>match(arg))}
\DoxyCodeLine{3290                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3291                 \}}
\DoxyCodeLine{3292                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3293             \}}
\DoxyCodeLine{3294             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3295                 std::string description;}
\DoxyCodeLine{3296                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3297                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3298                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3299                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3300                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3301                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3302                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3303                         description += \textcolor{stringliteral}{"{} and "{}};}
\DoxyCodeLine{3304                     description += matcher-\/>toString();}
\DoxyCodeLine{3305                 \}}
\DoxyCodeLine{3306                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3307                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3308             \}}
\DoxyCodeLine{3309 }
\DoxyCodeLine{3310             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<ArgT>}} operator \&\& ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3311                 \textcolor{keyword}{auto} copy(*\textcolor{keyword}{this});}
\DoxyCodeLine{3312                 copy.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3313                 \textcolor{keywordflow}{return} copy;}
\DoxyCodeLine{3314             \}}
\DoxyCodeLine{3315 }
\DoxyCodeLine{3316             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3317         \};}
\DoxyCodeLine{3318         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3319         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3320 }
\DoxyCodeLine{3321             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3322                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3323                     \textcolor{keywordflow}{if} (matcher-\/>match(arg))}
\DoxyCodeLine{3324                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3325                 \}}
\DoxyCodeLine{3326                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3327             \}}
\DoxyCodeLine{3328             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3329                 std::string description;}
\DoxyCodeLine{3330                 description.reserve( 4 + m\_matchers.size()*32 );}
\DoxyCodeLine{3331                 description += \textcolor{stringliteral}{"{}( "{}};}
\DoxyCodeLine{3332                 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{3333                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} matcher : m\_matchers ) \{}
\DoxyCodeLine{3334                     \textcolor{keywordflow}{if}( first )}
\DoxyCodeLine{3335                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{3336                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3337                         description += \textcolor{stringliteral}{"{} or "{}};}
\DoxyCodeLine{3338                     description += matcher-\/>toString();}
\DoxyCodeLine{3339                 \}}
\DoxyCodeLine{3340                 description += \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{3341                 \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{3342             \}}
\DoxyCodeLine{3343 }
\DoxyCodeLine{3344             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_any_of}{MatchAnyOf<ArgT>}} operator || ( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{3345                 \textcolor{keyword}{auto} copy(*\textcolor{keyword}{this});}
\DoxyCodeLine{3346                 copy.m\_matchers.push\_back( \&other );}
\DoxyCodeLine{3347                 \textcolor{keywordflow}{return} copy;}
\DoxyCodeLine{3348             \}}
\DoxyCodeLine{3349 }
\DoxyCodeLine{3350             std::vector<MatcherBase<ArgT> \textcolor{keyword}{const}*> m\_matchers;}
\DoxyCodeLine{3351         \};}
\DoxyCodeLine{3352 }
\DoxyCodeLine{3353         \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{3354         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<ArgT> \{}
\DoxyCodeLine{3355 }
\DoxyCodeLine{3356             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_not_of}{MatchNotOf}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& underlyingMatcher ) : m\_underlyingMatcher( underlyingMatcher ) \{\}}
\DoxyCodeLine{3357 }
\DoxyCodeLine{3358             \textcolor{keywordtype}{bool} match( ArgT \textcolor{keyword}{const}\& arg )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3359                 \textcolor{keywordflow}{return} !m\_underlyingMatcher.match( arg );}
\DoxyCodeLine{3360             \}}
\DoxyCodeLine{3361 }
\DoxyCodeLine{3362             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3363                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}not "{}} + m\_underlyingMatcher.toString();}
\DoxyCodeLine{3364             \}}
\DoxyCodeLine{3365             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<ArgT>}} \textcolor{keyword}{const}\& m\_underlyingMatcher;}
\DoxyCodeLine{3366         \};}
\DoxyCodeLine{3367 }
\DoxyCodeLine{3368         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3369         \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator \&\& }}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3370             \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_match_all_of}{MatchAllOf<T>}}() \&\& *\textcolor{keyword}{this} \&\& other;}
\DoxyCodeLine{3371         \}}
\DoxyCodeLine{3372         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3373         MatchAnyOf<T> \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator || }}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}} \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3374             \textcolor{keywordflow}{return} MatchAnyOf<T>() || *\textcolor{keyword}{this} || other;}
\DoxyCodeLine{3375         \}}
\DoxyCodeLine{3376         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3377         MatchNotOf<T> \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase<T>::operator ! }}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3378             \textcolor{keywordflow}{return} MatchNotOf<T>( *\textcolor{keyword}{this} );}
\DoxyCodeLine{3379         \}}
\DoxyCodeLine{3380 }
\DoxyCodeLine{3381     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{3382 }
\DoxyCodeLine{3383 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3384 }
\DoxyCodeLine{3385 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{3386 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{3387 }
\DoxyCodeLine{3388 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3389 }
\DoxyCodeLine{3390 \textcolor{comment}{// end catch\_matchers.h}}
\DoxyCodeLine{3391 \textcolor{comment}{// start catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3392 }
\DoxyCodeLine{3393 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3394 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3395 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{3396 }
\DoxyCodeLine{3397 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{ExceptionMessageMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::exception> \{}
\DoxyCodeLine{3398     std::string m\_message;}
\DoxyCodeLine{3399 \textcolor{keyword}{public}:}
\DoxyCodeLine{3400 }
\DoxyCodeLine{3401     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{ExceptionMessageMatcher}}(std::string \textcolor{keyword}{const}\& message):}
\DoxyCodeLine{3402         m\_message(message)}
\DoxyCodeLine{3403     \{\}}
\DoxyCodeLine{3404 }
\DoxyCodeLine{3405     \textcolor{keywordtype}{bool} match(std::exception \textcolor{keyword}{const}\& ex) \textcolor{keyword}{const override};}
\DoxyCodeLine{3406 }
\DoxyCodeLine{3407     std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3408 \};}
\DoxyCodeLine{3409 }
\DoxyCodeLine{3410 \} \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{3411 }
\DoxyCodeLine{3412 \mbox{\hyperlink{class_catch_1_1_matchers_1_1_exception_1_1_exception_message_matcher}{Exception::ExceptionMessageMatcher}} Message(std::string \textcolor{keyword}{const}\& message);}
\DoxyCodeLine{3413 }
\DoxyCodeLine{3414 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3415 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3416 }
\DoxyCodeLine{3417 \textcolor{comment}{// end catch\_matchers\_exception.hpp}}
\DoxyCodeLine{3418 \textcolor{comment}{// start catch\_matchers\_floating.h}}
\DoxyCodeLine{3419 }
\DoxyCodeLine{3420 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3421 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3422 }
\DoxyCodeLine{3423     \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{3424 }
\DoxyCodeLine{3425         \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t;}
\DoxyCodeLine{3426 }
\DoxyCodeLine{3427         struct \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{WithinAbsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3428             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{WithinAbsMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3429             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3430             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3431         \textcolor{keyword}{private}:}
\DoxyCodeLine{3432             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3433             \textcolor{keywordtype}{double} m\_margin;}
\DoxyCodeLine{3434         \};}
\DoxyCodeLine{3435 }
\DoxyCodeLine{3436         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{WithinUlpsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3437             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{WithinUlpsMatcher}}(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType);}
\DoxyCodeLine{3438             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3439             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3440         \textcolor{keyword}{private}:}
\DoxyCodeLine{3441             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3442             uint64\_t m\_ulps;}
\DoxyCodeLine{3443             FloatingPointKind m\_type;}
\DoxyCodeLine{3444         \};}
\DoxyCodeLine{3445 }
\DoxyCodeLine{3446         \textcolor{comment}{// Given IEEE-\/754 format for floats and doubles, we can assume}}
\DoxyCodeLine{3447         \textcolor{comment}{// that float -\/> double promotion is lossless. Given this, we can}}
\DoxyCodeLine{3448         \textcolor{comment}{// assume that if we do the standard relative comparison of}}
\DoxyCodeLine{3449         \textcolor{comment}{// |lhs -\/ rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get}}
\DoxyCodeLine{3450         \textcolor{comment}{// the same result if we do this for floats, as if we do this for}}
\DoxyCodeLine{3451         \textcolor{comment}{// doubles that were promoted from floats.}}
\DoxyCodeLine{3452         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{WithinRelMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<double> \{}
\DoxyCodeLine{3453             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{WithinRelMatcher}}(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon);}
\DoxyCodeLine{3454             \textcolor{keywordtype}{bool} match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee) \textcolor{keyword}{const override};}
\DoxyCodeLine{3455             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3456         \textcolor{keyword}{private}:}
\DoxyCodeLine{3457             \textcolor{keywordtype}{double} m\_target;}
\DoxyCodeLine{3458             \textcolor{keywordtype}{double} m\_epsilon;}
\DoxyCodeLine{3459         \};}
\DoxyCodeLine{3460 }
\DoxyCodeLine{3461     \} \textcolor{comment}{// namespace Floating}}
\DoxyCodeLine{3462 }
\DoxyCodeLine{3463     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3464     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3465     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{double} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3466     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_ulps_matcher}{Floating::WithinUlpsMatcher}} WithinULP(\textcolor{keywordtype}{float} target, uint64\_t maxUlpDiff);}
\DoxyCodeLine{3467     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_abs_matcher}{Floating::WithinAbsMatcher}} WithinAbs(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin);}
\DoxyCodeLine{3468     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} eps);}
\DoxyCodeLine{3469     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<double>::epsilon()}}
\DoxyCodeLine{3470     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{double} target);}
\DoxyCodeLine{3471     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target, \textcolor{keywordtype}{float} eps);}
\DoxyCodeLine{3472     \textcolor{comment}{// defaults epsilon to 100*numeric\_limits<float>::epsilon()}}
\DoxyCodeLine{3473     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_floating_1_1_within_rel_matcher}{Floating::WithinRelMatcher}} WithinRel(\textcolor{keywordtype}{float} target);}
\DoxyCodeLine{3474 }
\DoxyCodeLine{3475 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3476 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3477 }
\DoxyCodeLine{3478 \textcolor{comment}{// end catch\_matchers\_floating.h}}
\DoxyCodeLine{3479 \textcolor{comment}{// start catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3480 }
\DoxyCodeLine{3481 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{3482 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3483 }
\DoxyCodeLine{3484 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3485 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3486 \textcolor{keyword}{namespace }Generic \{}
\DoxyCodeLine{3487 }
\DoxyCodeLine{3488 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{3489     std::string finalizeDescription(\textcolor{keyword}{const} std::string\& desc);}
\DoxyCodeLine{3490 \}}
\DoxyCodeLine{3491 }
\DoxyCodeLine{3492 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3493 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{PredicateMatcher}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<T> \{}
\DoxyCodeLine{3494     std::function<bool(T \textcolor{keyword}{const}\&)> m\_predicate;}
\DoxyCodeLine{3495     std::string m\_description;}
\DoxyCodeLine{3496 \textcolor{keyword}{public}:}
\DoxyCodeLine{3497 }
\DoxyCodeLine{3498     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{PredicateMatcher}}(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& elem, std::string \textcolor{keyword}{const}\& descr)}
\DoxyCodeLine{3499         :m\_predicate(std::move(elem)),}
\DoxyCodeLine{3500         m\_description(Detail::finalizeDescription(descr))}
\DoxyCodeLine{3501     \{\}}
\DoxyCodeLine{3502 }
\DoxyCodeLine{3503     \textcolor{keywordtype}{bool} match( T \textcolor{keyword}{const}\& item )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3504         \textcolor{keywordflow}{return} m\_predicate(item);}
\DoxyCodeLine{3505     \}}
\DoxyCodeLine{3506 }
\DoxyCodeLine{3507     std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3508         \textcolor{keywordflow}{return} m\_description;}
\DoxyCodeLine{3509     \}}
\DoxyCodeLine{3510 \};}
\DoxyCodeLine{3511 }
\DoxyCodeLine{3512 \} \textcolor{comment}{// namespace Generic}}
\DoxyCodeLine{3513 }
\DoxyCodeLine{3514     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3515     \textcolor{comment}{// The user has to explicitly specify type to the function, because}}
\DoxyCodeLine{3516     \textcolor{comment}{// inferring std::function<bool(T const\&)> is hard (but possible) and}}
\DoxyCodeLine{3517     \textcolor{comment}{// requires a lot of TMP.}}
\DoxyCodeLine{3518     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3519     \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{Generic::PredicateMatcher<T>}} Predicate(std::function<\textcolor{keywordtype}{bool}(T \textcolor{keyword}{const}\&)> \textcolor{keyword}{const}\& predicate, std::string \textcolor{keyword}{const}\& description = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{3520         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_matchers_1_1_generic_1_1_predicate_matcher}{Generic::PredicateMatcher<T>}}(predicate, description);}
\DoxyCodeLine{3521     \}}
\DoxyCodeLine{3522 }
\DoxyCodeLine{3523 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3524 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3525 }
\DoxyCodeLine{3526 \textcolor{comment}{// end catch\_matchers\_generic.hpp}}
\DoxyCodeLine{3527 \textcolor{comment}{// start catch\_matchers\_string.h}}
\DoxyCodeLine{3528 }
\DoxyCodeLine{3529 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{3530 }
\DoxyCodeLine{3531 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3532 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3533 }
\DoxyCodeLine{3534     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{3535 }
\DoxyCodeLine{3536         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}}}
\DoxyCodeLine{3537         \{}
\DoxyCodeLine{3538             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}}( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3539             std::string adjustString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{3540             std::string caseSensitivitySuffix() \textcolor{keyword}{const};}
\DoxyCodeLine{3541 }
\DoxyCodeLine{3542             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3543             std::string m\_str;}
\DoxyCodeLine{3544         \};}
\DoxyCodeLine{3545 }
\DoxyCodeLine{3546         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3547             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}}( std::string \textcolor{keyword}{const}\& operation, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3548             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3549 }
\DoxyCodeLine{3550             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} m\_comparator;}
\DoxyCodeLine{3551             std::string m\_operation;}
\DoxyCodeLine{3552         \};}
\DoxyCodeLine{3553 }
\DoxyCodeLine{3554         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{EqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3555             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{EqualsMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3556             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3557         \};}
\DoxyCodeLine{3558         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{ContainsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3559             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{ContainsMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3560             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3561         \};}
\DoxyCodeLine{3562         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StartsWithMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3563             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StartsWithMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3564             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3565         \};}
\DoxyCodeLine{3566         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{EndsWithMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_string_matcher_base}{StringMatcherBase}} \{}
\DoxyCodeLine{3567             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{EndsWithMatcher}}( \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_cased_string}{CasedString}} \textcolor{keyword}{const}\& comparator );}
\DoxyCodeLine{3568             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& source ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3569         \};}
\DoxyCodeLine{3570 }
\DoxyCodeLine{3571         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{RegexMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::string> \{}
\DoxyCodeLine{3572             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{RegexMatcher}}( std::string regex, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{3573             \textcolor{keywordtype}{bool} match( std::string \textcolor{keyword}{const}\& matchee ) \textcolor{keyword}{const override};}
\DoxyCodeLine{3574             std::string describe() \textcolor{keyword}{const override};}
\DoxyCodeLine{3575 }
\DoxyCodeLine{3576         \textcolor{keyword}{private}:}
\DoxyCodeLine{3577             std::string m\_regex;}
\DoxyCodeLine{3578             CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{3579         \};}
\DoxyCodeLine{3580 }
\DoxyCodeLine{3581     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{3582 }
\DoxyCodeLine{3583     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3584     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3585 }
\DoxyCodeLine{3586     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_equals_matcher}{StdString::EqualsMatcher}} Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3587     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{StdString::ContainsMatcher}} Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3588     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_ends_with_matcher}{StdString::EndsWithMatcher}} EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3589     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_starts_with_matcher}{StdString::StartsWithMatcher}} StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3590     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_std_string_1_1_regex_matcher}{StdString::RegexMatcher}} Matches( std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );}
\DoxyCodeLine{3591 }
\DoxyCodeLine{3592 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3593 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3594 }
\DoxyCodeLine{3595 \textcolor{comment}{// end catch\_matchers\_string.h}}
\DoxyCodeLine{3596 \textcolor{comment}{// start catch\_matchers\_vector.h}}
\DoxyCodeLine{3597 }
\DoxyCodeLine{3598 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3601 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{3602 }
\DoxyCodeLine{3603     \textcolor{keyword}{namespace }Vector \{}
\DoxyCodeLine{3604         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{3605         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{ContainsElementMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, Alloc>> \{}
\DoxyCodeLine{3606 }
\DoxyCodeLine{3607             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{ContainsElementMatcher}}(T \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator) \{\}}
\DoxyCodeLine{3608 }
\DoxyCodeLine{3609             \textcolor{keywordtype}{bool} match(std::vector<T, Alloc> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3610                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& el : v) \{}
\DoxyCodeLine{3611                     \textcolor{keywordflow}{if} (el == m\_comparator) \{}
\DoxyCodeLine{3612                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3613                     \}}
\DoxyCodeLine{3614                 \}}
\DoxyCodeLine{3615                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3616             \}}
\DoxyCodeLine{3617 }
\DoxyCodeLine{3618             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3619                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3620             \}}
\DoxyCodeLine{3621 }
\DoxyCodeLine{3622             T \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3623         \};}
\DoxyCodeLine{3624 }
\DoxyCodeLine{3625         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3626         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{ContainsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3627 }
\DoxyCodeLine{3628             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{ContainsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3629 }
\DoxyCodeLine{3630             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3631                 \textcolor{comment}{// !TBD: see note in EqualsMatcher}}
\DoxyCodeLine{3632                 \textcolor{keywordflow}{if} (m\_comparator.size() > v.size())}
\DoxyCodeLine{3633                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3634                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& comparator : m\_comparator) \{}
\DoxyCodeLine{3635                     \textcolor{keyword}{auto} present = \textcolor{keyword}{false};}
\DoxyCodeLine{3636                     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& el : v) \{}
\DoxyCodeLine{3637                         \textcolor{keywordflow}{if} (el == comparator) \{}
\DoxyCodeLine{3638                             present = \textcolor{keyword}{true};}
\DoxyCodeLine{3639                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{3640                         \}}
\DoxyCodeLine{3641                     \}}
\DoxyCodeLine{3642                     \textcolor{keywordflow}{if} (!present) \{}
\DoxyCodeLine{3643                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3644                     \}}
\DoxyCodeLine{3645                 \}}
\DoxyCodeLine{3646                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3647             \}}
\DoxyCodeLine{3648             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3649                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Contains: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3650             \}}
\DoxyCodeLine{3651 }
\DoxyCodeLine{3652             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3653         \};}
\DoxyCodeLine{3654 }
\DoxyCodeLine{3655         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3656         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_equals_matcher}{EqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3657 }
\DoxyCodeLine{3658             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_equals_matcher}{EqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const} \&comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3659 }
\DoxyCodeLine{3660             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3661                 \textcolor{comment}{// !TBD: This currently works if all elements can be compared using !=}}
\DoxyCodeLine{3662                 \textcolor{comment}{// -\/ a more general approach would be via a compare template that defaults}}
\DoxyCodeLine{3663                 \textcolor{comment}{// to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc}}
\DoxyCodeLine{3664                 \textcolor{comment}{// -\/ then just call that directly}}
\DoxyCodeLine{3665                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3666                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3667                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3668                     \textcolor{keywordflow}{if} (m\_comparator[i] != v[i])}
\DoxyCodeLine{3669                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3670                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3671             \}}
\DoxyCodeLine{3672             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3673                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Equals: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3674             \}}
\DoxyCodeLine{3675             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3676         \};}
\DoxyCodeLine{3677 }
\DoxyCodeLine{3678         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3679         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3680 }
\DoxyCodeLine{3681             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator) : m\_comparator( comparator ) \{\}}
\DoxyCodeLine{3682 }
\DoxyCodeLine{3683             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const} \&v)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3684                 \textcolor{keywordflow}{if} (m\_comparator.size() != v.size())}
\DoxyCodeLine{3685                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3686                 \textcolor{keywordflow}{for} (std::size\_t i = 0; i < v.size(); ++i)}
\DoxyCodeLine{3687                     \textcolor{keywordflow}{if} (m\_comparator[i] != approx(v[i]))}
\DoxyCodeLine{3688                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3689                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{3690             \}}
\DoxyCodeLine{3691             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3692                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is approx: "{}} + ::Catch::Detail::stringify( m\_comparator );}
\DoxyCodeLine{3693             \}}
\DoxyCodeLine{3694             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3695             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& epsilon( T \textcolor{keyword}{const}\& newEpsilon ) \{}
\DoxyCodeLine{3696                 approx.epsilon(newEpsilon);}
\DoxyCodeLine{3697                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3698             \}}
\DoxyCodeLine{3699             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3700             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& margin( T \textcolor{keyword}{const}\& newMargin ) \{}
\DoxyCodeLine{3701                 approx.margin(newMargin);}
\DoxyCodeLine{3702                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3703             \}}
\DoxyCodeLine{3704             template <typename = typename std::enable\_if<std::is\_constructible<double, T>::value>::type>}
\DoxyCodeLine{3705             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_approx_matcher}{ApproxMatcher}}\& scale( T \textcolor{keyword}{const}\& newScale ) \{}
\DoxyCodeLine{3706                 approx.scale(newScale);}
\DoxyCodeLine{3707                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{3708             \}}
\DoxyCodeLine{3709 }
\DoxyCodeLine{3710             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_comparator;}
\DoxyCodeLine{3711             \textcolor{keyword}{mutable} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} approx = Catch::Detail::Approx::custom();}
\DoxyCodeLine{3712         \};}
\DoxyCodeLine{3713 }
\DoxyCodeLine{3714         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp, \textcolor{keyword}{typename} AllocMatch>}
\DoxyCodeLine{3715         \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_unordered_equals_matcher}{UnorderedEqualsMatcher}} : \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{MatcherBase}}<std::vector<T, AllocMatch>> \{}
\DoxyCodeLine{3716             \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_unordered_equals_matcher}{UnorderedEqualsMatcher}}(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) : m\_target(target) \{\}}
\DoxyCodeLine{3717             \textcolor{keywordtype}{bool} match(std::vector<T, AllocMatch> \textcolor{keyword}{const}\& vec)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3718                 \textcolor{keywordflow}{if} (m\_target.size() != vec.size()) \{}
\DoxyCodeLine{3719                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3720                 \}}
\DoxyCodeLine{3721                 \textcolor{keywordflow}{return} std::is\_permutation(m\_target.begin(), m\_target.end(), vec.begin());}
\DoxyCodeLine{3722             \}}
\DoxyCodeLine{3723 }
\DoxyCodeLine{3724             std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3725                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}UnorderedEquals: "{}} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{3726             \}}
\DoxyCodeLine{3727         \textcolor{keyword}{private}:}
\DoxyCodeLine{3728             std::vector<T, AllocComp> \textcolor{keyword}{const}\& m\_target;}
\DoxyCodeLine{3729         \};}
\DoxyCodeLine{3730 }
\DoxyCodeLine{3731     \} \textcolor{comment}{// namespace Vector}}
\DoxyCodeLine{3732 }
\DoxyCodeLine{3733     \textcolor{comment}{// The following functions create the actual matcher objects.}}
\DoxyCodeLine{3734     \textcolor{comment}{// This allows the types to be inferred}}
\DoxyCodeLine{3735 }
\DoxyCodeLine{3736     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3737     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}} Contains( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3738         \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_matcher}{Vector::ContainsMatcher<T, AllocComp, AllocMatch>}}( comparator );}
\DoxyCodeLine{3739     \}}
\DoxyCodeLine{3740 }
\DoxyCodeLine{3741     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Alloc = std::allocator<T>>}
\DoxyCodeLine{3742     \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{Vector::ContainsElementMatcher<T, Alloc>}} VectorContains( T \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3743         \textcolor{keywordflow}{return} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_vector_1_1_contains_element_matcher}{Vector::ContainsElementMatcher<T, Alloc>}}( comparator );}
\DoxyCodeLine{3744     \}}
\DoxyCodeLine{3745 }
\DoxyCodeLine{3746     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3747     Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3748         \textcolor{keywordflow}{return} Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3749     \}}
\DoxyCodeLine{3750 }
\DoxyCodeLine{3751     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3752     Vector::ApproxMatcher<T, AllocComp, AllocMatch> \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( std::vector<T, AllocComp> \textcolor{keyword}{const}\& comparator ) \{}
\DoxyCodeLine{3753         \textcolor{keywordflow}{return} Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );}
\DoxyCodeLine{3754     \}}
\DoxyCodeLine{3755 }
\DoxyCodeLine{3756     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} AllocComp = std::allocator<T>, \textcolor{keyword}{typename} AllocMatch = AllocComp>}
\DoxyCodeLine{3757     Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> \textcolor{keyword}{const}\& target) \{}
\DoxyCodeLine{3758         \textcolor{keywordflow}{return} Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );}
\DoxyCodeLine{3759     \}}
\DoxyCodeLine{3760 }
\DoxyCodeLine{3761 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{3762 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3763 }
\DoxyCodeLine{3764 \textcolor{comment}{// end catch\_matchers\_vector.h}}
\DoxyCodeLine{3765 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3766 }
\DoxyCodeLine{3767     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3768     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}} \{}
\DoxyCodeLine{3769         ArgT \textcolor{keyword}{const}\& m\_arg;}
\DoxyCodeLine{3770         MatcherT m\_matcher;}
\DoxyCodeLine{3771         \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} m\_matcherString;}
\DoxyCodeLine{3772     \textcolor{keyword}{public}:}
\DoxyCodeLine{3773         \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr}}( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString )}
\DoxyCodeLine{3774         :   \mbox{\hyperlink{struct_catch_1_1_i_transient_expression}{ITransientExpression}}\{ \textcolor{keyword}{true}, matcher.match( arg ) \},}
\DoxyCodeLine{3775             m\_arg( arg ),}
\DoxyCodeLine{3776             m\_matcher( matcher ),}
\DoxyCodeLine{3777             m\_matcherString( matcherString )}
\DoxyCodeLine{3778         \{\}}
\DoxyCodeLine{3779 }
\DoxyCodeLine{3780         \textcolor{keywordtype}{void} streamReconstructedExpression( std::ostream \&os )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3781             \textcolor{keyword}{auto} matcherAsString = m\_matcher.toString();}
\DoxyCodeLine{3782             os << Catch::Detail::stringify( m\_arg ) << \textcolor{charliteral}{' '};}
\DoxyCodeLine{3783             \textcolor{keywordflow}{if}( matcherAsString == Detail::unprintableString )}
\DoxyCodeLine{3784                 os << m\_matcherString;}
\DoxyCodeLine{3785             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3786                 os << matcherAsString;}
\DoxyCodeLine{3787         \}}
\DoxyCodeLine{3788     \};}
\DoxyCodeLine{3789 }
\DoxyCodeLine{3790     \textcolor{keyword}{using} \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{StringMatcher}} = \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{Matchers::Impl::MatcherBase<std::string>}};}
\DoxyCodeLine{3791 }
\DoxyCodeLine{3792     \textcolor{keywordtype}{void} handleExceptionMatchExpr( \mbox{\hyperlink{class_catch_1_1_assertion_handler}{AssertionHandler}}\& handler, \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{StringMatcher}} \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString  );}
\DoxyCodeLine{3793 }
\DoxyCodeLine{3794     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgT, \textcolor{keyword}{typename} MatcherT>}
\DoxyCodeLine{3795     \textcolor{keyword}{auto} makeMatchExpr( ArgT \textcolor{keyword}{const}\& arg, MatcherT \textcolor{keyword}{const}\& matcher, \mbox{\hyperlink{class_catch_1_1_string_ref}{StringRef}} \textcolor{keyword}{const}\& matcherString  ) -\/> \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr<ArgT, MatcherT>}} \{}
\DoxyCodeLine{3796         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_match_expr}{MatchExpr<ArgT, MatcherT>}}( arg, matcher, matcherString );}
\DoxyCodeLine{3797     \}}
\DoxyCodeLine{3798 }
\DoxyCodeLine{3799 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3800 }
\DoxyCodeLine{3802 \textcolor{preprocessor}{\#define INTERNAL\_CHECK\_THAT( macroName, matcher, resultDisposition, arg ) \(\backslash\)}}
\DoxyCodeLine{3803 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3804 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(arg) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3805         INTERNAL\_CATCH\_TRY \{ \(\backslash\)}
\DoxyCodeLine{3806             catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3807         \} INTERNAL\_CATCH\_CATCH( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3808         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3809     \} while( false )}
\DoxyCodeLine{3810 }
\DoxyCodeLine{3812 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_THROWS\_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \(\backslash\)}}
\DoxyCodeLine{3813 \textcolor{preprocessor}{    do \{ \(\backslash\)}}
\DoxyCodeLine{3814 \textcolor{preprocessor}{        Catch::AssertionHandler catchAssertionHandler( macroName\#\#\_catch\_sr, CATCH\_INTERNAL\_LINEINFO, CATCH\_INTERNAL\_STRINGIFY(\_\_VA\_ARGS\_\_) "{}, "{}} CATCH\_INTERNAL\_STRINGIFY(exceptionType) "{}, "{} CATCH\_INTERNAL\_STRINGIFY(matcher), resultDisposition ); \(\backslash\)}
\DoxyCodeLine{3815         if( catchAssertionHandler.allowThrows() ) \(\backslash\)}
\DoxyCodeLine{3816             try \{ \(\backslash\)}
\DoxyCodeLine{3817                 static\_cast<void>(\_\_VA\_ARGS\_\_ ); \(\backslash\)}
\DoxyCodeLine{3818                 catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \(\backslash\)}
\DoxyCodeLine{3819             \} \(\backslash\)}
\DoxyCodeLine{3820             catch( exceptionType const\& ex ) \{ \(\backslash\)}
\DoxyCodeLine{3821                 catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, \#matcher\#\#\_catch\_sr ) ); \(\backslash\)}
\DoxyCodeLine{3822             \} \(\backslash\)}
\DoxyCodeLine{3823             catch( ... ) \{ \(\backslash\)}
\DoxyCodeLine{3824                 catchAssertionHandler.handleUnexpectedInflightException(); \(\backslash\)}
\DoxyCodeLine{3825             \} \(\backslash\)}
\DoxyCodeLine{3826         else \(\backslash\)}
\DoxyCodeLine{3827             catchAssertionHandler.handleThrowingCallSkipped(); \(\backslash\)}
\DoxyCodeLine{3828         INTERNAL\_CATCH\_REACT( catchAssertionHandler ) \(\backslash\)}
\DoxyCodeLine{3829     \} while( false )}
\DoxyCodeLine{3830 }
\DoxyCodeLine{3831 \textcolor{comment}{// end catch\_capture\_matchers.h}}
\DoxyCodeLine{3832 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3833 \textcolor{comment}{// start catch\_generators.hpp}}
\DoxyCodeLine{3834 }
\DoxyCodeLine{3835 \textcolor{comment}{// start catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3836 }
\DoxyCodeLine{3837 }
\DoxyCodeLine{3838 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3839 }
\DoxyCodeLine{3840 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3841 }
\DoxyCodeLine{3842     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3843         \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3844         \textcolor{keyword}{public}:}
\DoxyCodeLine{3845             \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3846             \textcolor{keyword}{virtual} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{\string~GeneratorUntypedBase}}();}
\DoxyCodeLine{3847             \textcolor{comment}{// Attempts to move the generator to the next element}}
\DoxyCodeLine{3848              \textcolor{comment}{//}}
\DoxyCodeLine{3849              \textcolor{comment}{// Returns true iff the move succeeded (and a valid element}}
\DoxyCodeLine{3850              \textcolor{comment}{// can be retrieved).}}
\DoxyCodeLine{3851             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} next() = 0;}
\DoxyCodeLine{3852         \};}
\DoxyCodeLine{3853         \textcolor{keyword}{using} GeneratorBasePtr = std::unique\_ptr<GeneratorUntypedBase>;}
\DoxyCodeLine{3854 }
\DoxyCodeLine{3855     \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{3856 }
\DoxyCodeLine{3857     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{IGeneratorTracker}} \{}
\DoxyCodeLine{3858         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_generator_tracker}{\string~IGeneratorTracker}}();}
\DoxyCodeLine{3859         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} hasGenerator() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} = 0;}
\DoxyCodeLine{3860         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} getGenerator() \textcolor{keyword}{const} -\/> Generators::GeneratorBasePtr \textcolor{keyword}{const}\& = 0;}
\DoxyCodeLine{3861         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setGenerator( Generators::GeneratorBasePtr\&\& generator ) = 0;}
\DoxyCodeLine{3862     \};}
\DoxyCodeLine{3863 }
\DoxyCodeLine{3864 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{3865 }
\DoxyCodeLine{3866 \textcolor{comment}{// end catch\_interfaces\_generatortracker.h}}
\DoxyCodeLine{3867 \textcolor{comment}{// start catch\_enforce.h}}
\DoxyCodeLine{3868 }
\DoxyCodeLine{3869 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3870 }
\DoxyCodeLine{3871 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3872 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{3873     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Ex>}
\DoxyCodeLine{3874     [[noreturn]]}
\DoxyCodeLine{3875     \textcolor{keywordtype}{void} throw\_exception(Ex \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{3876         \textcolor{keywordflow}{throw} e;}
\DoxyCodeLine{3877     \}}
\DoxyCodeLine{3878 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled //  Exceptions are disabled vv}}
\DoxyCodeLine{3879     [[noreturn]]}
\DoxyCodeLine{3880     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e);}
\DoxyCodeLine{3881 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{3882 }
\DoxyCodeLine{3883     [[noreturn]]}
\DoxyCodeLine{3884     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3885     [[noreturn]]}
\DoxyCodeLine{3886     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3887     [[noreturn]]}
\DoxyCodeLine{3888     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg);}
\DoxyCodeLine{3889 }
\DoxyCodeLine{3890 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{3891 }
\DoxyCodeLine{3892 \textcolor{preprocessor}{\#define CATCH\_MAKE\_MSG(...) \(\backslash\)}}
\DoxyCodeLine{3893 \textcolor{preprocessor}{    (Catch::ReusableStringStream() << \_\_VA\_ARGS\_\_).str()}}
\DoxyCodeLine{3894 }
\DoxyCodeLine{3895 \textcolor{preprocessor}{\#define CATCH\_INTERNAL\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3896 \textcolor{preprocessor}{    Catch::throw\_logic\_error(CATCH\_MAKE\_MSG( CATCH\_INTERNAL\_LINEINFO << "{}: Internal Catch2 error: "{}} << \_\_VA\_ARGS\_\_))}
\DoxyCodeLine{3897 }
\DoxyCodeLine{3898 \textcolor{preprocessor}{\#define CATCH\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3899 \textcolor{preprocessor}{    Catch::throw\_domain\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3900 }
\DoxyCodeLine{3901 \textcolor{preprocessor}{\#define CATCH\_RUNTIME\_ERROR(...) \(\backslash\)}}
\DoxyCodeLine{3902 \textcolor{preprocessor}{    Catch::throw\_runtime\_error(CATCH\_MAKE\_MSG( \_\_VA\_ARGS\_\_ ))}}
\DoxyCodeLine{3903 }
\DoxyCodeLine{3904 \textcolor{preprocessor}{\#define CATCH\_ENFORCE( condition, ... ) \(\backslash\)}}
\DoxyCodeLine{3905 \textcolor{preprocessor}{    do\{ if( !(condition) ) CATCH\_ERROR( \_\_VA\_ARGS\_\_ ); \} while(false)}}
\DoxyCodeLine{3906 }
\DoxyCodeLine{3907 \textcolor{comment}{// end catch\_enforce.h}}
\DoxyCodeLine{3908 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{3909 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{3910 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{3911 }
\DoxyCodeLine{3912 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{3913 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{3914 }
\DoxyCodeLine{3915 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{3916 }
\DoxyCodeLine{3917 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}} : \textcolor{keyword}{public} std::exception \{}
\DoxyCodeLine{3918     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} m\_msg = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{3919 }
\DoxyCodeLine{3920 \textcolor{keyword}{public}:}
\DoxyCodeLine{3921     \mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg):}
\DoxyCodeLine{3922         m\_msg(msg)}
\DoxyCodeLine{3923     \{\}}
\DoxyCodeLine{3924 }
\DoxyCodeLine{3925     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \textcolor{keyword}{override} \textcolor{keyword}{final};}
\DoxyCodeLine{3926 \};}
\DoxyCodeLine{3927 }
\DoxyCodeLine{3928 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{3929 }
\DoxyCodeLine{3930     \textcolor{comment}{// !TBD move this into its own location?}}
\DoxyCodeLine{3931     \textcolor{keyword}{namespace }pf\{}
\DoxyCodeLine{3932         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{3933         std::unique\_ptr<T> make\_unique( Args\&\&... args ) \{}
\DoxyCodeLine{3934             \textcolor{keywordflow}{return} std::unique\_ptr<T>(\textcolor{keyword}{new} T(std::forward<Args>(args)...));}
\DoxyCodeLine{3935         \}}
\DoxyCodeLine{3936     \}}
\DoxyCodeLine{3937 }
\DoxyCodeLine{3938     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3939     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}} : \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_untyped_base}{GeneratorUntypedBase}} \{}
\DoxyCodeLine{3940         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{\string~IGenerator}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{3941 }
\DoxyCodeLine{3942         \textcolor{comment}{// Returns the current element of the generator}}
\DoxyCodeLine{3943         \textcolor{comment}{//}}
\DoxyCodeLine{3944         \textcolor{comment}{// \(\backslash\)Precondition The generator is either freshly constructed,}}
\DoxyCodeLine{3945         \textcolor{comment}{// or the last call to `next()` returned true}}
\DoxyCodeLine{3946         \textcolor{keyword}{virtual} T \textcolor{keyword}{const}\& get() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{3947         \textcolor{keyword}{using} type = T;}
\DoxyCodeLine{3948     \};}
\DoxyCodeLine{3949 }
\DoxyCodeLine{3950     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3951     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{3952         T m\_value;}
\DoxyCodeLine{3953     \textcolor{keyword}{public}:}
\DoxyCodeLine{3954         \mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator}}(T\&\& value) : m\_value(std::move(value)) \{\}}
\DoxyCodeLine{3955 }
\DoxyCodeLine{3956         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3957             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{3958         \}}
\DoxyCodeLine{3959         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3960             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{3961         \}}
\DoxyCodeLine{3962     \};}
\DoxyCodeLine{3963 }
\DoxyCodeLine{3964     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3965     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_fixed_values_generator}{FixedValuesGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{3966         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{3967             \textcolor{stringliteral}{"{}FixedValuesGenerator does not support bools because of std::vector<bool>"{}}}
\DoxyCodeLine{3968             \textcolor{stringliteral}{"{}specialization, use SingleValue Generator instead."{}});}
\DoxyCodeLine{3969         std::vector<T> m\_values;}
\DoxyCodeLine{3970         \textcolor{keywordtype}{size\_t} m\_idx = 0;}
\DoxyCodeLine{3971     \textcolor{keyword}{public}:}
\DoxyCodeLine{3972         \mbox{\hyperlink{class_catch_1_1_generators_1_1_fixed_values_generator}{FixedValuesGenerator}}( std::initializer\_list<T> values ) : m\_values( values ) \{\}}
\DoxyCodeLine{3973 }
\DoxyCodeLine{3974         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{3975             \textcolor{keywordflow}{return} m\_values[m\_idx];}
\DoxyCodeLine{3976         \}}
\DoxyCodeLine{3977         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{3978             ++m\_idx;}
\DoxyCodeLine{3979             \textcolor{keywordflow}{return} m\_idx < m\_values.size();}
\DoxyCodeLine{3980         \}}
\DoxyCodeLine{3981     \};}
\DoxyCodeLine{3982 }
\DoxyCodeLine{3983     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3984     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}} final \{}
\DoxyCodeLine{3985         std::unique\_ptr<IGenerator<T>> m\_generator;}
\DoxyCodeLine{3986     \textcolor{keyword}{public}:}
\DoxyCodeLine{3987         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}}(std::unique\_ptr<\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator<T>}}> generator):}
\DoxyCodeLine{3988             m\_generator(std::move(generator))}
\DoxyCodeLine{3989         \{\}}
\DoxyCodeLine{3990         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3991             \textcolor{keywordflow}{return} m\_generator-\/>get();}
\DoxyCodeLine{3992         \}}
\DoxyCodeLine{3993         \textcolor{keywordtype}{bool} next() \{}
\DoxyCodeLine{3994             \textcolor{keywordflow}{return} m\_generator-\/>next();}
\DoxyCodeLine{3995         \}}
\DoxyCodeLine{3996     \};}
\DoxyCodeLine{3997 }
\DoxyCodeLine{3998     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3999     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} value(T\&\& value) \{}
\DoxyCodeLine{4000         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_single_value_generator}{SingleValueGenerator<T>}}>(std::forward<T>(value)));}
\DoxyCodeLine{4001     \}}
\DoxyCodeLine{4002     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4003     GeneratorWrapper<T> values(std::initializer\_list<T> values) \{}
\DoxyCodeLine{4004         \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<FixedValuesGenerator<T>>(values));}
\DoxyCodeLine{4005     \}}
\DoxyCodeLine{4006 }
\DoxyCodeLine{4007     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4008     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4009         std::vector<GeneratorWrapper<T>> m\_generators;}
\DoxyCodeLine{4010         \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4011 }
\DoxyCodeLine{4012         \textcolor{keywordtype}{void} populate(\mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4013             m\_generators.emplace\_back(std::move(generator));}
\DoxyCodeLine{4014         \}}
\DoxyCodeLine{4015         \textcolor{keywordtype}{void} populate(T\&\& val) \{}
\DoxyCodeLine{4016             m\_generators.emplace\_back(value(std::forward<T>(val)));}
\DoxyCodeLine{4017         \}}
\DoxyCodeLine{4018         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{4019         \textcolor{keywordtype}{void} populate(U\&\& val) \{}
\DoxyCodeLine{4020             populate(T(std::forward<U>(val)));}
\DoxyCodeLine{4021         \}}
\DoxyCodeLine{4022         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4023         \textcolor{keywordtype}{void} populate(U\&\& valueOrGenerator, Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4024             populate(std::forward<U>(valueOrGenerator));}
\DoxyCodeLine{4025             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4026         \}}
\DoxyCodeLine{4027 }
\DoxyCodeLine{4028     \textcolor{keyword}{public}:}
\DoxyCodeLine{4029         \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4030         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators}}(Gs \&\&... moreGenerators) \{}
\DoxyCodeLine{4031             m\_generators.reserve(\textcolor{keyword}{sizeof}...(Gs));}
\DoxyCodeLine{4032             populate(std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4033         \}}
\DoxyCodeLine{4034 }
\DoxyCodeLine{4035         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4036             \textcolor{keywordflow}{return} m\_generators[m\_current].get();}
\DoxyCodeLine{4037         \}}
\DoxyCodeLine{4038 }
\DoxyCodeLine{4039         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4040             \textcolor{keywordflow}{if} (m\_current >= m\_generators.size()) \{}
\DoxyCodeLine{4041                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4042             \}}
\DoxyCodeLine{4043             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} current\_status = m\_generators[m\_current].next();}
\DoxyCodeLine{4044             \textcolor{keywordflow}{if} (!current\_status) \{}
\DoxyCodeLine{4045                 ++m\_current;}
\DoxyCodeLine{4046             \}}
\DoxyCodeLine{4047             \textcolor{keywordflow}{return} m\_current < m\_generators.size();}
\DoxyCodeLine{4048         \}}
\DoxyCodeLine{4049     \};}
\DoxyCodeLine{4050 }
\DoxyCodeLine{4051     \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Ts>}
\DoxyCodeLine{4052     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper}}<std::tuple<Ts...>> table( std::initializer\_list<std::tuple<\textcolor{keyword}{typename} std::decay<Ts>::type...>> tuples ) \{}
\DoxyCodeLine{4053         \textcolor{keywordflow}{return} values<std::tuple<Ts...>>( tuples );}
\DoxyCodeLine{4054     \}}
\DoxyCodeLine{4055 }
\DoxyCodeLine{4056     \textcolor{comment}{// Tag type to signal that a generator sequence should convert arguments to a specific type}}
\DoxyCodeLine{4057     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4058     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_generators_1_1as}{as}} \{\};}
\DoxyCodeLine{4059 }
\DoxyCodeLine{4060     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4061     \textcolor{keyword}{auto} makeGenerators( \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator, Gs \&\&... moreGenerators ) -\/> \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators<T>}} \{}
\DoxyCodeLine{4062         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generators}{Generators<T>}}(std::move(generator), std::forward<Gs>(moreGenerators)...);}
\DoxyCodeLine{4063     \}}
\DoxyCodeLine{4064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4065     \textcolor{keyword}{auto} makeGenerators( GeneratorWrapper<T>\&\& generator ) -\/> Generators<T> \{}
\DoxyCodeLine{4066         \textcolor{keywordflow}{return} Generators<T>(std::move(generator));}
\DoxyCodeLine{4067     \}}
\DoxyCodeLine{4068     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4069     \textcolor{keyword}{auto} makeGenerators( T\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4070         \textcolor{keywordflow}{return} makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4071     \}}
\DoxyCodeLine{4072     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename}... Gs>}
\DoxyCodeLine{4073     \textcolor{keyword}{auto} makeGenerators( as<T>, U\&\& val, Gs \&\&... moreGenerators ) -\/> Generators<T> \{}
\DoxyCodeLine{4074         \textcolor{keywordflow}{return} makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );}
\DoxyCodeLine{4075     \}}
\DoxyCodeLine{4076 }
\DoxyCodeLine{4077     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\&;}
\DoxyCodeLine{4078 }
\DoxyCodeLine{4079     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{4080     \textcolor{comment}{// Note: The type after -\/> is weird, because VS2015 cannot parse}}
\DoxyCodeLine{4081     \textcolor{comment}{//       the expression used in the typedef inside, when it is in}}
\DoxyCodeLine{4082     \textcolor{comment}{//       return type. Yeah.}}
\DoxyCodeLine{4083     \textcolor{keyword}{auto} generate( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, L \textcolor{keyword}{const}\& generatorExpression ) -\/> \textcolor{keyword}{decltype}(std::declval<decltype(generatorExpression())>().get()) \{}
\DoxyCodeLine{4084         \textcolor{keyword}{using} UnderlyingType = \textcolor{keyword}{typename} \textcolor{keyword}{decltype}(generatorExpression())::type;}
\DoxyCodeLine{4085 }
\DoxyCodeLine{4086         IGeneratorTracker\& tracker = acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{4087         \textcolor{keywordflow}{if} (!tracker.hasGenerator()) \{}
\DoxyCodeLine{4088             tracker.setGenerator(pf::make\_unique<Generators<UnderlyingType>>(generatorExpression()));}
\DoxyCodeLine{4089         \}}
\DoxyCodeLine{4090 }
\DoxyCodeLine{4091         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& generator = \textcolor{keyword}{static\_cast<}IGenerator<UnderlyingType> const\&\textcolor{keyword}{>}( *tracker.getGenerator() );}
\DoxyCodeLine{4092         \textcolor{keywordflow}{return} generator.get();}
\DoxyCodeLine{4093     \}}
\DoxyCodeLine{4094 }
\DoxyCodeLine{4095 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4096 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4097 }
\DoxyCodeLine{4098 \textcolor{preprocessor}{\#define GENERATE( ... ) \(\backslash\)}}
\DoxyCodeLine{4099 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4100 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4101 \textcolor{preprocessor}{                                 [ ]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4102 \textcolor{preprocessor}{\#define GENERATE\_COPY( ... ) \(\backslash\)}}
\DoxyCodeLine{4103 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4104 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4105 \textcolor{preprocessor}{                                 [=]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4106 \textcolor{preprocessor}{\#define GENERATE\_REF( ... ) \(\backslash\)}}
\DoxyCodeLine{4107 \textcolor{preprocessor}{    Catch::Generators::generate( INTERNAL\_CATCH\_STRINGIZE(INTERNAL\_CATCH\_UNIQUE\_NAME(generator)), \(\backslash\)}}
\DoxyCodeLine{4108 \textcolor{preprocessor}{                                 CATCH\_INTERNAL\_LINEINFO, \(\backslash\)}}
\DoxyCodeLine{4109 \textcolor{preprocessor}{                                 [\&]\{ using namespace Catch::Generators; return makeGenerators( \_\_VA\_ARGS\_\_ ); \} ) }\textcolor{comment}{//NOLINT(google-\/build-\/using-\/namespace)}}
\DoxyCodeLine{4110 }
\DoxyCodeLine{4111 \textcolor{comment}{// end catch\_generators.hpp}}
\DoxyCodeLine{4112 \textcolor{comment}{// start catch\_generators\_generic.hpp}}
\DoxyCodeLine{4113 }
\DoxyCodeLine{4114 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4115 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4116 }
\DoxyCodeLine{4117     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4118     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4119         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4120         \textcolor{keywordtype}{size\_t} m\_returned = 0;}
\DoxyCodeLine{4121         \textcolor{keywordtype}{size\_t} m\_target;}
\DoxyCodeLine{4122     \textcolor{keyword}{public}:}
\DoxyCodeLine{4123         \mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator}}(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4124             m\_generator(std::move(generator)),}
\DoxyCodeLine{4125             m\_target(target)}
\DoxyCodeLine{4126         \{}
\DoxyCodeLine{4127             assert(target != 0 \&\& \textcolor{stringliteral}{"{}Empty generators are not allowed"{}});}
\DoxyCodeLine{4128         \}}
\DoxyCodeLine{4129         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4130             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4131         \}}
\DoxyCodeLine{4132         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4133             ++m\_returned;}
\DoxyCodeLine{4134             \textcolor{keywordflow}{if} (m\_returned >= m\_target) \{}
\DoxyCodeLine{4135                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4136             \}}
\DoxyCodeLine{4137 }
\DoxyCodeLine{4138             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4139             \textcolor{comment}{// If the underlying generator does not contain enough values}}
\DoxyCodeLine{4140             \textcolor{comment}{// then we cut short as well}}
\DoxyCodeLine{4141             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4142                 m\_returned = m\_target;}
\DoxyCodeLine{4143             \}}
\DoxyCodeLine{4144             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4145         \}}
\DoxyCodeLine{4146     \};}
\DoxyCodeLine{4147 }
\DoxyCodeLine{4148     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4149     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} take(\textcolor{keywordtype}{size\_t} target, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4150         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_take_generator}{TakeGenerator<T>}}>(target, std::move(generator)));}
\DoxyCodeLine{4151     \}}
\DoxyCodeLine{4152 }
\DoxyCodeLine{4153     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4154     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4155         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4156         Predicate m\_predicate;}
\DoxyCodeLine{4157     \textcolor{keyword}{public}:}
\DoxyCodeLine{4158         \textcolor{keyword}{template} <\textcolor{keyword}{typename} P = Predicate>}
\DoxyCodeLine{4159         \mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator}}(P\&\& pred, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4160             m\_generator(std::move(generator)),}
\DoxyCodeLine{4161             m\_predicate(std::forward<P>(pred))}
\DoxyCodeLine{4162         \{}
\DoxyCodeLine{4163             \textcolor{keywordflow}{if} (!m\_predicate(m\_generator.get())) \{}
\DoxyCodeLine{4164                 \textcolor{comment}{// It might happen that there are no values that pass the}}
\DoxyCodeLine{4165                 \textcolor{comment}{// filter. In that case we throw an exception.}}
\DoxyCodeLine{4166                 \textcolor{keyword}{auto} has\_initial\_value = next();}
\DoxyCodeLine{4167                 \textcolor{keywordflow}{if} (!has\_initial\_value) \{}
\DoxyCodeLine{4168                     Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}No valid value found in filtered generator"{}}));}
\DoxyCodeLine{4169                 \}}
\DoxyCodeLine{4170             \}}
\DoxyCodeLine{4171         \}}
\DoxyCodeLine{4172 }
\DoxyCodeLine{4173         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4174             \textcolor{keywordflow}{return} m\_generator.get();}
\DoxyCodeLine{4175         \}}
\DoxyCodeLine{4176 }
\DoxyCodeLine{4177         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4178             \textcolor{keywordtype}{bool} success = m\_generator.next();}
\DoxyCodeLine{4179             \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4180                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4181             \}}
\DoxyCodeLine{4182             \textcolor{keywordflow}{while} (!m\_predicate(m\_generator.get()) \&\& (success = m\_generator.next()) == \textcolor{keyword}{true});}
\DoxyCodeLine{4183             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4184         \}}
\DoxyCodeLine{4185     \};}
\DoxyCodeLine{4186 }
\DoxyCodeLine{4187     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Predicate>}
\DoxyCodeLine{4188     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} filter(Predicate\&\& pred, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4189         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(std::unique\_ptr<\mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator<T>}}>(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_filter_generator}{FilterGenerator<T, Predicate>}}>(std::forward<Predicate>(pred), std::move(generator))));}
\DoxyCodeLine{4190     \}}
\DoxyCodeLine{4191 }
\DoxyCodeLine{4192     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4193     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4194         \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4195             \textcolor{stringliteral}{"{}RepeatGenerator currently does not support bools"{}}}
\DoxyCodeLine{4196             \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4197         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4198         \textcolor{keyword}{mutable} std::vector<T> m\_returned;}
\DoxyCodeLine{4199         \textcolor{keywordtype}{size\_t} m\_target\_repeats;}
\DoxyCodeLine{4200         \textcolor{keywordtype}{size\_t} m\_current\_repeat = 0;}
\DoxyCodeLine{4201         \textcolor{keywordtype}{size\_t} m\_repeat\_index = 0;}
\DoxyCodeLine{4202     \textcolor{keyword}{public}:}
\DoxyCodeLine{4203         \mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator}}(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator):}
\DoxyCodeLine{4204             m\_generator(std::move(generator)),}
\DoxyCodeLine{4205             m\_target\_repeats(repeats)}
\DoxyCodeLine{4206         \{}
\DoxyCodeLine{4207             assert(m\_target\_repeats > 0 \&\& \textcolor{stringliteral}{"{}Repeat generator must repeat at least once"{}});}
\DoxyCodeLine{4208         \}}
\DoxyCodeLine{4209 }
\DoxyCodeLine{4210         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4211             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4212                 m\_returned.push\_back(m\_generator.get());}
\DoxyCodeLine{4213                 \textcolor{keywordflow}{return} m\_returned.back();}
\DoxyCodeLine{4214             \}}
\DoxyCodeLine{4215             \textcolor{keywordflow}{return} m\_returned[m\_repeat\_index];}
\DoxyCodeLine{4216         \}}
\DoxyCodeLine{4217 }
\DoxyCodeLine{4218         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4219             \textcolor{comment}{// There are 2 basic cases:}}
\DoxyCodeLine{4220             \textcolor{comment}{// 1) We are still reading the generator}}
\DoxyCodeLine{4221             \textcolor{comment}{// 2) We are reading our own cache}}
\DoxyCodeLine{4222 }
\DoxyCodeLine{4223             \textcolor{comment}{// In the first case, we need to poke the underlying generator.}}
\DoxyCodeLine{4224             \textcolor{comment}{// If it happily moves, we are left in that state, otherwise it is time to start reading from our cache}}
\DoxyCodeLine{4225             \textcolor{keywordflow}{if} (m\_current\_repeat == 0) \{}
\DoxyCodeLine{4226                 \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4227                 \textcolor{keywordflow}{if} (!success) \{}
\DoxyCodeLine{4228                     ++m\_current\_repeat;}
\DoxyCodeLine{4229                 \}}
\DoxyCodeLine{4230                 \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4231             \}}
\DoxyCodeLine{4232 }
\DoxyCodeLine{4233             \textcolor{comment}{// In the second case, we need to move indices forward and check that we haven't run up against the end}}
\DoxyCodeLine{4234             ++m\_repeat\_index;}
\DoxyCodeLine{4235             \textcolor{keywordflow}{if} (m\_repeat\_index == m\_returned.size()) \{}
\DoxyCodeLine{4236                 m\_repeat\_index = 0;}
\DoxyCodeLine{4237                 ++m\_current\_repeat;}
\DoxyCodeLine{4238             \}}
\DoxyCodeLine{4239             \textcolor{keywordflow}{return} m\_current\_repeat < m\_target\_repeats;}
\DoxyCodeLine{4240         \}}
\DoxyCodeLine{4241     \};}
\DoxyCodeLine{4242 }
\DoxyCodeLine{4243     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4244     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} repeat(\textcolor{keywordtype}{size\_t} repeats, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4245         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_repeat_generator}{RepeatGenerator<T>}}>(repeats, std::move(generator)));}
\DoxyCodeLine{4246     \}}
\DoxyCodeLine{4247 }
\DoxyCodeLine{4248     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4249     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4250         \textcolor{comment}{// TBD: provide static assert for mapping function, for friendly error message}}
\DoxyCodeLine{4251         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}} m\_generator;}
\DoxyCodeLine{4252         Func m\_function;}
\DoxyCodeLine{4253         \textcolor{comment}{// To avoid returning dangling reference, we have to save the values}}
\DoxyCodeLine{4254         T m\_cache;}
\DoxyCodeLine{4255     \textcolor{keyword}{public}:}
\DoxyCodeLine{4256         \textcolor{keyword}{template} <\textcolor{keyword}{typename} F2 = Func>}
\DoxyCodeLine{4257         \mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator}}(F2\&\& \textcolor{keyword}{function}, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}}\&\& generator) :}
\DoxyCodeLine{4258             m\_generator(std::move(generator)),}
\DoxyCodeLine{4259             m\_function(std::forward<F2>(\textcolor{keyword}{function})),}
\DoxyCodeLine{4260             m\_cache(m\_function(m\_generator.get()))}
\DoxyCodeLine{4261         \{\}}
\DoxyCodeLine{4262 }
\DoxyCodeLine{4263         T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4264             \textcolor{keywordflow}{return} m\_cache;}
\DoxyCodeLine{4265         \}}
\DoxyCodeLine{4266         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4267             \textcolor{keyword}{const} \textcolor{keyword}{auto} success = m\_generator.next();}
\DoxyCodeLine{4268             \textcolor{keywordflow}{if} (success) \{}
\DoxyCodeLine{4269                 m\_cache = m\_function(m\_generator.get());}
\DoxyCodeLine{4270             \}}
\DoxyCodeLine{4271             \textcolor{keywordflow}{return} success;}
\DoxyCodeLine{4272         \}}
\DoxyCodeLine{4273     \};}
\DoxyCodeLine{4274 }
\DoxyCodeLine{4275     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Func, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} T = FunctionReturnType<Func, U>>}
\DoxyCodeLine{4276     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} map(Func\&\& \textcolor{keyword}{function}, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<U>}}\&\& generator) \{}
\DoxyCodeLine{4277         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4278             pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_map_generator}{MapGenerator<T, U, Func>}}>(std::forward<Func>(\textcolor{keyword}{function}), std::move(generator))}
\DoxyCodeLine{4279         );}
\DoxyCodeLine{4280     \}}
\DoxyCodeLine{4281 }
\DoxyCodeLine{4282     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U, \textcolor{keyword}{typename} Func>}
\DoxyCodeLine{4283     GeneratorWrapper<T> map(Func\&\& \textcolor{keyword}{function}, GeneratorWrapper<U>\&\& generator) \{}
\DoxyCodeLine{4284         \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4285             pf::make\_unique<MapGenerator<T, U, Func>>(std::forward<Func>(\textcolor{keyword}{function}), std::move(generator))}
\DoxyCodeLine{4286         );}
\DoxyCodeLine{4287     \}}
\DoxyCodeLine{4288 }
\DoxyCodeLine{4289     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4290     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_chunk_generator}{ChunkGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<std::vector<T>> \{}
\DoxyCodeLine{4291         std::vector<T> m\_chunk;}
\DoxyCodeLine{4292         \textcolor{keywordtype}{size\_t} m\_chunk\_size;}
\DoxyCodeLine{4293         \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} m\_generator;}
\DoxyCodeLine{4294         \textcolor{keywordtype}{bool} m\_used\_up = \textcolor{keyword}{false};}
\DoxyCodeLine{4295     \textcolor{keyword}{public}:}
\DoxyCodeLine{4296         \mbox{\hyperlink{class_catch_1_1_generators_1_1_chunk_generator}{ChunkGenerator}}(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} generator) :}
\DoxyCodeLine{4297             m\_chunk\_size(size), m\_generator(std::move(generator))}
\DoxyCodeLine{4298         \{}
\DoxyCodeLine{4299             m\_chunk.reserve(m\_chunk\_size);}
\DoxyCodeLine{4300             \textcolor{keywordflow}{if} (m\_chunk\_size != 0) \{}
\DoxyCodeLine{4301                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4302                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < m\_chunk\_size; ++i) \{}
\DoxyCodeLine{4303                     \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4304                         Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}Not enough values to initialize the first chunk"{}}));}
\DoxyCodeLine{4305                     \}}
\DoxyCodeLine{4306                     m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4307                 \}}
\DoxyCodeLine{4308             \}}
\DoxyCodeLine{4309         \}}
\DoxyCodeLine{4310         std::vector<T> \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4311             \textcolor{keywordflow}{return} m\_chunk;}
\DoxyCodeLine{4312         \}}
\DoxyCodeLine{4313         \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4314             m\_chunk.clear();}
\DoxyCodeLine{4315             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} idx = 0; idx < m\_chunk\_size; ++idx) \{}
\DoxyCodeLine{4316                 \textcolor{keywordflow}{if} (!m\_generator.next()) \{}
\DoxyCodeLine{4317                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4318                 \}}
\DoxyCodeLine{4319                 m\_chunk.push\_back(m\_generator.get());}
\DoxyCodeLine{4320             \}}
\DoxyCodeLine{4321             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4322         \}}
\DoxyCodeLine{4323     \};}
\DoxyCodeLine{4324 }
\DoxyCodeLine{4325     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4326     \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<std::vector<T>}}> chunk(\textcolor{keywordtype}{size\_t} size, \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}\&\& generator) \{}
\DoxyCodeLine{4327         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<std::vector<T>}}>(}
\DoxyCodeLine{4328             pf::make\_unique<ChunkGenerator<T>>(size, std::move(generator))}
\DoxyCodeLine{4329         );}
\DoxyCodeLine{4330     \}}
\DoxyCodeLine{4331 }
\DoxyCodeLine{4332 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4333 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4334 }
\DoxyCodeLine{4335 \textcolor{comment}{// end catch\_generators\_generic.hpp}}
\DoxyCodeLine{4336 \textcolor{comment}{// start catch\_generators\_specific.hpp}}
\DoxyCodeLine{4337 }
\DoxyCodeLine{4338 \textcolor{comment}{// start catch\_context.h}}
\DoxyCodeLine{4339 }
\DoxyCodeLine{4340 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4341 }
\DoxyCodeLine{4342 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4343 }
\DoxyCodeLine{4344     \textcolor{keyword}{struct }IResultCapture;}
\DoxyCodeLine{4345     \textcolor{keyword}{struct }IRunner;}
\DoxyCodeLine{4346     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{4347     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{4348 }
\DoxyCodeLine{4349     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4350 }
\DoxyCodeLine{4351     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_context}{IContext}}}
\DoxyCodeLine{4352     \{}
\DoxyCodeLine{4353         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_context}{\string~IContext}}();}
\DoxyCodeLine{4354 }
\DoxyCodeLine{4355         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}* getResultCapture() = 0;}
\DoxyCodeLine{4356         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}}* getRunner() = 0;}
\DoxyCodeLine{4357         \textcolor{keyword}{virtual} IConfigPtr \textcolor{keyword}{const}\& getConfig() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4358     \};}
\DoxyCodeLine{4359 }
\DoxyCodeLine{4360     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}} : \mbox{\hyperlink{struct_catch_1_1_i_context}{IContext}}}
\DoxyCodeLine{4361     \{}
\DoxyCodeLine{4362         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{\string~IMutableContext}}();}
\DoxyCodeLine{4363         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setResultCapture( \mbox{\hyperlink{struct_catch_1_1_i_result_capture}{IResultCapture}}* resultCapture ) = 0;}
\DoxyCodeLine{4364         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setRunner( \mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}}* runner ) = 0;}
\DoxyCodeLine{4365         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config ) = 0;}
\DoxyCodeLine{4366 }
\DoxyCodeLine{4367     \textcolor{keyword}{private}:}
\DoxyCodeLine{4368         \textcolor{keyword}{static} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}} *currentContext;}
\DoxyCodeLine{4369         \textcolor{keyword}{friend} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}}\& getCurrentMutableContext();}
\DoxyCodeLine{4370         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4371         \textcolor{keyword}{static} \textcolor{keywordtype}{void} createContext();}
\DoxyCodeLine{4372     \};}
\DoxyCodeLine{4373 }
\DoxyCodeLine{4374     \textcolor{keyword}{inline} \mbox{\hyperlink{struct_catch_1_1_i_mutable_context}{IMutableContext}}\& getCurrentMutableContext()}
\DoxyCodeLine{4375     \{}
\DoxyCodeLine{4376         \textcolor{keywordflow}{if}( !IMutableContext::currentContext )}
\DoxyCodeLine{4377             IMutableContext::createContext();}
\DoxyCodeLine{4378         \textcolor{comment}{// NOLINTNEXTLINE(clang-\/analyzer-\/core.uninitialized.UndefReturn)}}
\DoxyCodeLine{4379         \textcolor{keywordflow}{return} *IMutableContext::currentContext;}
\DoxyCodeLine{4380     \}}
\DoxyCodeLine{4381 }
\DoxyCodeLine{4382     \textcolor{keyword}{inline} IContext\& getCurrentContext()}
\DoxyCodeLine{4383     \{}
\DoxyCodeLine{4384         \textcolor{keywordflow}{return} getCurrentMutableContext();}
\DoxyCodeLine{4385     \}}
\DoxyCodeLine{4386 }
\DoxyCodeLine{4387     \textcolor{keywordtype}{void} cleanUpContext();}
\DoxyCodeLine{4388 }
\DoxyCodeLine{4389     \textcolor{keyword}{class }SimplePcg32;}
\DoxyCodeLine{4390     SimplePcg32\& rng();}
\DoxyCodeLine{4391 \}}
\DoxyCodeLine{4392 }
\DoxyCodeLine{4393 \textcolor{comment}{// end catch\_context.h}}
\DoxyCodeLine{4394 \textcolor{comment}{// start catch\_interfaces\_config.h}}
\DoxyCodeLine{4395 }
\DoxyCodeLine{4396 \textcolor{comment}{// start catch\_option.hpp}}
\DoxyCodeLine{4397 }
\DoxyCodeLine{4398 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4399 }
\DoxyCodeLine{4400     \textcolor{comment}{// An optional type}}
\DoxyCodeLine{4401     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4402     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_option}{Option}} \{}
\DoxyCodeLine{4403     \textcolor{keyword}{public}:}
\DoxyCodeLine{4404         \mbox{\hyperlink{class_catch_1_1_option}{Option}}() : nullableValue( \textcolor{keyword}{nullptr} ) \{\}}
\DoxyCodeLine{4405         \mbox{\hyperlink{class_catch_1_1_option}{Option}}( T \textcolor{keyword}{const}\& \_value )}
\DoxyCodeLine{4406         : nullableValue( \textcolor{keyword}{new}( storage ) T( \_value ) )}
\DoxyCodeLine{4407         \{\}}
\DoxyCodeLine{4408         \mbox{\hyperlink{class_catch_1_1_option}{Option}}( \mbox{\hyperlink{class_catch_1_1_option}{Option}} \textcolor{keyword}{const}\& \_other )}
\DoxyCodeLine{4409         : nullableValue( \_other ? \textcolor{keyword}{new}( storage ) T( *\_other ) : \textcolor{keyword}{nullptr} )}
\DoxyCodeLine{4410         \{\}}
\DoxyCodeLine{4411 }
\DoxyCodeLine{4412         \mbox{\hyperlink{class_catch_1_1_option}{\string~Option}}() \{}
\DoxyCodeLine{4413             reset();}
\DoxyCodeLine{4414         \}}
\DoxyCodeLine{4415 }
\DoxyCodeLine{4416         \mbox{\hyperlink{class_catch_1_1_option}{Option}}\& operator= ( \mbox{\hyperlink{class_catch_1_1_option}{Option}} \textcolor{keyword}{const}\& \_other ) \{}
\DoxyCodeLine{4417             \textcolor{keywordflow}{if}( \&\_other != \textcolor{keyword}{this} ) \{}
\DoxyCodeLine{4418                 reset();}
\DoxyCodeLine{4419                 \textcolor{keywordflow}{if}( \_other )}
\DoxyCodeLine{4420                     nullableValue = \textcolor{keyword}{new}( storage ) T( *\_other );}
\DoxyCodeLine{4421             \}}
\DoxyCodeLine{4422             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4423         \}}
\DoxyCodeLine{4424         \mbox{\hyperlink{class_catch_1_1_option}{Option}}\& operator = ( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{4425             reset();}
\DoxyCodeLine{4426             nullableValue = \textcolor{keyword}{new}( storage ) T( \_value );}
\DoxyCodeLine{4427             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{4428         \}}
\DoxyCodeLine{4429 }
\DoxyCodeLine{4430         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{4431             \textcolor{keywordflow}{if}( nullableValue )}
\DoxyCodeLine{4432                 nullableValue-\/>\string~T();}
\DoxyCodeLine{4433             nullableValue = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{4434         \}}
\DoxyCodeLine{4435 }
\DoxyCodeLine{4436         T\& operator*() \{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4437         T \textcolor{keyword}{const}\& operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *nullableValue; \}}
\DoxyCodeLine{4438         T* operator-\/>() \{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4439         \textcolor{keyword}{const} T* operator-\/>()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue; \}}
\DoxyCodeLine{4440 }
\DoxyCodeLine{4441         T valueOr( T \textcolor{keyword}{const}\& defaultValue )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4442             \textcolor{keywordflow}{return} nullableValue ? *nullableValue : defaultValue;}
\DoxyCodeLine{4443         \}}
\DoxyCodeLine{4444 }
\DoxyCodeLine{4445         \textcolor{keywordtype}{bool} some()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4446         \textcolor{keywordtype}{bool} none()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4447 }
\DoxyCodeLine{4448         \textcolor{keywordtype}{bool} operator !()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} nullableValue == \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{4449         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4450             \textcolor{keywordflow}{return} some();}
\DoxyCodeLine{4451         \}}
\DoxyCodeLine{4452 }
\DoxyCodeLine{4453     \textcolor{keyword}{private}:}
\DoxyCodeLine{4454         T *nullableValue;}
\DoxyCodeLine{4455         \textcolor{keyword}{alignas}(\textcolor{keyword}{alignof}(T)) \textcolor{keywordtype}{char} storage[\textcolor{keyword}{sizeof}(T)];}
\DoxyCodeLine{4456     \};}
\DoxyCodeLine{4457 }
\DoxyCodeLine{4458 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4459 }
\DoxyCodeLine{4460 \textcolor{comment}{// end catch\_option.hpp}}
\DoxyCodeLine{4461 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{4462 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{4463 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4464 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4465 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4467 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4468 }
\DoxyCodeLine{4469     \textcolor{keyword}{enum class} Verbosity \{}
\DoxyCodeLine{4470         Quiet = 0,}
\DoxyCodeLine{4471         Normal,}
\DoxyCodeLine{4472         High}
\DoxyCodeLine{4473     \};}
\DoxyCodeLine{4474 }
\DoxyCodeLine{4475     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_warn_about}{WarnAbout}} \{ \textcolor{keyword}{enum} What \{}
\DoxyCodeLine{4476         Nothing = 0x00,}
\DoxyCodeLine{4477         NoAssertions = 0x01,}
\DoxyCodeLine{4478         NoTests = 0x02}
\DoxyCodeLine{4479     \}; \};}
\DoxyCodeLine{4480 }
\DoxyCodeLine{4481     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_show_durations}{ShowDurations}} \{ \textcolor{keyword}{enum} OrNot \{}
\DoxyCodeLine{4482         DefaultForReporter,}
\DoxyCodeLine{4483         Always,}
\DoxyCodeLine{4484         Never}
\DoxyCodeLine{4485     \}; \};}
\DoxyCodeLine{4486     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_run_tests}{RunTests}} \{ \textcolor{keyword}{enum} InWhatOrder \{}
\DoxyCodeLine{4487         InDeclarationOrder,}
\DoxyCodeLine{4488         InLexicographicalOrder,}
\DoxyCodeLine{4489         InRandomOrder}
\DoxyCodeLine{4490     \}; \};}
\DoxyCodeLine{4491     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_use_colour}{UseColour}} \{ \textcolor{keyword}{enum} YesOrNo \{}
\DoxyCodeLine{4492         Auto,}
\DoxyCodeLine{4493         Yes,}
\DoxyCodeLine{4494         No}
\DoxyCodeLine{4495     \}; \};}
\DoxyCodeLine{4496     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_wait_for_keypress}{WaitForKeypress}} \{ \textcolor{keyword}{enum} When \{}
\DoxyCodeLine{4497         Never,}
\DoxyCodeLine{4498         BeforeStart = 1,}
\DoxyCodeLine{4499         BeforeExit = 2,}
\DoxyCodeLine{4500         BeforeStartAndExit = BeforeStart | BeforeExit}
\DoxyCodeLine{4501     \}; \};}
\DoxyCodeLine{4502 }
\DoxyCodeLine{4503     \textcolor{keyword}{class }TestSpec;}
\DoxyCodeLine{4504 }
\DoxyCodeLine{4505     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_config}{IConfig}} : \mbox{\hyperlink{class_catch_1_1_non_copyable}{NonCopyable}} \{}
\DoxyCodeLine{4506 }
\DoxyCodeLine{4507         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_config}{\string~IConfig}}();}
\DoxyCodeLine{4508 }
\DoxyCodeLine{4509         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4510         \textcolor{keyword}{virtual} std::ostream\& stream() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4511         \textcolor{keyword}{virtual} std::string name() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4513         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4514         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4515         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4516         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4517         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4518         \textcolor{keyword}{virtual} ShowDurations::OrNot showDurations() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4519         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4520         \textcolor{keyword}{virtual} TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4521         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4522         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4523         \textcolor{keyword}{virtual} RunTests::InWhatOrder runOrder() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4524         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4525         \textcolor{keyword}{virtual} UseColour::YesOrNo useColour() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4526         \textcolor{keyword}{virtual} std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4527         \textcolor{keyword}{virtual} Verbosity verbosity() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4528 }
\DoxyCodeLine{4529         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4530         \textcolor{keyword}{virtual} \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4531         \textcolor{keyword}{virtual} \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4532         \textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4533         \textcolor{keyword}{virtual} std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4534     \};}
\DoxyCodeLine{4535 }
\DoxyCodeLine{4536     \textcolor{keyword}{using} IConfigPtr = std::shared\_ptr<IConfig const>;}
\DoxyCodeLine{4537 \}}
\DoxyCodeLine{4538 }
\DoxyCodeLine{4539 \textcolor{comment}{// end catch\_interfaces\_config.h}}
\DoxyCodeLine{4540 \textcolor{comment}{// start catch\_random\_number\_generator.h}}
\DoxyCodeLine{4541 }
\DoxyCodeLine{4542 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{4543 }
\DoxyCodeLine{4544 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4545 }
\DoxyCodeLine{4546     \textcolor{comment}{// This is a simple implementation of C++11 Uniform Random Number}}
\DoxyCodeLine{4547     \textcolor{comment}{// Generator. It does not provide all operators, because Catch2}}
\DoxyCodeLine{4548     \textcolor{comment}{// does not use it, but it should behave as expected inside stdlib's}}
\DoxyCodeLine{4549     \textcolor{comment}{// distributions.}}
\DoxyCodeLine{4550     \textcolor{comment}{// The implementation is based on the PCG family (http://pcg-\/random.org)}}
\DoxyCodeLine{4551     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \{}
\DoxyCodeLine{4552         \textcolor{keyword}{using} state\_type = std::uint64\_t;}
\DoxyCodeLine{4553     \textcolor{keyword}{public}:}
\DoxyCodeLine{4554         \textcolor{keyword}{using} result\_type = std::uint32\_t;}
\DoxyCodeLine{4555         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (min)() \{}
\DoxyCodeLine{4556             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{4557         \}}
\DoxyCodeLine{4558         \textcolor{keyword}{static} \textcolor{keyword}{constexpr} result\_type (max)() \{}
\DoxyCodeLine{4559             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}result\_type\textcolor{keyword}{>}(-\/1);}
\DoxyCodeLine{4560         \}}
\DoxyCodeLine{4561 }
\DoxyCodeLine{4562         \textcolor{comment}{// Provide some default initial state for the default constructor}}
\DoxyCodeLine{4563         \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}():\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}(0xed743cc4U) \{\}}
\DoxyCodeLine{4564 }
\DoxyCodeLine{4565         \textcolor{keyword}{explicit} \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}}(result\_type seed\_);}
\DoxyCodeLine{4566 }
\DoxyCodeLine{4567         \textcolor{keywordtype}{void} seed(result\_type seed\_);}
\DoxyCodeLine{4568         \textcolor{keywordtype}{void} discard(uint64\_t skip);}
\DoxyCodeLine{4569 }
\DoxyCodeLine{4570         result\_type operator()();}
\DoxyCodeLine{4571 }
\DoxyCodeLine{4572     \textcolor{keyword}{private}:}
\DoxyCodeLine{4573         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4574         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator!=(\mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& lhs, \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{SimplePcg32}} \textcolor{keyword}{const}\& rhs);}
\DoxyCodeLine{4575 }
\DoxyCodeLine{4576         \textcolor{comment}{// In theory we also need operator<< and operator>>}}
\DoxyCodeLine{4577         \textcolor{comment}{// In practice we do not use them, so we will skip them for now}}
\DoxyCodeLine{4578 }
\DoxyCodeLine{4579         std::uint64\_t m\_state;}
\DoxyCodeLine{4580         \textcolor{comment}{// This part of the state determines which "{}stream"{} of the numbers}}
\DoxyCodeLine{4581         \textcolor{comment}{// is chosen -\/-\/ we take it as a constant for Catch2, so we only}}
\DoxyCodeLine{4582         \textcolor{comment}{// need to deal with seeding the main state.}}
\DoxyCodeLine{4583         \textcolor{comment}{// Picked by reading 8 bytes from `/dev/random` :-\/)}}
\DoxyCodeLine{4584         \textcolor{keyword}{static} \textcolor{keyword}{const} std::uint64\_t s\_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;}
\DoxyCodeLine{4585     \};}
\DoxyCodeLine{4586 }
\DoxyCodeLine{4587 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{4588 }
\DoxyCodeLine{4589 \textcolor{comment}{// end catch\_random\_number\_generator.h}}
\DoxyCodeLine{4590 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{4591 }
\DoxyCodeLine{4592 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4593 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{4594 }
\DoxyCodeLine{4595 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{4596 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_floating_generator}{RandomFloatingGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<Float> \{}
\DoxyCodeLine{4597     \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4598     std::uniform\_real\_distribution<Float> m\_dist;}
\DoxyCodeLine{4599     Float m\_current\_number;}
\DoxyCodeLine{4600 \textcolor{keyword}{public}:}
\DoxyCodeLine{4601 }
\DoxyCodeLine{4602     \mbox{\hyperlink{class_catch_1_1_generators_1_1_random_floating_generator}{RandomFloatingGenerator}}(Float a, Float b):}
\DoxyCodeLine{4603         m\_rng(rng()),}
\DoxyCodeLine{4604         m\_dist(a, b) \{}
\DoxyCodeLine{4605         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4606     \}}
\DoxyCodeLine{4607 }
\DoxyCodeLine{4608     Float \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4609         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4610     \}}
\DoxyCodeLine{4611     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4612         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4613         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4614     \}}
\DoxyCodeLine{4615 \};}
\DoxyCodeLine{4616 }
\DoxyCodeLine{4617 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Integer>}
\DoxyCodeLine{4618 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<Integer> \{}
\DoxyCodeLine{4619     \mbox{\hyperlink{class_catch_1_1_simple_pcg32}{Catch::SimplePcg32}}\& m\_rng;}
\DoxyCodeLine{4620     std::uniform\_int\_distribution<Integer> m\_dist;}
\DoxyCodeLine{4621     Integer m\_current\_number;}
\DoxyCodeLine{4622 \textcolor{keyword}{public}:}
\DoxyCodeLine{4623 }
\DoxyCodeLine{4624     \mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator}}(Integer a, Integer b):}
\DoxyCodeLine{4625         m\_rng(rng()),}
\DoxyCodeLine{4626         m\_dist(a, b) \{}
\DoxyCodeLine{4627         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(next());}
\DoxyCodeLine{4628     \}}
\DoxyCodeLine{4629 }
\DoxyCodeLine{4630     Integer \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4631         \textcolor{keywordflow}{return} m\_current\_number;}
\DoxyCodeLine{4632     \}}
\DoxyCodeLine{4633     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4634         m\_current\_number = m\_dist(m\_rng);}
\DoxyCodeLine{4635         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{4636     \}}
\DoxyCodeLine{4637 \};}
\DoxyCodeLine{4638 }
\DoxyCodeLine{4639 \textcolor{comment}{// TODO: Ideally this would be also constrained against the various char types,}}
\DoxyCodeLine{4640 \textcolor{comment}{//       but I don't expect users to run into that in practice.}}
\DoxyCodeLine{4641 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4642 \textcolor{keyword}{typename} std::enable\_if<std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value,}
\DoxyCodeLine{4643 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}>::type}
\DoxyCodeLine{4644 random(T a, T b) \{}
\DoxyCodeLine{4645     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(}
\DoxyCodeLine{4646         pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_random_integer_generator}{RandomIntegerGenerator<T>}}>(a, b)}
\DoxyCodeLine{4647     );}
\DoxyCodeLine{4648 \}}
\DoxyCodeLine{4649 }
\DoxyCodeLine{4650 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4651 \textcolor{keyword}{typename} std::enable\_if<std::is\_floating\_point<T>::value,}
\DoxyCodeLine{4652 GeneratorWrapper<T>>::type}
\DoxyCodeLine{4653 random(T a, T b) \{}
\DoxyCodeLine{4654     \textcolor{keywordflow}{return} GeneratorWrapper<T>(}
\DoxyCodeLine{4655         pf::make\_unique<RandomFloatingGenerator<T>>(a, b)}
\DoxyCodeLine{4656     );}
\DoxyCodeLine{4657 \}}
\DoxyCodeLine{4658 }
\DoxyCodeLine{4659 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4660 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4661     T m\_current;}
\DoxyCodeLine{4662     T m\_end;}
\DoxyCodeLine{4663     T m\_step;}
\DoxyCodeLine{4664     \textcolor{keywordtype}{bool} m\_positive;}
\DoxyCodeLine{4665 }
\DoxyCodeLine{4666 \textcolor{keyword}{public}:}
\DoxyCodeLine{4667     \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step):}
\DoxyCodeLine{4668         m\_current(start),}
\DoxyCodeLine{4669         m\_end(end),}
\DoxyCodeLine{4670         m\_step(step),}
\DoxyCodeLine{4671         m\_positive(m\_step > T(0))}
\DoxyCodeLine{4672     \{}
\DoxyCodeLine{4673         assert(m\_current != m\_end \&\& \textcolor{stringliteral}{"{}Range start and end cannot be equal"{}});}
\DoxyCodeLine{4674         assert(m\_step != T(0) \&\& \textcolor{stringliteral}{"{}Step size cannot be zero"{}});}
\DoxyCodeLine{4675         assert(((m\_positive \&\& m\_current <= m\_end) || (!m\_positive \&\& m\_current >= m\_end)) \&\& \textcolor{stringliteral}{"{}Step moves away from end"{}});}
\DoxyCodeLine{4676     \}}
\DoxyCodeLine{4677 }
\DoxyCodeLine{4678     \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end):}
\DoxyCodeLine{4679         \mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator}}(start, end, (start < end) ? T(1) : T(-\/1))}
\DoxyCodeLine{4680     \{\}}
\DoxyCodeLine{4681 }
\DoxyCodeLine{4682     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4683         \textcolor{keywordflow}{return} m\_current;}
\DoxyCodeLine{4684     \}}
\DoxyCodeLine{4685 }
\DoxyCodeLine{4686     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4687         m\_current += m\_step;}
\DoxyCodeLine{4688         \textcolor{keywordflow}{return} (m\_positive) ? (m\_current < m\_end) : (m\_current > m\_end);}
\DoxyCodeLine{4689     \}}
\DoxyCodeLine{4690 \};}
\DoxyCodeLine{4691 }
\DoxyCodeLine{4692 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4693 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}} range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end, T \textcolor{keyword}{const}\& step) \{}
\DoxyCodeLine{4694     \textcolor{keyword}{static\_assert}(std::is\_arithmetic<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be numeric"{}});}
\DoxyCodeLine{4695     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<T>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_range_generator}{RangeGenerator<T>}}>(start, end, step));}
\DoxyCodeLine{4696 \}}
\DoxyCodeLine{4697 }
\DoxyCodeLine{4698 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4699 GeneratorWrapper<T> range(T \textcolor{keyword}{const}\& start, T \textcolor{keyword}{const}\& end) \{}
\DoxyCodeLine{4700     \textcolor{keyword}{static\_assert}(std::is\_integral<T>::value \&\& !std::is\_same<T, bool>::value, \textcolor{stringliteral}{"{}Type must be an integer"{}});}
\DoxyCodeLine{4701     \textcolor{keywordflow}{return} GeneratorWrapper<T>(pf::make\_unique<RangeGenerator<T>>(start, end));}
\DoxyCodeLine{4702 \}}
\DoxyCodeLine{4703 }
\DoxyCodeLine{4704 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{4705 \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator}} final : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_generators_1_1_i_generator}{IGenerator}}<T> \{}
\DoxyCodeLine{4706     \textcolor{keyword}{static\_assert}(!std::is\_same<T, bool>::value,}
\DoxyCodeLine{4707         \textcolor{stringliteral}{"{}IteratorGenerator currently does not support bools"{}}}
\DoxyCodeLine{4708         \textcolor{stringliteral}{"{}because of std::vector<bool> specialization"{}});}
\DoxyCodeLine{4709 }
\DoxyCodeLine{4710     std::vector<T> m\_elems;}
\DoxyCodeLine{4711     \textcolor{keywordtype}{size\_t} m\_current = 0;}
\DoxyCodeLine{4712 \textcolor{keyword}{public}:}
\DoxyCodeLine{4713     \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator, \textcolor{keyword}{typename} InputSentinel>}
\DoxyCodeLine{4714     \mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator}}(InputIterator first, InputSentinel last):m\_elems(first, last) \{}
\DoxyCodeLine{4715         \textcolor{keywordflow}{if} (m\_elems.empty()) \{}
\DoxyCodeLine{4716             Catch::throw\_exception(\mbox{\hyperlink{class_catch_1_1_generator_exception}{GeneratorException}}(\textcolor{stringliteral}{"{}IteratorGenerator received no valid values"{}}));}
\DoxyCodeLine{4717         \}}
\DoxyCodeLine{4718     \}}
\DoxyCodeLine{4719 }
\DoxyCodeLine{4720     T \textcolor{keyword}{const}\& get()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4721         \textcolor{keywordflow}{return} m\_elems[m\_current];}
\DoxyCodeLine{4722     \}}
\DoxyCodeLine{4723 }
\DoxyCodeLine{4724     \textcolor{keywordtype}{bool} next()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{4725         ++m\_current;}
\DoxyCodeLine{4726         \textcolor{keywordflow}{return} m\_current != m\_elems.size();}
\DoxyCodeLine{4727     \}}
\DoxyCodeLine{4728 \};}
\DoxyCodeLine{4729 }
\DoxyCodeLine{4730 \textcolor{keyword}{template} <\textcolor{keyword}{typename} InputIterator,}
\DoxyCodeLine{4731           \textcolor{keyword}{typename} InputSentinel,}
\DoxyCodeLine{4732           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} std::iterator\_traits<InputIterator>::value\_type>}
\DoxyCodeLine{4733 \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<ResultType>}} from\_range(InputIterator from, InputSentinel to) \{}
\DoxyCodeLine{4734     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_generators_1_1_generator_wrapper}{GeneratorWrapper<ResultType>}}(pf::make\_unique<\mbox{\hyperlink{class_catch_1_1_generators_1_1_iterator_generator}{IteratorGenerator<ResultType>}}>(from, to));}
\DoxyCodeLine{4735 \}}
\DoxyCodeLine{4736 }
\DoxyCodeLine{4737 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container,}
\DoxyCodeLine{4738           \textcolor{keyword}{typename} ResultType = \textcolor{keyword}{typename} Container::value\_type>}
\DoxyCodeLine{4739 GeneratorWrapper<ResultType> from\_range(Container \textcolor{keyword}{const}\& cnt) \{}
\DoxyCodeLine{4740     \textcolor{keywordflow}{return} GeneratorWrapper<ResultType>(pf::make\_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));}
\DoxyCodeLine{4741 \}}
\DoxyCodeLine{4742 }
\DoxyCodeLine{4743 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{4744 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{4745 }
\DoxyCodeLine{4746 \textcolor{comment}{// end catch\_generators\_specific.hpp}}
\DoxyCodeLine{4747 }
\DoxyCodeLine{4748 \textcolor{comment}{// These files are included here so the single\_include script doesn't put them}}
\DoxyCodeLine{4749 \textcolor{comment}{// in the conditionally compiled sections}}
\DoxyCodeLine{4750 \textcolor{comment}{// start catch\_test\_case\_info.h}}
\DoxyCodeLine{4751 }
\DoxyCodeLine{4752 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4753 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{4754 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{4755 }
\DoxyCodeLine{4756 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4757 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{4758 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{4759 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4760 }
\DoxyCodeLine{4761 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4762 }
\DoxyCodeLine{4763     \textcolor{keyword}{struct }ITestInvoker;}
\DoxyCodeLine{4764 }
\DoxyCodeLine{4765     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \{}
\DoxyCodeLine{4766         \textcolor{keyword}{enum} SpecialProperties\{}
\DoxyCodeLine{4767             None = 0,}
\DoxyCodeLine{4768             IsHidden = 1 << 1,}
\DoxyCodeLine{4769             ShouldFail = 1 << 2,}
\DoxyCodeLine{4770             MayFail = 1 << 3,}
\DoxyCodeLine{4771             Throws = 1 << 4,}
\DoxyCodeLine{4772             NonPortable = 1 << 5,}
\DoxyCodeLine{4773             Benchmark = 1 << 6}
\DoxyCodeLine{4774         \};}
\DoxyCodeLine{4775 }
\DoxyCodeLine{4776         \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}(   std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{4777                         std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{4778                         std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{4779                         std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{4780                         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& \_lineInfo );}
\DoxyCodeLine{4781 }
\DoxyCodeLine{4782         \textcolor{keyword}{friend} \textcolor{keywordtype}{void} setTags( \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}\& testCaseInfo, std::vector<std::string> tags );}
\DoxyCodeLine{4783 }
\DoxyCodeLine{4784         \textcolor{keywordtype}{bool} isHidden() \textcolor{keyword}{const};}
\DoxyCodeLine{4785         \textcolor{keywordtype}{bool} \textcolor{keywordflow}{throws}() \textcolor{keyword}{const};}
\DoxyCodeLine{4786         \textcolor{keywordtype}{bool} okToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4787         \textcolor{keywordtype}{bool} expectedToFail() \textcolor{keyword}{const};}
\DoxyCodeLine{4788 }
\DoxyCodeLine{4789         std::string tagsAsString() \textcolor{keyword}{const};}
\DoxyCodeLine{4790 }
\DoxyCodeLine{4791         std::string name;}
\DoxyCodeLine{4792         std::string className;}
\DoxyCodeLine{4793         std::string description;}
\DoxyCodeLine{4794         std::vector<std::string> tags;}
\DoxyCodeLine{4795         std::vector<std::string> lcaseTags;}
\DoxyCodeLine{4796         \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} lineInfo;}
\DoxyCodeLine{4797         SpecialProperties properties;}
\DoxyCodeLine{4798     \};}
\DoxyCodeLine{4799 }
\DoxyCodeLine{4800     \textcolor{keyword}{class }\mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} : \textcolor{keyword}{public} \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \{}
\DoxyCodeLine{4801     \textcolor{keyword}{public}:}
\DoxyCodeLine{4802 }
\DoxyCodeLine{4803         \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}}( \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* testCase, \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}}\&\& info );}
\DoxyCodeLine{4804 }
\DoxyCodeLine{4805         \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} withName( std::string \textcolor{keyword}{const}\& \_newName ) \textcolor{keyword}{const};}
\DoxyCodeLine{4806 }
\DoxyCodeLine{4807         \textcolor{keywordtype}{void} invoke() \textcolor{keyword}{const};}
\DoxyCodeLine{4808 }
\DoxyCodeLine{4809         \mbox{\hyperlink{struct_catch_1_1_test_case_info}{TestCaseInfo}} \textcolor{keyword}{const}\& getTestCaseInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{4810 }
\DoxyCodeLine{4811         \textcolor{keywordtype}{bool} operator == ( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4812         \textcolor{keywordtype}{bool} operator < ( \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const};}
\DoxyCodeLine{4813 }
\DoxyCodeLine{4814     \textcolor{keyword}{private}:}
\DoxyCodeLine{4815         std::shared\_ptr<ITestInvoker> test;}
\DoxyCodeLine{4816     \};}
\DoxyCodeLine{4817 }
\DoxyCodeLine{4818     \mbox{\hyperlink{class_catch_1_1_test_case}{TestCase}} makeTestCase(  \mbox{\hyperlink{struct_catch_1_1_i_test_invoker}{ITestInvoker}}* testCase,}
\DoxyCodeLine{4819                             std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{4820                             \mbox{\hyperlink{struct_catch_1_1_name_and_tags}{NameAndTags}} \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{4821                             \mbox{\hyperlink{struct_catch_1_1_source_line_info}{SourceLineInfo}} \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{4822 \}}
\DoxyCodeLine{4823 }
\DoxyCodeLine{4824 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{4825 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{4826 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4827 }
\DoxyCodeLine{4828 \textcolor{comment}{// end catch\_test\_case\_info.h}}
\DoxyCodeLine{4829 \textcolor{comment}{// start catch\_interfaces\_runner.h}}
\DoxyCodeLine{4830 }
\DoxyCodeLine{4831 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4832 }
\DoxyCodeLine{4833     \textcolor{keyword}{struct }\mbox{\hyperlink{struct_catch_1_1_i_runner}{IRunner}} \{}
\DoxyCodeLine{4834         \textcolor{keyword}{virtual} \mbox{\hyperlink{struct_catch_1_1_i_runner}{\string~IRunner}}();}
\DoxyCodeLine{4835         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} aborting() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{4836     \};}
\DoxyCodeLine{4837 \}}
\DoxyCodeLine{4838 }
\DoxyCodeLine{4839 \textcolor{comment}{// end catch\_interfaces\_runner.h}}
\DoxyCodeLine{4840 }
\DoxyCodeLine{4841 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{4842 \textcolor{comment}{// start catch\_objc.hpp}}
\DoxyCodeLine{4843 }
\DoxyCodeLine{4844 \textcolor{preprocessor}{\#import <objc/runtime.h>}}
\DoxyCodeLine{4845 }
\DoxyCodeLine{4846 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{4847 }
\DoxyCodeLine{4848 \textcolor{comment}{// NB. Any general catch headers included here must be included}}
\DoxyCodeLine{4849 \textcolor{comment}{// in catch.hpp first to make sure they are included by the single}}
\DoxyCodeLine{4850 \textcolor{comment}{// header for non obj-\/usage}}
\DoxyCodeLine{4851 }
\DoxyCodeLine{4853 \textcolor{comment}{// This protocol is really only here for (self) documenting purposes, since}}
\DoxyCodeLine{4854 \textcolor{comment}{// all its methods are optional.}}
\DoxyCodeLine{4855 \textcolor{keyword}{@protocol }OcFixture}
\DoxyCodeLine{4856 }
\DoxyCodeLine{4857 \textcolor{keyword}{@optional}}
\DoxyCodeLine{4858 }
\DoxyCodeLine{4859 -\/(void) setUp;}
\DoxyCodeLine{4860 -\/(void) tearDown;}
\DoxyCodeLine{4861 }
\DoxyCodeLine{4862 \textcolor{keyword}{@end}}
\DoxyCodeLine{4863 }
\DoxyCodeLine{4864 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{4865 }
\DoxyCodeLine{4866     \textcolor{keyword}{class }OcMethod : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{4867 }
\DoxyCodeLine{4868     \textcolor{keyword}{public}:}
\DoxyCodeLine{4869         OcMethod( Class cls, \textcolor{keywordtype}{SEL} sel ) : m\_cls( cls ), m\_sel( sel ) \{\}}
\DoxyCodeLine{4870 }
\DoxyCodeLine{4871         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{4872             \textcolor{keywordtype}{id} obj = [[m\_cls alloc] init];}
\DoxyCodeLine{4873 }
\DoxyCodeLine{4874             performOptionalSelector( obj, \textcolor{keyword}{@selector}(setUp)  );}
\DoxyCodeLine{4875             performOptionalSelector( obj, m\_sel );}
\DoxyCodeLine{4876             performOptionalSelector( obj, \textcolor{keyword}{@selector}(tearDown)  );}
\DoxyCodeLine{4877 }
\DoxyCodeLine{4878             arcSafeRelease( obj );}
\DoxyCodeLine{4879         \}}
\DoxyCodeLine{4880     \textcolor{keyword}{private}:}
\DoxyCodeLine{4881         \textcolor{keyword}{virtual} \string~OcMethod() \{\}}
\DoxyCodeLine{4882 }
\DoxyCodeLine{4883         Class m\_cls;}
\DoxyCodeLine{4884         \textcolor{keywordtype}{SEL} m\_sel;}
\DoxyCodeLine{4885     \};}
\DoxyCodeLine{4886 }
\DoxyCodeLine{4887     \textcolor{keyword}{namespace }Detail\{}
\DoxyCodeLine{4888 }
\DoxyCodeLine{4889         \textcolor{keyword}{inline} std::string getAnnotation(   Class cls,}
\DoxyCodeLine{4890                                             std::string \textcolor{keyword}{const}\& annotationName,}
\DoxyCodeLine{4891                                             std::string \textcolor{keyword}{const}\& testCaseName ) \{}
\DoxyCodeLine{4892             NSString* selStr = [[NSString alloc] initWithFormat:@"{}Catch\_\%s\_\%s"{}, annotationName.c\_str(), testCaseName.c\_str()];}
\DoxyCodeLine{4893             \textcolor{keywordtype}{SEL} sel = NSSelectorFromString( selStr );}
\DoxyCodeLine{4894             arcSafeRelease( selStr );}
\DoxyCodeLine{4895             \textcolor{keywordtype}{id} value = performOptionalSelector( cls, sel );}
\DoxyCodeLine{4896             \textcolor{keywordflow}{if}( value )}
\DoxyCodeLine{4897                 \textcolor{keywordflow}{return} [(NSString*)value UTF8String];}
\DoxyCodeLine{4898             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{4899         \}}
\DoxyCodeLine{4900     \}}
\DoxyCodeLine{4901 }
\DoxyCodeLine{4902     \textcolor{keyword}{inline} std::size\_t registerTestMethods() \{}
\DoxyCodeLine{4903         std::size\_t noTestMethods = 0;}
\DoxyCodeLine{4904         \textcolor{keywordtype}{int} noClasses = objc\_getClassList( \textcolor{keyword}{nullptr}, 0 );}
\DoxyCodeLine{4905 }
\DoxyCodeLine{4906         Class* classes = (CATCH\_UNSAFE\_UNRETAINED Class *)malloc( \textcolor{keyword}{sizeof}(Class) * noClasses);}
\DoxyCodeLine{4907         objc\_getClassList( classes, noClasses );}
\DoxyCodeLine{4908 }
\DoxyCodeLine{4909         \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} c = 0; c < noClasses; c++ ) \{}
\DoxyCodeLine{4910             Class cls = classes[c];}
\DoxyCodeLine{4911             \{}
\DoxyCodeLine{4912                 u\_int count;}
\DoxyCodeLine{4913                 Method* methods = class\_copyMethodList( cls, \&count );}
\DoxyCodeLine{4914                 \textcolor{keywordflow}{for}( u\_int m = 0; m < count ; m++ ) \{}
\DoxyCodeLine{4915                     \textcolor{keywordtype}{SEL} selector = method\_getName(methods[m]);}
\DoxyCodeLine{4916                     std::string methodName = sel\_getName(selector);}
\DoxyCodeLine{4917                     \textcolor{keywordflow}{if}( startsWith( methodName, \textcolor{stringliteral}{"{}Catch\_TestCase\_"{}} ) ) \{}
\DoxyCodeLine{4918                         std::string testCaseName = methodName.substr( 15 );}
\DoxyCodeLine{4919                         std::string name = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Name"{}}, testCaseName );}
\DoxyCodeLine{4920                         std::string desc = Detail::getAnnotation( cls, \textcolor{stringliteral}{"{}Description"{}}, testCaseName );}
\DoxyCodeLine{4921                         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* className = class\_getName( cls );}
\DoxyCodeLine{4922 }
\DoxyCodeLine{4923                         getMutableRegistryHub().registerTest( makeTestCase( \textcolor{keyword}{new} OcMethod( cls, selector ), className, NameAndTags( name.c\_str(), desc.c\_str() ), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0) ) );}
\DoxyCodeLine{4924                         noTestMethods++;}
\DoxyCodeLine{4925                     \}}
\DoxyCodeLine{4926                 \}}
\DoxyCodeLine{4927                 free(methods);}
\DoxyCodeLine{4928             \}}
\DoxyCodeLine{4929         \}}
\DoxyCodeLine{4930         \textcolor{keywordflow}{return} noTestMethods;}
\DoxyCodeLine{4931     \}}
\DoxyCodeLine{4932 }
\DoxyCodeLine{4933 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{4934 }
\DoxyCodeLine{4935     \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{4936         \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{4937         \textcolor{keyword}{namespace }NSStringMatchers \{}
\DoxyCodeLine{4938 }
\DoxyCodeLine{4939             \textcolor{keyword}{struct }StringHolder : MatcherBase<NSString*>\{}
\DoxyCodeLine{4940                 StringHolder( NSString* substr ) : m\_substr( [substr copy] )\{\}}
\DoxyCodeLine{4941                 StringHolder( StringHolder \textcolor{keyword}{const}\& other ) : m\_substr( [other.m\_substr copy] )\{\}}
\DoxyCodeLine{4942                 StringHolder() \{}
\DoxyCodeLine{4943                     arcSafeRelease( m\_substr );}
\DoxyCodeLine{4944                 \}}
\DoxyCodeLine{4945 }
\DoxyCodeLine{4946                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4947                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{4948                 \}}
\DoxyCodeLine{4949 }
\DoxyCodeLine{4950                 NSString* CATCH\_ARC\_STRONG m\_substr;}
\DoxyCodeLine{4951             \};}
\DoxyCodeLine{4952 }
\DoxyCodeLine{4953             \textcolor{keyword}{struct }Equals : StringHolder \{}
\DoxyCodeLine{4954                 Equals( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4955 }
\DoxyCodeLine{4956                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4957                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4958                             [str isEqualToString:m\_substr];}
\DoxyCodeLine{4959                 \}}
\DoxyCodeLine{4960 }
\DoxyCodeLine{4961                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4962                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}equals string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4963                 \}}
\DoxyCodeLine{4964             \};}
\DoxyCodeLine{4965 }
\DoxyCodeLine{4966             \textcolor{keyword}{struct }Contains : StringHolder \{}
\DoxyCodeLine{4967                 Contains( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4968 }
\DoxyCodeLine{4969                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4970                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4971                             [str rangeOfString:m\_substr].location != NSNotFound;}
\DoxyCodeLine{4972                 \}}
\DoxyCodeLine{4973 }
\DoxyCodeLine{4974                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4975                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}contains string: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4976                 \}}
\DoxyCodeLine{4977             \};}
\DoxyCodeLine{4978 }
\DoxyCodeLine{4979             \textcolor{keyword}{struct }StartsWith : StringHolder \{}
\DoxyCodeLine{4980                 StartsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4981 }
\DoxyCodeLine{4982                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4983                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4984                             [str rangeOfString:m\_substr].location == 0;}
\DoxyCodeLine{4985                 \}}
\DoxyCodeLine{4986 }
\DoxyCodeLine{4987                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4988                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}starts with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{4989                 \}}
\DoxyCodeLine{4990             \};}
\DoxyCodeLine{4991             \textcolor{keyword}{struct }EndsWith : StringHolder \{}
\DoxyCodeLine{4992                 EndsWith( NSString* substr ) : StringHolder( substr )\{\}}
\DoxyCodeLine{4993 }
\DoxyCodeLine{4994                 \textcolor{keywordtype}{bool} match( NSString* str )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{4995                     \textcolor{keywordflow}{return}  (str != nil || m\_substr == nil ) \&\&}
\DoxyCodeLine{4996                             [str rangeOfString:m\_substr].location == [str length] -\/ [m\_substr length];}
\DoxyCodeLine{4997                 \}}
\DoxyCodeLine{4998 }
\DoxyCodeLine{4999                 std::string describe()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5000                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ends with: "{}} + Catch::Detail::stringify( m\_substr );}
\DoxyCodeLine{5001                 \}}
\DoxyCodeLine{5002             \};}
\DoxyCodeLine{5003 }
\DoxyCodeLine{5004         \} \textcolor{comment}{// namespace NSStringMatchers}}
\DoxyCodeLine{5005         \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{5006 }
\DoxyCodeLine{5007         \textcolor{keyword}{inline} Impl::NSStringMatchers::Equals}
\DoxyCodeLine{5008             Equals( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Equals( substr ); \}}
\DoxyCodeLine{5009 }
\DoxyCodeLine{5010         \textcolor{keyword}{inline} Impl::NSStringMatchers::Contains}
\DoxyCodeLine{5011             Contains( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::Contains( substr ); \}}
\DoxyCodeLine{5012 }
\DoxyCodeLine{5013         \textcolor{keyword}{inline} Impl::NSStringMatchers::StartsWith}
\DoxyCodeLine{5014             StartsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::StartsWith( substr ); \}}
\DoxyCodeLine{5015 }
\DoxyCodeLine{5016         \textcolor{keyword}{inline} Impl::NSStringMatchers::EndsWith}
\DoxyCodeLine{5017             EndsWith( NSString* substr )\{ \textcolor{keywordflow}{return} Impl::NSStringMatchers::EndsWith( substr ); \}}
\DoxyCodeLine{5018 }
\DoxyCodeLine{5019     \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{5020 }
\DoxyCodeLine{5021     \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{5022 }
\DoxyCodeLine{5023 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{5024 }
\DoxyCodeLine{5025 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5026 }
\DoxyCodeLine{5028 \textcolor{preprocessor}{\#define OC\_MAKE\_UNIQUE\_NAME( root, uniqueSuffix ) root\#\#uniqueSuffix}}
\DoxyCodeLine{5029 \textcolor{preprocessor}{\#define OC\_TEST\_CASE2( name, desc, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5030 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Name\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5031 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5032 \textcolor{preprocessor}{return @ name; \(\backslash\)}}
\DoxyCodeLine{5033 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5034 \textcolor{preprocessor}{+(NSString*) OC\_MAKE\_UNIQUE\_NAME( Catch\_Description\_test\_, uniqueSuffix ) \(\backslash\)}}
\DoxyCodeLine{5035 \textcolor{preprocessor}{\{ \(\backslash\)}}
\DoxyCodeLine{5036 \textcolor{preprocessor}{return @ desc; \(\backslash\)}}
\DoxyCodeLine{5037 \textcolor{preprocessor}{\} \(\backslash\)}}
\DoxyCodeLine{5038 \textcolor{preprocessor}{-\/(void) OC\_MAKE\_UNIQUE\_NAME( Catch\_TestCase\_test\_, uniqueSuffix )}}
\DoxyCodeLine{5039 }
\DoxyCodeLine{5040 \textcolor{preprocessor}{\#define OC\_TEST\_CASE( name, desc ) OC\_TEST\_CASE2( name, desc, \_\_LINE\_\_ )}}
\DoxyCodeLine{5041 }
\DoxyCodeLine{5042 \textcolor{comment}{// end catch\_objc.hpp}}
\DoxyCodeLine{5043 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5044 }
\DoxyCodeLine{5045 \textcolor{comment}{// Benchmarking needs the externally-\/facing parts of reporters to work}}
\DoxyCodeLine{5046 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_EXTERNAL\_INTERFACES) || defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5047 \textcolor{comment}{// start catch\_external\_interfaces.h}}
\DoxyCodeLine{5048 }
\DoxyCodeLine{5049 \textcolor{comment}{// start catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5050 }
\DoxyCodeLine{5051 \textcolor{comment}{// start catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5052 }
\DoxyCodeLine{5053 \textcolor{comment}{// start catch\_config.hpp}}
\DoxyCodeLine{5054 }
\DoxyCodeLine{5055 \textcolor{comment}{// start catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5056 }
\DoxyCodeLine{5057 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5058 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5059 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5060 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5061 }
\DoxyCodeLine{5062 \textcolor{comment}{// start catch\_test\_spec.h}}
\DoxyCodeLine{5063 }
\DoxyCodeLine{5064 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5065 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{5066 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wpadded"{}}}
\DoxyCodeLine{5067 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5068 }
\DoxyCodeLine{5069 \textcolor{comment}{// start catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5070 }
\DoxyCodeLine{5071 \textcolor{keyword}{namespace }Catch}
\DoxyCodeLine{5072 \{}
\DoxyCodeLine{5073     \textcolor{keyword}{class }WildcardPattern \{}
\DoxyCodeLine{5074         \textcolor{keyword}{enum} WildcardPosition \{}
\DoxyCodeLine{5075             NoWildcard = 0,}
\DoxyCodeLine{5076             WildcardAtStart = 1,}
\DoxyCodeLine{5077             WildcardAtEnd = 2,}
\DoxyCodeLine{5078             WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd}
\DoxyCodeLine{5079         \};}
\DoxyCodeLine{5080 }
\DoxyCodeLine{5081     \textcolor{keyword}{public}:}
\DoxyCodeLine{5082 }
\DoxyCodeLine{5083         WildcardPattern( std::string \textcolor{keyword}{const}\& pattern, CaseSensitive::Choice caseSensitivity );}
\DoxyCodeLine{5084         \textcolor{keyword}{virtual} \string~WildcardPattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5085         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5086 }
\DoxyCodeLine{5087     \textcolor{keyword}{private}:}
\DoxyCodeLine{5088         std::string normaliseString( std::string \textcolor{keyword}{const}\& str ) \textcolor{keyword}{const};}
\DoxyCodeLine{5089         CaseSensitive::Choice m\_caseSensitivity;}
\DoxyCodeLine{5090         WildcardPosition m\_wildcard = NoWildcard;}
\DoxyCodeLine{5091         std::string m\_pattern;}
\DoxyCodeLine{5092     \};}
\DoxyCodeLine{5093 \}}
\DoxyCodeLine{5094 }
\DoxyCodeLine{5095 \textcolor{comment}{// end catch\_wildcard\_pattern.h}}
\DoxyCodeLine{5096 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5097 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5098 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5099 }
\DoxyCodeLine{5100 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5101 }
\DoxyCodeLine{5102     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{5103 }
\DoxyCodeLine{5104     \textcolor{keyword}{class }TestSpec \{}
\DoxyCodeLine{5105         \textcolor{keyword}{class }Pattern \{}
\DoxyCodeLine{5106         \textcolor{keyword}{public}:}
\DoxyCodeLine{5107             \textcolor{keyword}{explicit} Pattern( std::string \textcolor{keyword}{const}\& name );}
\DoxyCodeLine{5108             \textcolor{keyword}{virtual} \string~Pattern();}
\DoxyCodeLine{5109             \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5110             std::string \textcolor{keyword}{const}\& name() \textcolor{keyword}{const};}
\DoxyCodeLine{5111         \textcolor{keyword}{private}:}
\DoxyCodeLine{5112             std::string \textcolor{keyword}{const} m\_name;}
\DoxyCodeLine{5113         \};}
\DoxyCodeLine{5114         \textcolor{keyword}{using} PatternPtr = std::shared\_ptr<Pattern>;}
\DoxyCodeLine{5115 }
\DoxyCodeLine{5116         \textcolor{keyword}{class }NamePattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5117         \textcolor{keyword}{public}:}
\DoxyCodeLine{5118             \textcolor{keyword}{explicit} NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5119             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5120         \textcolor{keyword}{private}:}
\DoxyCodeLine{5121             WildcardPattern m\_wildcardPattern;}
\DoxyCodeLine{5122         \};}
\DoxyCodeLine{5123 }
\DoxyCodeLine{5124         \textcolor{keyword}{class }TagPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5125         \textcolor{keyword}{public}:}
\DoxyCodeLine{5126             \textcolor{keyword}{explicit} TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString );}
\DoxyCodeLine{5127             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5128         \textcolor{keyword}{private}:}
\DoxyCodeLine{5129             std::string m\_tag;}
\DoxyCodeLine{5130         \};}
\DoxyCodeLine{5131 }
\DoxyCodeLine{5132         \textcolor{keyword}{class }ExcludedPattern : \textcolor{keyword}{public} Pattern \{}
\DoxyCodeLine{5133         \textcolor{keyword}{public}:}
\DoxyCodeLine{5134             \textcolor{keyword}{explicit} ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern );}
\DoxyCodeLine{5135             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const override};}
\DoxyCodeLine{5136         \textcolor{keyword}{private}:}
\DoxyCodeLine{5137             PatternPtr m\_underlyingPattern;}
\DoxyCodeLine{5138         \};}
\DoxyCodeLine{5139 }
\DoxyCodeLine{5140         \textcolor{keyword}{struct }Filter \{}
\DoxyCodeLine{5141             std::vector<PatternPtr> m\_patterns;}
\DoxyCodeLine{5142 }
\DoxyCodeLine{5143             \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5144             std::string name() \textcolor{keyword}{const};}
\DoxyCodeLine{5145         \};}
\DoxyCodeLine{5146 }
\DoxyCodeLine{5147     \textcolor{keyword}{public}:}
\DoxyCodeLine{5148         \textcolor{keyword}{struct }FilterMatch \{}
\DoxyCodeLine{5149             std::string name;}
\DoxyCodeLine{5150             std::vector<TestCase const*> tests;}
\DoxyCodeLine{5151         \};}
\DoxyCodeLine{5152         \textcolor{keyword}{using} Matches = std::vector<FilterMatch>;}
\DoxyCodeLine{5153         \textcolor{keyword}{using} vectorStrings = std::vector<std::string>;}
\DoxyCodeLine{5154 }
\DoxyCodeLine{5155         \textcolor{keywordtype}{bool} hasFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{5156         \textcolor{keywordtype}{bool} matches( TestCaseInfo \textcolor{keyword}{const}\& testCase ) \textcolor{keyword}{const};}
\DoxyCodeLine{5157         Matches matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const};}
\DoxyCodeLine{5158         \textcolor{keyword}{const} vectorStrings \& getInvalidArgs() \textcolor{keyword}{const};}
\DoxyCodeLine{5159 }
\DoxyCodeLine{5160     \textcolor{keyword}{private}:}
\DoxyCodeLine{5161         std::vector<Filter> m\_filters;}
\DoxyCodeLine{5162         std::vector<std::string> m\_invalidArgs;}
\DoxyCodeLine{5163         \textcolor{keyword}{friend} \textcolor{keyword}{class }TestSpecParser;}
\DoxyCodeLine{5164     \};}
\DoxyCodeLine{5165 \}}
\DoxyCodeLine{5166 }
\DoxyCodeLine{5167 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5168 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5169 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5170 }
\DoxyCodeLine{5171 \textcolor{comment}{// end catch\_test\_spec.h}}
\DoxyCodeLine{5172 \textcolor{comment}{// start catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5173 }
\DoxyCodeLine{5174 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5175 }
\DoxyCodeLine{5176 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5177 }
\DoxyCodeLine{5178     \textcolor{keyword}{struct }TagAlias;}
\DoxyCodeLine{5179 }
\DoxyCodeLine{5180     \textcolor{keyword}{struct }ITagAliasRegistry \{}
\DoxyCodeLine{5181         \textcolor{keyword}{virtual} \string~ITagAliasRegistry();}
\DoxyCodeLine{5182         \textcolor{comment}{// Nullptr if not present}}
\DoxyCodeLine{5183         \textcolor{keyword}{virtual} TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5184         \textcolor{keyword}{virtual} std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5185 }
\DoxyCodeLine{5186         \textcolor{keyword}{static} ITagAliasRegistry \textcolor{keyword}{const}\& get();}
\DoxyCodeLine{5187     \};}
\DoxyCodeLine{5188 }
\DoxyCodeLine{5189 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5190 }
\DoxyCodeLine{5191 \textcolor{comment}{// end catch\_interfaces\_tag\_alias\_registry.h}}
\DoxyCodeLine{5192 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5193 }
\DoxyCodeLine{5194     \textcolor{keyword}{class }TestSpecParser \{}
\DoxyCodeLine{5195         \textcolor{keyword}{enum} Mode\{ None, Name, QuotedName, Tag, EscapedName \};}
\DoxyCodeLine{5196         Mode m\_mode = None;}
\DoxyCodeLine{5197         Mode lastMode = None;}
\DoxyCodeLine{5198         \textcolor{keywordtype}{bool} m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{5199         std::size\_t m\_pos = 0;}
\DoxyCodeLine{5200         std::size\_t m\_realPatternPos = 0;}
\DoxyCodeLine{5201         std::string m\_arg;}
\DoxyCodeLine{5202         std::string m\_substring;}
\DoxyCodeLine{5203         std::string m\_patternName;}
\DoxyCodeLine{5204         std::vector<std::size\_t> m\_escapeChars;}
\DoxyCodeLine{5205         TestSpec::Filter m\_currentFilter;}
\DoxyCodeLine{5206         TestSpec m\_testSpec;}
\DoxyCodeLine{5207         ITagAliasRegistry \textcolor{keyword}{const}* m\_tagAliases = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{5208 }
\DoxyCodeLine{5209     \textcolor{keyword}{public}:}
\DoxyCodeLine{5210         TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases );}
\DoxyCodeLine{5211 }
\DoxyCodeLine{5212         TestSpecParser\& parse( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5213         TestSpec testSpec();}
\DoxyCodeLine{5214 }
\DoxyCodeLine{5215     \textcolor{keyword}{private}:}
\DoxyCodeLine{5216         \textcolor{keywordtype}{bool} visitChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5217         \textcolor{keywordtype}{void} startNewMode( Mode mode );}
\DoxyCodeLine{5218         \textcolor{keywordtype}{bool} processNoneChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5219         \textcolor{keywordtype}{void} processNameChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5220         \textcolor{keywordtype}{bool} processOtherChar( \textcolor{keywordtype}{char} c );}
\DoxyCodeLine{5221         \textcolor{keywordtype}{void} endMode();}
\DoxyCodeLine{5222         \textcolor{keywordtype}{void} escape();}
\DoxyCodeLine{5223         \textcolor{keywordtype}{bool} isControlChar( \textcolor{keywordtype}{char} c ) \textcolor{keyword}{const};}
\DoxyCodeLine{5224         \textcolor{keywordtype}{void} saveLastMode();}
\DoxyCodeLine{5225         \textcolor{keywordtype}{void} revertBackToLastMode();}
\DoxyCodeLine{5226         \textcolor{keywordtype}{void} addFilter();}
\DoxyCodeLine{5227         \textcolor{keywordtype}{bool} separate();}
\DoxyCodeLine{5228 }
\DoxyCodeLine{5229         \textcolor{comment}{// Handles common preprocessing of the pattern for name/tag patterns}}
\DoxyCodeLine{5230         std::string preprocessPattern();}
\DoxyCodeLine{5231         \textcolor{comment}{// Adds the current pattern as a test name}}
\DoxyCodeLine{5232         \textcolor{keywordtype}{void} addNamePattern();}
\DoxyCodeLine{5233         \textcolor{comment}{// Adds the current pattern as a tag}}
\DoxyCodeLine{5234         \textcolor{keywordtype}{void} addTagPattern();}
\DoxyCodeLine{5235 }
\DoxyCodeLine{5236         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} addCharToPattern(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{5237             m\_substring += c;}
\DoxyCodeLine{5238             m\_patternName += c;}
\DoxyCodeLine{5239             m\_realPatternPos++;}
\DoxyCodeLine{5240         \}}
\DoxyCodeLine{5241 }
\DoxyCodeLine{5242     \};}
\DoxyCodeLine{5243     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg );}
\DoxyCodeLine{5244 }
\DoxyCodeLine{5245 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5246 }
\DoxyCodeLine{5247 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{5248 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{5249 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5250 }
\DoxyCodeLine{5251 \textcolor{comment}{// end catch\_test\_spec\_parser.h}}
\DoxyCodeLine{5252 \textcolor{comment}{// Libstdc++ doesn't like incomplete classes for unique\_ptr}}
\DoxyCodeLine{5253 }
\DoxyCodeLine{5254 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5255 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{5256 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5257 }
\DoxyCodeLine{5258 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{5259 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{5260 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5261 }
\DoxyCodeLine{5262 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5263 }
\DoxyCodeLine{5264     \textcolor{keyword}{struct }IStream;}
\DoxyCodeLine{5265 }
\DoxyCodeLine{5266     \textcolor{keyword}{struct }ConfigData \{}
\DoxyCodeLine{5267         \textcolor{keywordtype}{bool} listTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5268         \textcolor{keywordtype}{bool} listTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5269         \textcolor{keywordtype}{bool} listReporters = \textcolor{keyword}{false};}
\DoxyCodeLine{5270         \textcolor{keywordtype}{bool} listTestNamesOnly = \textcolor{keyword}{false};}
\DoxyCodeLine{5271 }
\DoxyCodeLine{5272         \textcolor{keywordtype}{bool} showSuccessfulTests = \textcolor{keyword}{false};}
\DoxyCodeLine{5273         \textcolor{keywordtype}{bool} shouldDebugBreak = \textcolor{keyword}{false};}
\DoxyCodeLine{5274         \textcolor{keywordtype}{bool} noThrow = \textcolor{keyword}{false};}
\DoxyCodeLine{5275         \textcolor{keywordtype}{bool} showHelp = \textcolor{keyword}{false};}
\DoxyCodeLine{5276         \textcolor{keywordtype}{bool} showInvisibles = \textcolor{keyword}{false};}
\DoxyCodeLine{5277         \textcolor{keywordtype}{bool} filenamesAsTags = \textcolor{keyword}{false};}
\DoxyCodeLine{5278         \textcolor{keywordtype}{bool} libIdentify = \textcolor{keyword}{false};}
\DoxyCodeLine{5279 }
\DoxyCodeLine{5280         \textcolor{keywordtype}{int} abortAfter = -\/1;}
\DoxyCodeLine{5281         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed = 0;}
\DoxyCodeLine{5282 }
\DoxyCodeLine{5283         \textcolor{keywordtype}{bool} benchmarkNoAnalysis = \textcolor{keyword}{false};}
\DoxyCodeLine{5284         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkSamples = 100;}
\DoxyCodeLine{5285         \textcolor{keywordtype}{double} benchmarkConfidenceInterval = 0.95;}
\DoxyCodeLine{5286         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples = 100000;}
\DoxyCodeLine{5287         std::chrono::milliseconds::rep benchmarkWarmupTime = 100;}
\DoxyCodeLine{5288 }
\DoxyCodeLine{5289         Verbosity verbosity = Verbosity::Normal;}
\DoxyCodeLine{5290         WarnAbout::What warnings = WarnAbout::Nothing;}
\DoxyCodeLine{5291         ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;}
\DoxyCodeLine{5292         \textcolor{keywordtype}{double} minDuration = -\/1;}
\DoxyCodeLine{5293         RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{5294         UseColour::YesOrNo useColour = UseColour::Auto;}
\DoxyCodeLine{5295         WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{5296 }
\DoxyCodeLine{5297         std::string outputFilename;}
\DoxyCodeLine{5298         std::string name;}
\DoxyCodeLine{5299         std::string processName;}
\DoxyCodeLine{5300 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5301 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_DEFAULT\_REPORTER "{}console"{}}}
\DoxyCodeLine{5302 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{5303         std::string reporterName = CATCH\_CONFIG\_DEFAULT\_REPORTER;}
\DoxyCodeLine{5304 \textcolor{preprocessor}{\#undef CATCH\_CONFIG\_DEFAULT\_REPORTER}}
\DoxyCodeLine{5305 }
\DoxyCodeLine{5306         std::vector<std::string> testsOrTags;}
\DoxyCodeLine{5307         std::vector<std::string> sectionsToRun;}
\DoxyCodeLine{5308     \};}
\DoxyCodeLine{5309 }
\DoxyCodeLine{5310     \textcolor{keyword}{class }Config : \textcolor{keyword}{public} IConfig \{}
\DoxyCodeLine{5311     \textcolor{keyword}{public}:}
\DoxyCodeLine{5312 }
\DoxyCodeLine{5313         Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5314         Config( ConfigData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5315         \textcolor{keyword}{virtual} \string~Config() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5316 }
\DoxyCodeLine{5317         std::string \textcolor{keyword}{const}\& getFilename() \textcolor{keyword}{const};}
\DoxyCodeLine{5318 }
\DoxyCodeLine{5319         \textcolor{keywordtype}{bool} listTests() \textcolor{keyword}{const};}
\DoxyCodeLine{5320         \textcolor{keywordtype}{bool} listTestNamesOnly() \textcolor{keyword}{const};}
\DoxyCodeLine{5321         \textcolor{keywordtype}{bool} listTags() \textcolor{keyword}{const};}
\DoxyCodeLine{5322         \textcolor{keywordtype}{bool} listReporters() \textcolor{keyword}{const};}
\DoxyCodeLine{5323 }
\DoxyCodeLine{5324         std::string getProcessName() \textcolor{keyword}{const};}
\DoxyCodeLine{5325         std::string \textcolor{keyword}{const}\& getReporterName() \textcolor{keyword}{const};}
\DoxyCodeLine{5326 }
\DoxyCodeLine{5327         std::vector<std::string> \textcolor{keyword}{const}\& getTestsOrTags() \textcolor{keyword}{const override};}
\DoxyCodeLine{5328         std::vector<std::string> \textcolor{keyword}{const}\& getSectionsToRun() \textcolor{keyword}{const override};}
\DoxyCodeLine{5329 }
\DoxyCodeLine{5330         TestSpec \textcolor{keyword}{const}\& testSpec() \textcolor{keyword}{const override};}
\DoxyCodeLine{5331         \textcolor{keywordtype}{bool} hasTestFilters() \textcolor{keyword}{const override};}
\DoxyCodeLine{5332 }
\DoxyCodeLine{5333         \textcolor{keywordtype}{bool} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{5334 }
\DoxyCodeLine{5335         \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{5336         \textcolor{keywordtype}{bool} allowThrows() \textcolor{keyword}{const override};}
\DoxyCodeLine{5337         std::ostream\& stream() \textcolor{keyword}{const override};}
\DoxyCodeLine{5338         std::string name() \textcolor{keyword}{const override};}
\DoxyCodeLine{5339         \textcolor{keywordtype}{bool} includeSuccessfulResults() \textcolor{keyword}{const override};}
\DoxyCodeLine{5340         \textcolor{keywordtype}{bool} warnAboutMissingAssertions() \textcolor{keyword}{const override};}
\DoxyCodeLine{5341         \textcolor{keywordtype}{bool} warnAboutNoTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{5342         ShowDurations::OrNot showDurations() \textcolor{keyword}{const override};}
\DoxyCodeLine{5343         \textcolor{keywordtype}{double} minDuration() \textcolor{keyword}{const override};}
\DoxyCodeLine{5344         RunTests::InWhatOrder runOrder() \textcolor{keyword}{const override};}
\DoxyCodeLine{5345         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \textcolor{keyword}{const override};}
\DoxyCodeLine{5346         UseColour::YesOrNo useColour() \textcolor{keyword}{const override};}
\DoxyCodeLine{5347         \textcolor{keywordtype}{bool} shouldDebugBreak() \textcolor{keyword}{const override};}
\DoxyCodeLine{5348         \textcolor{keywordtype}{int} abortAfter() \textcolor{keyword}{const override};}
\DoxyCodeLine{5349         \textcolor{keywordtype}{bool} showInvisibles() \textcolor{keyword}{const override};}
\DoxyCodeLine{5350         Verbosity verbosity() \textcolor{keyword}{const override};}
\DoxyCodeLine{5351         \textcolor{keywordtype}{bool} benchmarkNoAnalysis() \textcolor{keyword}{const override};}
\DoxyCodeLine{5352         \textcolor{keywordtype}{int} benchmarkSamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5353         \textcolor{keywordtype}{double} benchmarkConfidenceInterval() \textcolor{keyword}{const override};}
\DoxyCodeLine{5354         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} benchmarkResamples() \textcolor{keyword}{const override};}
\DoxyCodeLine{5355         std::chrono::milliseconds benchmarkWarmupTime() \textcolor{keyword}{const override};}
\DoxyCodeLine{5356 }
\DoxyCodeLine{5357     \textcolor{keyword}{private}:}
\DoxyCodeLine{5358 }
\DoxyCodeLine{5359         IStream \textcolor{keyword}{const}* openStream();}
\DoxyCodeLine{5360         ConfigData m\_data;}
\DoxyCodeLine{5361 }
\DoxyCodeLine{5362         std::unique\_ptr<IStream const> m\_stream;}
\DoxyCodeLine{5363         TestSpec m\_testSpec;}
\DoxyCodeLine{5364         \textcolor{keywordtype}{bool} m\_hasTestFilters = \textcolor{keyword}{false};}
\DoxyCodeLine{5365     \};}
\DoxyCodeLine{5366 }
\DoxyCodeLine{5367 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5368 }
\DoxyCodeLine{5369 \textcolor{comment}{// end catch\_config.hpp}}
\DoxyCodeLine{5370 \textcolor{comment}{// start catch\_assertionresult.h}}
\DoxyCodeLine{5371 }
\DoxyCodeLine{5372 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5373 }
\DoxyCodeLine{5374 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5375 }
\DoxyCodeLine{5376     \textcolor{keyword}{struct }AssertionResultData}
\DoxyCodeLine{5377     \{}
\DoxyCodeLine{5378         AssertionResultData() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5379 }
\DoxyCodeLine{5380         AssertionResultData( ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const}\& \_lazyExpression );}
\DoxyCodeLine{5381 }
\DoxyCodeLine{5382         std::string message;}
\DoxyCodeLine{5383         \textcolor{keyword}{mutable} std::string reconstructedExpression;}
\DoxyCodeLine{5384         LazyExpression lazyExpression;}
\DoxyCodeLine{5385         ResultWas::OfType resultType;}
\DoxyCodeLine{5386 }
\DoxyCodeLine{5387         std::string reconstructExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5388     \};}
\DoxyCodeLine{5389 }
\DoxyCodeLine{5390     \textcolor{keyword}{class }AssertionResult \{}
\DoxyCodeLine{5391     \textcolor{keyword}{public}:}
\DoxyCodeLine{5392         AssertionResult() = \textcolor{keyword}{delete};}
\DoxyCodeLine{5393         AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data );}
\DoxyCodeLine{5394 }
\DoxyCodeLine{5395         \textcolor{keywordtype}{bool} isOk() \textcolor{keyword}{const};}
\DoxyCodeLine{5396         \textcolor{keywordtype}{bool} succeeded() \textcolor{keyword}{const};}
\DoxyCodeLine{5397         ResultWas::OfType getResultType() \textcolor{keyword}{const};}
\DoxyCodeLine{5398         \textcolor{keywordtype}{bool} hasExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5399         \textcolor{keywordtype}{bool} hasMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5400         std::string getExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5401         std::string getExpressionInMacro() \textcolor{keyword}{const};}
\DoxyCodeLine{5402         \textcolor{keywordtype}{bool} hasExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5403         std::string getExpandedExpression() \textcolor{keyword}{const};}
\DoxyCodeLine{5404         std::string getMessage() \textcolor{keyword}{const};}
\DoxyCodeLine{5405         SourceLineInfo getSourceInfo() \textcolor{keyword}{const};}
\DoxyCodeLine{5406         StringRef getTestMacroName() \textcolor{keyword}{const};}
\DoxyCodeLine{5407 }
\DoxyCodeLine{5408     \textcolor{comment}{//protected:}}
\DoxyCodeLine{5409         AssertionInfo m\_info;}
\DoxyCodeLine{5410         AssertionResultData m\_resultData;}
\DoxyCodeLine{5411     \};}
\DoxyCodeLine{5412 }
\DoxyCodeLine{5413 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5414 }
\DoxyCodeLine{5415 \textcolor{comment}{// end catch\_assertionresult.h}}
\DoxyCodeLine{5416 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5417 \textcolor{comment}{// start catch\_estimate.hpp}}
\DoxyCodeLine{5418 }
\DoxyCodeLine{5419  \textcolor{comment}{// Statistics estimates}}
\DoxyCodeLine{5420 }
\DoxyCodeLine{5421 }
\DoxyCodeLine{5422 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5423     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5424         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{5425         \textcolor{keyword}{struct }Estimate \{}
\DoxyCodeLine{5426             Duration point;}
\DoxyCodeLine{5427             Duration lower\_bound;}
\DoxyCodeLine{5428             Duration upper\_bound;}
\DoxyCodeLine{5429             \textcolor{keywordtype}{double} confidence\_interval;}
\DoxyCodeLine{5430 }
\DoxyCodeLine{5431             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5432             \textcolor{keyword}{operator} Estimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5433                 \textcolor{keywordflow}{return} \{ point, lower\_bound, upper\_bound, confidence\_interval \};}
\DoxyCodeLine{5434             \}}
\DoxyCodeLine{5435         \};}
\DoxyCodeLine{5436     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5437 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5438 }
\DoxyCodeLine{5439 \textcolor{comment}{// end catch\_estimate.hpp}}
\DoxyCodeLine{5440 \textcolor{comment}{// start catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5441 }
\DoxyCodeLine{5442 \textcolor{comment}{// Outlier information}}
\DoxyCodeLine{5443 }
\DoxyCodeLine{5444 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5445     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{5446         \textcolor{keyword}{struct }OutlierClassification \{}
\DoxyCodeLine{5447             \textcolor{keywordtype}{int} samples\_seen = 0;}
\DoxyCodeLine{5448             \textcolor{keywordtype}{int} low\_severe = 0;     \textcolor{comment}{// more than 3 times IQR below Q1}}
\DoxyCodeLine{5449             \textcolor{keywordtype}{int} low\_mild = 0;       \textcolor{comment}{// 1.5 to 3 times IQR below Q1}}
\DoxyCodeLine{5450             \textcolor{keywordtype}{int} high\_mild = 0;      \textcolor{comment}{// 1.5 to 3 times IQR above Q3}}
\DoxyCodeLine{5451             \textcolor{keywordtype}{int} high\_severe = 0;    \textcolor{comment}{// more than 3 times IQR above Q3}}
\DoxyCodeLine{5452 }
\DoxyCodeLine{5453             \textcolor{keywordtype}{int} total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5454                 \textcolor{keywordflow}{return} low\_severe + low\_mild + high\_mild + high\_severe;}
\DoxyCodeLine{5455             \}}
\DoxyCodeLine{5456         \};}
\DoxyCodeLine{5457     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{5458 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{5459 }
\DoxyCodeLine{5460 \textcolor{comment}{// end catch\_outlier\_classification.hpp}}
\DoxyCodeLine{5461 }
\DoxyCodeLine{5462 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{5463 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5464 }
\DoxyCodeLine{5465 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{5466 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{5467 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{5468 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{5469 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5470 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5471 }
\DoxyCodeLine{5472 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5473 }
\DoxyCodeLine{5474     \textcolor{keyword}{struct }ReporterConfig \{}
\DoxyCodeLine{5475         \textcolor{keyword}{explicit} ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig );}
\DoxyCodeLine{5476 }
\DoxyCodeLine{5477         ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream );}
\DoxyCodeLine{5478 }
\DoxyCodeLine{5479         std::ostream\& stream() \textcolor{keyword}{const};}
\DoxyCodeLine{5480         IConfigPtr fullConfig() \textcolor{keyword}{const};}
\DoxyCodeLine{5481 }
\DoxyCodeLine{5482     \textcolor{keyword}{private}:}
\DoxyCodeLine{5483         std::ostream* m\_stream;}
\DoxyCodeLine{5484         IConfigPtr m\_fullConfig;}
\DoxyCodeLine{5485     \};}
\DoxyCodeLine{5486 }
\DoxyCodeLine{5487     \textcolor{keyword}{struct }ReporterPreferences \{}
\DoxyCodeLine{5488         \textcolor{keywordtype}{bool} shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5489         \textcolor{keywordtype}{bool} shouldReportAllAssertions = \textcolor{keyword}{false};}
\DoxyCodeLine{5490     \};}
\DoxyCodeLine{5491 }
\DoxyCodeLine{5492     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{5493     \textcolor{keyword}{struct }LazyStat : Option<T> \{}
\DoxyCodeLine{5494         LazyStat\& operator=( T \textcolor{keyword}{const}\& \_value ) \{}
\DoxyCodeLine{5495             Option<T>::operator=( \_value );}
\DoxyCodeLine{5496             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5497             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{5498         \}}
\DoxyCodeLine{5499         \textcolor{keywordtype}{void} reset() \{}
\DoxyCodeLine{5500             Option<T>::reset();}
\DoxyCodeLine{5501             used = \textcolor{keyword}{false};}
\DoxyCodeLine{5502         \}}
\DoxyCodeLine{5503         \textcolor{keywordtype}{bool} used = \textcolor{keyword}{false};}
\DoxyCodeLine{5504     \};}
\DoxyCodeLine{5505 }
\DoxyCodeLine{5506     \textcolor{keyword}{struct }TestRunInfo \{}
\DoxyCodeLine{5507         TestRunInfo( std::string \textcolor{keyword}{const}\& \_name );}
\DoxyCodeLine{5508         std::string name;}
\DoxyCodeLine{5509     \};}
\DoxyCodeLine{5510     \textcolor{keyword}{struct }GroupInfo \{}
\DoxyCodeLine{5511         GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{5512                     std::size\_t \_groupIndex,}
\DoxyCodeLine{5513                     std::size\_t \_groupsCount );}
\DoxyCodeLine{5514 }
\DoxyCodeLine{5515         std::string name;}
\DoxyCodeLine{5516         std::size\_t groupIndex;}
\DoxyCodeLine{5517         std::size\_t groupsCounts;}
\DoxyCodeLine{5518     \};}
\DoxyCodeLine{5519 }
\DoxyCodeLine{5520     \textcolor{keyword}{struct }AssertionStats \{}
\DoxyCodeLine{5521         AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{5522                         std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{5523                         Totals \textcolor{keyword}{const}\& \_totals );}
\DoxyCodeLine{5524 }
\DoxyCodeLine{5525         AssertionStats( AssertionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5526         AssertionStats( AssertionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5527         AssertionStats\& operator = ( AssertionStats \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5528         AssertionStats\& operator = ( AssertionStats \&\& )     = \textcolor{keyword}{delete};}
\DoxyCodeLine{5529         \textcolor{keyword}{virtual} \string~AssertionStats();}
\DoxyCodeLine{5530 }
\DoxyCodeLine{5531         AssertionResult assertionResult;}
\DoxyCodeLine{5532         std::vector<MessageInfo> infoMessages;}
\DoxyCodeLine{5533         Totals totals;}
\DoxyCodeLine{5534     \};}
\DoxyCodeLine{5535 }
\DoxyCodeLine{5536     \textcolor{keyword}{struct }SectionStats \{}
\DoxyCodeLine{5537         SectionStats(   SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{5538                         Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{5539                         \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{5540                         \textcolor{keywordtype}{bool} \_missingAssertions );}
\DoxyCodeLine{5541         SectionStats( SectionStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5542         SectionStats( SectionStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5543         SectionStats\& operator = ( SectionStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5544         SectionStats\& operator = ( SectionStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5545         \textcolor{keyword}{virtual} \string~SectionStats();}
\DoxyCodeLine{5546 }
\DoxyCodeLine{5547         SectionInfo sectionInfo;}
\DoxyCodeLine{5548         Counts assertions;}
\DoxyCodeLine{5549         \textcolor{keywordtype}{double} durationInSeconds;}
\DoxyCodeLine{5550         \textcolor{keywordtype}{bool} missingAssertions;}
\DoxyCodeLine{5551     \};}
\DoxyCodeLine{5552 }
\DoxyCodeLine{5553     \textcolor{keyword}{struct }TestCaseStats \{}
\DoxyCodeLine{5554         TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{5555                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5556                         std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{5557                         std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{5558                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5559 }
\DoxyCodeLine{5560         TestCaseStats( TestCaseStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5561         TestCaseStats( TestCaseStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5562         TestCaseStats\& operator = ( TestCaseStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5563         TestCaseStats\& operator = ( TestCaseStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5564         \textcolor{keyword}{virtual} \string~TestCaseStats();}
\DoxyCodeLine{5565 }
\DoxyCodeLine{5566         TestCaseInfo testInfo;}
\DoxyCodeLine{5567         Totals totals;}
\DoxyCodeLine{5568         std::string stdOut;}
\DoxyCodeLine{5569         std::string stdErr;}
\DoxyCodeLine{5570         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5571     \};}
\DoxyCodeLine{5572 }
\DoxyCodeLine{5573     \textcolor{keyword}{struct }TestGroupStats \{}
\DoxyCodeLine{5574         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{5575                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5576                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5577         TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo );}
\DoxyCodeLine{5578 }
\DoxyCodeLine{5579         TestGroupStats( TestGroupStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5580         TestGroupStats( TestGroupStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5581         TestGroupStats\& operator = ( TestGroupStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5582         TestGroupStats\& operator = ( TestGroupStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5583         \textcolor{keyword}{virtual} \string~TestGroupStats();}
\DoxyCodeLine{5584 }
\DoxyCodeLine{5585         GroupInfo groupInfo;}
\DoxyCodeLine{5586         Totals totals;}
\DoxyCodeLine{5587         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5588     \};}
\DoxyCodeLine{5589 }
\DoxyCodeLine{5590     \textcolor{keyword}{struct }TestRunStats \{}
\DoxyCodeLine{5591         TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{5592                         Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{5593                         \textcolor{keywordtype}{bool} \_aborting );}
\DoxyCodeLine{5594 }
\DoxyCodeLine{5595         TestRunStats( TestRunStats \textcolor{keyword}{const}\& )              = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5596         TestRunStats( TestRunStats \&\& )                  = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5597         TestRunStats\& operator = ( TestRunStats \textcolor{keyword}{const}\& ) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5598         TestRunStats\& operator = ( TestRunStats \&\& )     = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5599         \textcolor{keyword}{virtual} \string~TestRunStats();}
\DoxyCodeLine{5600 }
\DoxyCodeLine{5601         TestRunInfo runInfo;}
\DoxyCodeLine{5602         Totals totals;}
\DoxyCodeLine{5603         \textcolor{keywordtype}{bool} aborting;}
\DoxyCodeLine{5604     \};}
\DoxyCodeLine{5605 }
\DoxyCodeLine{5606 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5607     \textcolor{keyword}{struct }BenchmarkInfo \{}
\DoxyCodeLine{5608         std::string name;}
\DoxyCodeLine{5609         \textcolor{keywordtype}{double} estimatedDuration;}
\DoxyCodeLine{5610         \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{5611         \textcolor{keywordtype}{int} samples;}
\DoxyCodeLine{5612         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} resamples;}
\DoxyCodeLine{5613         \textcolor{keywordtype}{double} clockResolution;}
\DoxyCodeLine{5614         \textcolor{keywordtype}{double} clockCost;}
\DoxyCodeLine{5615     \};}
\DoxyCodeLine{5616 }
\DoxyCodeLine{5617     \textcolor{keyword}{template} <\textcolor{keyword}{class} Duration>}
\DoxyCodeLine{5618     \textcolor{keyword}{struct }BenchmarkStats \{}
\DoxyCodeLine{5619         BenchmarkInfo info;}
\DoxyCodeLine{5620 }
\DoxyCodeLine{5621         std::vector<Duration> samples;}
\DoxyCodeLine{5622         Benchmark::Estimate<Duration> mean;}
\DoxyCodeLine{5623         Benchmark::Estimate<Duration> standardDeviation;}
\DoxyCodeLine{5624         Benchmark::OutlierClassification outliers;}
\DoxyCodeLine{5625         \textcolor{keywordtype}{double} outlierVariance;}
\DoxyCodeLine{5626 }
\DoxyCodeLine{5627         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{5628         \textcolor{keyword}{operator} BenchmarkStats<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5629             std::vector<Duration2> samples2;}
\DoxyCodeLine{5630             samples2.reserve(samples.size());}
\DoxyCodeLine{5631             std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{5632             \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{5633                 info,}
\DoxyCodeLine{5634                 std::move(samples2),}
\DoxyCodeLine{5635                 mean,}
\DoxyCodeLine{5636                 standardDeviation,}
\DoxyCodeLine{5637                 outliers,}
\DoxyCodeLine{5638                 outlierVariance,}
\DoxyCodeLine{5639             \};}
\DoxyCodeLine{5640         \}}
\DoxyCodeLine{5641     \};}
\DoxyCodeLine{5642 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5643 }
\DoxyCodeLine{5644     \textcolor{keyword}{struct }IStreamingReporter \{}
\DoxyCodeLine{5645         \textcolor{keyword}{virtual} \string~IStreamingReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5646 }
\DoxyCodeLine{5647         \textcolor{comment}{// Implementing class must also provide the following static methods:}}
\DoxyCodeLine{5648         \textcolor{comment}{// static std::string getDescription();}}
\DoxyCodeLine{5649         \textcolor{comment}{// static std::set<Verbosity> getSupportedVerbosities()}}
\DoxyCodeLine{5650 }
\DoxyCodeLine{5651         \textcolor{keyword}{virtual} ReporterPreferences getPreferences() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5652 }
\DoxyCodeLine{5653         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) = 0;}
\DoxyCodeLine{5654 }
\DoxyCodeLine{5655         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{5656 }
\DoxyCodeLine{5657         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) = 0;}
\DoxyCodeLine{5658         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) = 0;}
\DoxyCodeLine{5659 }
\DoxyCodeLine{5660         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5661         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) = 0;}
\DoxyCodeLine{5662 }
\DoxyCodeLine{5663 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{5664         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5665         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5666         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5667         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{5668 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{5669 }
\DoxyCodeLine{5670         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) = 0;}
\DoxyCodeLine{5671 }
\DoxyCodeLine{5672         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{5673         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) = 0;}
\DoxyCodeLine{5674 }
\DoxyCodeLine{5675         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) = 0;}
\DoxyCodeLine{5676         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) = 0;}
\DoxyCodeLine{5677         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) = 0;}
\DoxyCodeLine{5678         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) = 0;}
\DoxyCodeLine{5679 }
\DoxyCodeLine{5680         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) = 0;}
\DoxyCodeLine{5681 }
\DoxyCodeLine{5682         \textcolor{comment}{// Default empty implementation provided}}
\DoxyCodeLine{5683         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fatalErrorEncountered( StringRef name );}
\DoxyCodeLine{5684 }
\DoxyCodeLine{5685         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const};}
\DoxyCodeLine{5686     \};}
\DoxyCodeLine{5687     \textcolor{keyword}{using} IStreamingReporterPtr = std::unique\_ptr<IStreamingReporter>;}
\DoxyCodeLine{5688 }
\DoxyCodeLine{5689     \textcolor{keyword}{struct }IReporterFactory \{}
\DoxyCodeLine{5690         \textcolor{keyword}{virtual} \string~IReporterFactory();}
\DoxyCodeLine{5691         \textcolor{keyword}{virtual} IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5692         \textcolor{keyword}{virtual} std::string getDescription() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5693     \};}
\DoxyCodeLine{5694     \textcolor{keyword}{using} IReporterFactoryPtr = std::shared\_ptr<IReporterFactory>;}
\DoxyCodeLine{5695 }
\DoxyCodeLine{5696     \textcolor{keyword}{struct }IReporterRegistry \{}
\DoxyCodeLine{5697         \textcolor{keyword}{using} FactoryMap = std::map<std::string, IReporterFactoryPtr>;}
\DoxyCodeLine{5698         \textcolor{keyword}{using} Listeners = std::vector<IReporterFactoryPtr>;}
\DoxyCodeLine{5699 }
\DoxyCodeLine{5700         \textcolor{keyword}{virtual} \string~IReporterRegistry();}
\DoxyCodeLine{5701         \textcolor{keyword}{virtual} IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5702         \textcolor{keyword}{virtual} FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5703         \textcolor{keyword}{virtual} Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{5704     \};}
\DoxyCodeLine{5705 }
\DoxyCodeLine{5706 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5707 }
\DoxyCodeLine{5708 \textcolor{comment}{// end catch\_interfaces\_reporter.h}}
\DoxyCodeLine{5709 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{5710 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{5711 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{5712 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{5713 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{5714 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{5715 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{5716 }
\DoxyCodeLine{5717 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5718     \textcolor{keywordtype}{void} prepareExpandedExpression(AssertionResult\& result);}
\DoxyCodeLine{5719 }
\DoxyCodeLine{5720     \textcolor{comment}{// Returns double formatted as \%.3f (format expected on output)}}
\DoxyCodeLine{5721     std::string getFormattedDuration( \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5722 }
\DoxyCodeLine{5724     \textcolor{keywordtype}{bool} shouldShowDuration( IConfig \textcolor{keyword}{const}\& config, \textcolor{keywordtype}{double} duration );}
\DoxyCodeLine{5725 }
\DoxyCodeLine{5726     std::string serializeFilters( std::vector<std::string> \textcolor{keyword}{const}\& container );}
\DoxyCodeLine{5727 }
\DoxyCodeLine{5728     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5729     \textcolor{keyword}{struct }StreamingReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5730 }
\DoxyCodeLine{5731         StreamingReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5732         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5733             stream( \_config.stream() )}
\DoxyCodeLine{5734         \{}
\DoxyCodeLine{5735             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5736             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5737                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5738         \}}
\DoxyCodeLine{5739 }
\DoxyCodeLine{5740         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5741             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5742         \}}
\DoxyCodeLine{5743 }
\DoxyCodeLine{5744         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5745             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5746         \}}
\DoxyCodeLine{5747 }
\DoxyCodeLine{5748         \string~StreamingReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5749 }
\DoxyCodeLine{5750         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5751 }
\DoxyCodeLine{5752         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5753 }
\DoxyCodeLine{5754         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5755             currentTestRunInfo = \_testRunInfo;}
\DoxyCodeLine{5756         \}}
\DoxyCodeLine{5757 }
\DoxyCodeLine{5758         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& \_groupInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5759             currentGroupInfo = \_groupInfo;}
\DoxyCodeLine{5760         \}}
\DoxyCodeLine{5761 }
\DoxyCodeLine{5762         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& \_testInfo)\textcolor{keyword}{ override  }\{}
\DoxyCodeLine{5763             currentTestCaseInfo = \_testInfo;}
\DoxyCodeLine{5764         \}}
\DoxyCodeLine{5765         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5766             m\_sectionStack.push\_back(\_sectionInfo);}
\DoxyCodeLine{5767         \}}
\DoxyCodeLine{5768 }
\DoxyCodeLine{5769         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_sectionStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5770             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5771         \}}
\DoxyCodeLine{5772         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testCaseStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5773             currentTestCaseInfo.reset();}
\DoxyCodeLine{5774         \}}
\DoxyCodeLine{5775         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testGroupStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5776             currentGroupInfo.reset();}
\DoxyCodeLine{5777         \}}
\DoxyCodeLine{5778         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \textcolor{comment}{/* \_testRunStats */})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5779             currentTestCaseInfo.reset();}
\DoxyCodeLine{5780             currentGroupInfo.reset();}
\DoxyCodeLine{5781             currentTestRunInfo.reset();}
\DoxyCodeLine{5782         \}}
\DoxyCodeLine{5783 }
\DoxyCodeLine{5784         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5785             \textcolor{comment}{// Don't do anything with this by default.}}
\DoxyCodeLine{5786             \textcolor{comment}{// It can optionally be overridden in the derived class.}}
\DoxyCodeLine{5787         \}}
\DoxyCodeLine{5788 }
\DoxyCodeLine{5789         IConfigPtr m\_config;}
\DoxyCodeLine{5790         std::ostream\& stream;}
\DoxyCodeLine{5791 }
\DoxyCodeLine{5792         LazyStat<TestRunInfo> currentTestRunInfo;}
\DoxyCodeLine{5793         LazyStat<GroupInfo> currentGroupInfo;}
\DoxyCodeLine{5794         LazyStat<TestCaseInfo> currentTestCaseInfo;}
\DoxyCodeLine{5795 }
\DoxyCodeLine{5796         std::vector<SectionInfo> m\_sectionStack;}
\DoxyCodeLine{5797         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5798     \};}
\DoxyCodeLine{5799 }
\DoxyCodeLine{5800     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{5801     \textcolor{keyword}{struct }CumulativeReporterBase : IStreamingReporter \{}
\DoxyCodeLine{5802         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ChildNodeT>}
\DoxyCodeLine{5803         \textcolor{keyword}{struct }Node \{}
\DoxyCodeLine{5804             \textcolor{keyword}{explicit} Node( T \textcolor{keyword}{const}\& \_value ) : value( \_value ) \{\}}
\DoxyCodeLine{5805             \textcolor{keyword}{virtual} \string~Node() \{\}}
\DoxyCodeLine{5806 }
\DoxyCodeLine{5807             \textcolor{keyword}{using} ChildNodes = std::vector<std::shared\_ptr<ChildNodeT>>;}
\DoxyCodeLine{5808             T value;}
\DoxyCodeLine{5809             ChildNodes children;}
\DoxyCodeLine{5810         \};}
\DoxyCodeLine{5811         \textcolor{keyword}{struct }SectionNode \{}
\DoxyCodeLine{5812             \textcolor{keyword}{explicit} SectionNode(SectionStats \textcolor{keyword}{const}\& \_stats) : stats(\_stats) \{\}}
\DoxyCodeLine{5813             \textcolor{keyword}{virtual} \string~SectionNode() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5814 }
\DoxyCodeLine{5815             \textcolor{keywordtype}{bool} operator == (SectionNode \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5816                 \textcolor{keywordflow}{return} stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;}
\DoxyCodeLine{5817             \}}
\DoxyCodeLine{5818             \textcolor{keywordtype}{bool} operator == (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5819                 \textcolor{keywordflow}{return} operator==(*other);}
\DoxyCodeLine{5820             \}}
\DoxyCodeLine{5821 }
\DoxyCodeLine{5822             SectionStats stats;}
\DoxyCodeLine{5823             \textcolor{keyword}{using} ChildSections = std::vector<std::shared\_ptr<SectionNode>>;}
\DoxyCodeLine{5824             \textcolor{keyword}{using} Assertions = std::vector<AssertionStats>;}
\DoxyCodeLine{5825             ChildSections childSections;}
\DoxyCodeLine{5826             Assertions assertions;}
\DoxyCodeLine{5827             std::string stdOut;}
\DoxyCodeLine{5828             std::string stdErr;}
\DoxyCodeLine{5829         \};}
\DoxyCodeLine{5830 }
\DoxyCodeLine{5831         \textcolor{keyword}{struct }BySectionInfo \{}
\DoxyCodeLine{5832             BySectionInfo( SectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other ) \{\}}
\DoxyCodeLine{5833             BySectionInfo( BySectionInfo \textcolor{keyword}{const}\& other ) : m\_other( other.m\_other ) \{\}}
\DoxyCodeLine{5834             \textcolor{keywordtype}{bool} operator() (std::shared\_ptr<SectionNode> \textcolor{keyword}{const}\& node)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{5835                 \textcolor{keywordflow}{return} ((node-\/>stats.sectionInfo.name == m\_other.name) \&\&}
\DoxyCodeLine{5836                         (node-\/>stats.sectionInfo.lineInfo == m\_other.lineInfo));}
\DoxyCodeLine{5837             \}}
\DoxyCodeLine{5838             \textcolor{keywordtype}{void} operator=(BySectionInfo \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{5839 }
\DoxyCodeLine{5840         \textcolor{keyword}{private}:}
\DoxyCodeLine{5841             SectionInfo \textcolor{keyword}{const}\& m\_other;}
\DoxyCodeLine{5842         \};}
\DoxyCodeLine{5843 }
\DoxyCodeLine{5844         \textcolor{keyword}{using} TestCaseNode = Node<TestCaseStats, SectionNode>;}
\DoxyCodeLine{5845         \textcolor{keyword}{using} TestGroupNode = Node<TestGroupStats, TestCaseNode>;}
\DoxyCodeLine{5846         \textcolor{keyword}{using} TestRunNode = Node<TestRunStats, TestGroupNode>;}
\DoxyCodeLine{5847 }
\DoxyCodeLine{5848         CumulativeReporterBase( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{5849         :   m\_config( \_config.fullConfig() ),}
\DoxyCodeLine{5850             stream( \_config.stream() )}
\DoxyCodeLine{5851         \{}
\DoxyCodeLine{5852             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{false};}
\DoxyCodeLine{5853             \textcolor{keywordflow}{if}( !DerivedT::getSupportedVerbosities().count( m\_config-\/>verbosity() ) )}
\DoxyCodeLine{5854                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Verbosity level not supported by this reporter"{}} );}
\DoxyCodeLine{5855         \}}
\DoxyCodeLine{5856         \string~CumulativeReporterBase() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{5857 }
\DoxyCodeLine{5858         ReporterPreferences getPreferences()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{5859             \textcolor{keywordflow}{return} m\_reporterPrefs;}
\DoxyCodeLine{5860         \}}
\DoxyCodeLine{5861 }
\DoxyCodeLine{5862         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities() \{}
\DoxyCodeLine{5863             \textcolor{keywordflow}{return} \{ Verbosity::Normal \};}
\DoxyCodeLine{5864         \}}
\DoxyCodeLine{5865 }
\DoxyCodeLine{5866         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5867         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5868 }
\DoxyCodeLine{5869         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5870 }
\DoxyCodeLine{5871         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5872             SectionStats incompleteStats( sectionInfo, Counts(), 0, \textcolor{keyword}{false} );}
\DoxyCodeLine{5873             std::shared\_ptr<SectionNode> node;}
\DoxyCodeLine{5874             \textcolor{keywordflow}{if}( m\_sectionStack.empty() ) \{}
\DoxyCodeLine{5875                 \textcolor{keywordflow}{if}( !m\_rootSection )}
\DoxyCodeLine{5876                     m\_rootSection = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5877                 node = m\_rootSection;}
\DoxyCodeLine{5878             \}}
\DoxyCodeLine{5879             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{5880                 SectionNode\& parentNode = *m\_sectionStack.back();}
\DoxyCodeLine{5881                 \textcolor{keyword}{auto} it =}
\DoxyCodeLine{5882                     std::find\_if(   parentNode.childSections.begin(),}
\DoxyCodeLine{5883                                     parentNode.childSections.end(),}
\DoxyCodeLine{5884                                     BySectionInfo( sectionInfo ) );}
\DoxyCodeLine{5885                 \textcolor{keywordflow}{if}( it == parentNode.childSections.end() ) \{}
\DoxyCodeLine{5886                     node = std::make\_shared<SectionNode>( incompleteStats );}
\DoxyCodeLine{5887                     parentNode.childSections.push\_back( node );}
\DoxyCodeLine{5888                 \}}
\DoxyCodeLine{5889                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{5890                     node = *it;}
\DoxyCodeLine{5891             \}}
\DoxyCodeLine{5892             m\_sectionStack.push\_back( node );}
\DoxyCodeLine{5893             m\_deepestSection = std::move(node);}
\DoxyCodeLine{5894         \}}
\DoxyCodeLine{5895 }
\DoxyCodeLine{5896         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5897 }
\DoxyCodeLine{5898         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5899             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5900             \textcolor{comment}{// AssertionResult holds a pointer to a temporary DecomposedExpression,}}
\DoxyCodeLine{5901             \textcolor{comment}{// which getExpandedExpression() calls to build the expression string.}}
\DoxyCodeLine{5902             \textcolor{comment}{// Our section stack copy of the assertionResult will likely outlive the}}
\DoxyCodeLine{5903             \textcolor{comment}{// temporary, so it must be expanded or discarded now to avoid calling}}
\DoxyCodeLine{5904             \textcolor{comment}{// a destroyed object later.}}
\DoxyCodeLine{5905             prepareExpandedExpression(\textcolor{keyword}{const\_cast<}AssertionResult\&\textcolor{keyword}{>}( assertionStats.assertionResult ) );}
\DoxyCodeLine{5906             SectionNode\& sectionNode = *m\_sectionStack.back();}
\DoxyCodeLine{5907             sectionNode.assertions.push\_back(assertionStats);}
\DoxyCodeLine{5908             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{5909         \}}
\DoxyCodeLine{5910         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5911             assert(!m\_sectionStack.empty());}
\DoxyCodeLine{5912             SectionNode\& node = *m\_sectionStack.back();}
\DoxyCodeLine{5913             node.stats = sectionStats;}
\DoxyCodeLine{5914             m\_sectionStack.pop\_back();}
\DoxyCodeLine{5915         \}}
\DoxyCodeLine{5916         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5917             \textcolor{keyword}{auto} node = std::make\_shared<TestCaseNode>(testCaseStats);}
\DoxyCodeLine{5918             assert(m\_sectionStack.size() == 0);}
\DoxyCodeLine{5919             node-\/>children.push\_back(m\_rootSection);}
\DoxyCodeLine{5920             m\_testCases.push\_back(node);}
\DoxyCodeLine{5921             m\_rootSection.reset();}
\DoxyCodeLine{5922 }
\DoxyCodeLine{5923             assert(m\_deepestSection);}
\DoxyCodeLine{5924             m\_deepestSection-\/>stdOut = testCaseStats.stdOut;}
\DoxyCodeLine{5925             m\_deepestSection-\/>stdErr = testCaseStats.stdErr;}
\DoxyCodeLine{5926         \}}
\DoxyCodeLine{5927         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5928             \textcolor{keyword}{auto} node = std::make\_shared<TestGroupNode>(testGroupStats);}
\DoxyCodeLine{5929             node-\/>children.swap(m\_testCases);}
\DoxyCodeLine{5930             m\_testGroups.push\_back(node);}
\DoxyCodeLine{5931         \}}
\DoxyCodeLine{5932         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats)\textcolor{keyword}{ override }\{}
\DoxyCodeLine{5933             \textcolor{keyword}{auto} node = std::make\_shared<TestRunNode>(testRunStats);}
\DoxyCodeLine{5934             node-\/>children.swap(m\_testGroups);}
\DoxyCodeLine{5935             m\_testRuns.push\_back(node);}
\DoxyCodeLine{5936             testRunEndedCumulative();}
\DoxyCodeLine{5937         \}}
\DoxyCodeLine{5938         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} testRunEndedCumulative() = 0;}
\DoxyCodeLine{5939 }
\DoxyCodeLine{5940         \textcolor{keywordtype}{void} skipTest(TestCaseInfo \textcolor{keyword}{const}\&)\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{5941 }
\DoxyCodeLine{5942         IConfigPtr m\_config;}
\DoxyCodeLine{5943         std::ostream\& stream;}
\DoxyCodeLine{5944         std::vector<AssertionStats> m\_assertions;}
\DoxyCodeLine{5945         std::vector<std::vector<std::shared\_ptr<SectionNode>>> m\_sections;}
\DoxyCodeLine{5946         std::vector<std::shared\_ptr<TestCaseNode>> m\_testCases;}
\DoxyCodeLine{5947         std::vector<std::shared\_ptr<TestGroupNode>> m\_testGroups;}
\DoxyCodeLine{5948 }
\DoxyCodeLine{5949         std::vector<std::shared\_ptr<TestRunNode>> m\_testRuns;}
\DoxyCodeLine{5950 }
\DoxyCodeLine{5951         std::shared\_ptr<SectionNode> m\_rootSection;}
\DoxyCodeLine{5952         std::shared\_ptr<SectionNode> m\_deepestSection;}
\DoxyCodeLine{5953         std::vector<std::shared\_ptr<SectionNode>> m\_sectionStack;}
\DoxyCodeLine{5954         ReporterPreferences m\_reporterPrefs;}
\DoxyCodeLine{5955     \};}
\DoxyCodeLine{5956 }
\DoxyCodeLine{5957     \textcolor{keyword}{template}<\textcolor{keywordtype}{char} C>}
\DoxyCodeLine{5958     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* getLineOfChars() \{}
\DoxyCodeLine{5959         \textcolor{keyword}{static} \textcolor{keywordtype}{char} line[CATCH\_CONFIG\_CONSOLE\_WIDTH] = \{0\};}
\DoxyCodeLine{5960         \textcolor{keywordflow}{if}( !*line ) \{}
\DoxyCodeLine{5961             std::memset( line, C, CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1 );}
\DoxyCodeLine{5962             line[CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1] = 0;}
\DoxyCodeLine{5963         \}}
\DoxyCodeLine{5964         \textcolor{keywordflow}{return} line;}
\DoxyCodeLine{5965     \}}
\DoxyCodeLine{5966 }
\DoxyCodeLine{5967     \textcolor{keyword}{struct }TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> \{}
\DoxyCodeLine{5968         TestEventListenerBase( ReporterConfig \textcolor{keyword}{const}\& \_config );}
\DoxyCodeLine{5969 }
\DoxyCodeLine{5970         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{5971 }
\DoxyCodeLine{5972         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5973         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{5974     \};}
\DoxyCodeLine{5975 }
\DoxyCodeLine{5976 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{5977 }
\DoxyCodeLine{5978 \textcolor{comment}{// end catch\_reporter\_bases.hpp}}
\DoxyCodeLine{5979 \textcolor{comment}{// start catch\_console\_colour.h}}
\DoxyCodeLine{5980 }
\DoxyCodeLine{5981 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{5982 }
\DoxyCodeLine{5983     \textcolor{keyword}{struct }Colour \{}
\DoxyCodeLine{5984         \textcolor{keyword}{enum} Code \{}
\DoxyCodeLine{5985             None = 0,}
\DoxyCodeLine{5986 }
\DoxyCodeLine{5987             White,}
\DoxyCodeLine{5988             Red,}
\DoxyCodeLine{5989             Green,}
\DoxyCodeLine{5990             Blue,}
\DoxyCodeLine{5991             Cyan,}
\DoxyCodeLine{5992             Yellow,}
\DoxyCodeLine{5993             Grey,}
\DoxyCodeLine{5994 }
\DoxyCodeLine{5995             Bright = 0x10,}
\DoxyCodeLine{5996 }
\DoxyCodeLine{5997             BrightRed = Bright | Red,}
\DoxyCodeLine{5998             BrightGreen = Bright | Green,}
\DoxyCodeLine{5999             LightGrey = Bright | Grey,}
\DoxyCodeLine{6000             BrightWhite = Bright | White,}
\DoxyCodeLine{6001             BrightYellow = Bright | Yellow,}
\DoxyCodeLine{6002 }
\DoxyCodeLine{6003             \textcolor{comment}{// By intention}}
\DoxyCodeLine{6004             FileName = LightGrey,}
\DoxyCodeLine{6005             Warning = BrightYellow,}
\DoxyCodeLine{6006             ResultError = BrightRed,}
\DoxyCodeLine{6007             ResultSuccess = BrightGreen,}
\DoxyCodeLine{6008             ResultExpectedFailure = Warning,}
\DoxyCodeLine{6009 }
\DoxyCodeLine{6010             Error = BrightRed,}
\DoxyCodeLine{6011             Success = Green,}
\DoxyCodeLine{6012 }
\DoxyCodeLine{6013             OriginalExpression = Cyan,}
\DoxyCodeLine{6014             ReconstructedExpression = BrightYellow,}
\DoxyCodeLine{6015 }
\DoxyCodeLine{6016             SecondaryText = LightGrey,}
\DoxyCodeLine{6017             Headers = White}
\DoxyCodeLine{6018         \};}
\DoxyCodeLine{6019 }
\DoxyCodeLine{6020         \textcolor{comment}{// Use constructed object for RAII guard}}
\DoxyCodeLine{6021         Colour( Code \_colourCode );}
\DoxyCodeLine{6022         Colour( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6023         Colour\& operator=( Colour\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6024         \string~Colour();}
\DoxyCodeLine{6025 }
\DoxyCodeLine{6026         \textcolor{comment}{// Use static method for one-\/shot changes}}
\DoxyCodeLine{6027         \textcolor{keyword}{static} \textcolor{keywordtype}{void} use( Code \_colourCode );}
\DoxyCodeLine{6028 }
\DoxyCodeLine{6029     \textcolor{keyword}{private}:}
\DoxyCodeLine{6030         \textcolor{keywordtype}{bool} m\_moved = \textcolor{keyword}{false};}
\DoxyCodeLine{6031     \};}
\DoxyCodeLine{6032 }
\DoxyCodeLine{6033     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& );}
\DoxyCodeLine{6034 }
\DoxyCodeLine{6035 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6036 }
\DoxyCodeLine{6037 \textcolor{comment}{// end catch\_console\_colour.h}}
\DoxyCodeLine{6038 \textcolor{comment}{// start catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6039 }
\DoxyCodeLine{6040 }
\DoxyCodeLine{6041 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6042 }
\DoxyCodeLine{6043     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6044     \textcolor{keyword}{class }ReporterRegistrar \{}
\DoxyCodeLine{6045 }
\DoxyCodeLine{6046         \textcolor{keyword}{class }ReporterFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6047 }
\DoxyCodeLine{6048             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6049                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6050             \}}
\DoxyCodeLine{6051 }
\DoxyCodeLine{6052             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6053                 \textcolor{keywordflow}{return} T::getDescription();}
\DoxyCodeLine{6054             \}}
\DoxyCodeLine{6055         \};}
\DoxyCodeLine{6056 }
\DoxyCodeLine{6057     \textcolor{keyword}{public}:}
\DoxyCodeLine{6058 }
\DoxyCodeLine{6059         \textcolor{keyword}{explicit} ReporterRegistrar( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{6060             getMutableRegistryHub().registerReporter( name, std::make\_shared<ReporterFactory>() );}
\DoxyCodeLine{6061         \}}
\DoxyCodeLine{6062     \};}
\DoxyCodeLine{6063 }
\DoxyCodeLine{6064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6065     \textcolor{keyword}{class }ListenerRegistrar \{}
\DoxyCodeLine{6066 }
\DoxyCodeLine{6067         \textcolor{keyword}{class }ListenerFactory : \textcolor{keyword}{public} IReporterFactory \{}
\DoxyCodeLine{6068 }
\DoxyCodeLine{6069             IStreamingReporterPtr create( ReporterConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6070                 \textcolor{keywordflow}{return} std::unique\_ptr<T>( \textcolor{keyword}{new} T( config ) );}
\DoxyCodeLine{6071             \}}
\DoxyCodeLine{6072             std::string getDescription()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6073                 \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{6074             \}}
\DoxyCodeLine{6075         \};}
\DoxyCodeLine{6076 }
\DoxyCodeLine{6077     \textcolor{keyword}{public}:}
\DoxyCodeLine{6078 }
\DoxyCodeLine{6079         ListenerRegistrar() \{}
\DoxyCodeLine{6080             getMutableRegistryHub().registerListener( std::make\_shared<ListenerFactory>() );}
\DoxyCodeLine{6081         \}}
\DoxyCodeLine{6082     \};}
\DoxyCodeLine{6083 \}}
\DoxyCodeLine{6084 }
\DoxyCodeLine{6085 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{6086 }
\DoxyCodeLine{6087 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER( name, reporterType ) \(\backslash\)}}
\DoxyCodeLine{6088 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION         \(\backslash\)}}
\DoxyCodeLine{6089 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS          \(\backslash\)}}
\DoxyCodeLine{6090 \textcolor{preprocessor}{    namespace\{ Catch::ReporterRegistrar<reporterType> catch\_internal\_RegistrarFor\#\#reporterType( name ); \} \(\backslash\)}}
\DoxyCodeLine{6091 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6092 }
\DoxyCodeLine{6093 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER( listenerType ) \(\backslash\)}}
\DoxyCodeLine{6094 \textcolor{preprocessor}{    CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION   \(\backslash\)}}
\DoxyCodeLine{6095 \textcolor{preprocessor}{    CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS    \(\backslash\)}}
\DoxyCodeLine{6096 \textcolor{preprocessor}{    namespace\{ Catch::ListenerRegistrar<listenerType> catch\_internal\_RegistrarFor\#\#listenerType; \} \(\backslash\)}}
\DoxyCodeLine{6097 \textcolor{preprocessor}{    CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}}
\DoxyCodeLine{6098 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6099 }
\DoxyCodeLine{6100 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_REPORTER(name, reporterType)}}
\DoxyCodeLine{6101 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_LISTENER(listenerType)}}
\DoxyCodeLine{6102 }
\DoxyCodeLine{6103 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{6104 }
\DoxyCodeLine{6105 \textcolor{comment}{// end catch\_reporter\_registrars.hpp}}
\DoxyCodeLine{6106 \textcolor{comment}{// Allow users to base their work off existing reporters}}
\DoxyCodeLine{6107 \textcolor{comment}{// start catch\_reporter\_compact.h}}
\DoxyCodeLine{6108 }
\DoxyCodeLine{6109 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6110 }
\DoxyCodeLine{6111     \textcolor{keyword}{struct }CompactReporter : StreamingReporterBase<CompactReporter> \{}
\DoxyCodeLine{6112 }
\DoxyCodeLine{6113         \textcolor{keyword}{using} StreamingReporterBase::StreamingReporterBase;}
\DoxyCodeLine{6114 }
\DoxyCodeLine{6115         \string~CompactReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6116 }
\DoxyCodeLine{6117         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6118 }
\DoxyCodeLine{6119         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6120 }
\DoxyCodeLine{6121         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6122 }
\DoxyCodeLine{6123         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6124 }
\DoxyCodeLine{6125         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6126 }
\DoxyCodeLine{6127         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6128 }
\DoxyCodeLine{6129     \};}
\DoxyCodeLine{6130 }
\DoxyCodeLine{6131 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6132 }
\DoxyCodeLine{6133 \textcolor{comment}{// end catch\_reporter\_compact.h}}
\DoxyCodeLine{6134 \textcolor{comment}{// start catch\_reporter\_console.h}}
\DoxyCodeLine{6135 }
\DoxyCodeLine{6136 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6137 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{6138 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{6139                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{6140                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{6141 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6142 }
\DoxyCodeLine{6143 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6144     \textcolor{comment}{// Fwd decls}}
\DoxyCodeLine{6145     \textcolor{keyword}{struct }SummaryColumn;}
\DoxyCodeLine{6146     \textcolor{keyword}{class }TablePrinter;}
\DoxyCodeLine{6147 }
\DoxyCodeLine{6148     \textcolor{keyword}{struct }ConsoleReporter : StreamingReporterBase<ConsoleReporter> \{}
\DoxyCodeLine{6149         std::unique\_ptr<TablePrinter> m\_tablePrinter;}
\DoxyCodeLine{6150 }
\DoxyCodeLine{6151         ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config);}
\DoxyCodeLine{6152         \string~ConsoleReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6153         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6154 }
\DoxyCodeLine{6155         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \textcolor{keyword}{override};}
\DoxyCodeLine{6156 }
\DoxyCodeLine{6157         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{6158 }
\DoxyCodeLine{6159         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6160 }
\DoxyCodeLine{6161         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6162 }
\DoxyCodeLine{6163         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6164         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6165 }
\DoxyCodeLine{6166 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6167         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6168         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \textcolor{keyword}{override};}
\DoxyCodeLine{6169         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \textcolor{keyword}{override};}
\DoxyCodeLine{6170         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \textcolor{keyword}{override};}
\DoxyCodeLine{6171 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6172 }
\DoxyCodeLine{6173         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6174         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6175         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6176         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testRunInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6177     \textcolor{keyword}{private}:}
\DoxyCodeLine{6178 }
\DoxyCodeLine{6179         \textcolor{keywordtype}{void} lazyPrint();}
\DoxyCodeLine{6180 }
\DoxyCodeLine{6181         \textcolor{keywordtype}{void} lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{6182         \textcolor{keywordtype}{void} lazyPrintRunInfo();}
\DoxyCodeLine{6183         \textcolor{keywordtype}{void} lazyPrintGroupInfo();}
\DoxyCodeLine{6184         \textcolor{keywordtype}{void} printTestCaseAndSectionHeader();}
\DoxyCodeLine{6185 }
\DoxyCodeLine{6186         \textcolor{keywordtype}{void} printClosedHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6187         \textcolor{keywordtype}{void} printOpenHeader(std::string \textcolor{keyword}{const}\& \_name);}
\DoxyCodeLine{6188 }
\DoxyCodeLine{6189         \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{6190         \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{6191         \textcolor{keywordtype}{void} printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent = 0);}
\DoxyCodeLine{6192 }
\DoxyCodeLine{6193         \textcolor{keywordtype}{void} printTotals(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6194         \textcolor{keywordtype}{void} printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row);}
\DoxyCodeLine{6195 }
\DoxyCodeLine{6196         \textcolor{keywordtype}{void} printTotalsDivider(Totals \textcolor{keyword}{const}\& totals);}
\DoxyCodeLine{6197         \textcolor{keywordtype}{void} printSummaryDivider();}
\DoxyCodeLine{6198         \textcolor{keywordtype}{void} printTestFilters();}
\DoxyCodeLine{6199 }
\DoxyCodeLine{6200     \textcolor{keyword}{private}:}
\DoxyCodeLine{6201         \textcolor{keywordtype}{bool} m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{6202     \};}
\DoxyCodeLine{6203 }
\DoxyCodeLine{6204 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6205 }
\DoxyCodeLine{6206 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6207 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{6208 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6209 }
\DoxyCodeLine{6210 \textcolor{comment}{// end catch\_reporter\_console.h}}
\DoxyCodeLine{6211 \textcolor{comment}{// start catch\_reporter\_junit.h}}
\DoxyCodeLine{6212 }
\DoxyCodeLine{6213 \textcolor{comment}{// start catch\_xmlwriter.h}}
\DoxyCodeLine{6214 }
\DoxyCodeLine{6215 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6216 }
\DoxyCodeLine{6217 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6218     \textcolor{keyword}{enum class} XmlFormatting \{}
\DoxyCodeLine{6219         None = 0x00,}
\DoxyCodeLine{6220         Indent = 0x01,}
\DoxyCodeLine{6221         Newline = 0x02,}
\DoxyCodeLine{6222     \};}
\DoxyCodeLine{6223 }
\DoxyCodeLine{6224     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6225     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs);}
\DoxyCodeLine{6226 }
\DoxyCodeLine{6227     \textcolor{keyword}{class }XmlEncode \{}
\DoxyCodeLine{6228     \textcolor{keyword}{public}:}
\DoxyCodeLine{6229         \textcolor{keyword}{enum} ForWhat \{ ForTextNodes, ForAttributes \};}
\DoxyCodeLine{6230 }
\DoxyCodeLine{6231         XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat = ForTextNodes );}
\DoxyCodeLine{6232 }
\DoxyCodeLine{6233         \textcolor{keywordtype}{void} encodeTo( std::ostream\& os ) \textcolor{keyword}{const};}
\DoxyCodeLine{6234 }
\DoxyCodeLine{6235         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode );}
\DoxyCodeLine{6236 }
\DoxyCodeLine{6237     \textcolor{keyword}{private}:}
\DoxyCodeLine{6238         std::string m\_str;}
\DoxyCodeLine{6239         ForWhat m\_forWhat;}
\DoxyCodeLine{6240     \};}
\DoxyCodeLine{6241 }
\DoxyCodeLine{6242     \textcolor{keyword}{class }XmlWriter \{}
\DoxyCodeLine{6243     \textcolor{keyword}{public}:}
\DoxyCodeLine{6244 }
\DoxyCodeLine{6245         \textcolor{keyword}{class }ScopedElement \{}
\DoxyCodeLine{6246         \textcolor{keyword}{public}:}
\DoxyCodeLine{6247             ScopedElement( XmlWriter* writer, XmlFormatting fmt );}
\DoxyCodeLine{6248 }
\DoxyCodeLine{6249             ScopedElement( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6250             ScopedElement\& operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{6251 }
\DoxyCodeLine{6252             \string~ScopedElement();}
\DoxyCodeLine{6253 }
\DoxyCodeLine{6254             ScopedElement\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );}
\DoxyCodeLine{6255 }
\DoxyCodeLine{6256             \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6257             ScopedElement\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6258                 m\_writer-\/>writeAttribute( name, attribute );}
\DoxyCodeLine{6259                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6260             \}}
\DoxyCodeLine{6261 }
\DoxyCodeLine{6262         \textcolor{keyword}{private}:}
\DoxyCodeLine{6263             \textcolor{keyword}{mutable} XmlWriter* m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{6264             XmlFormatting m\_fmt;}
\DoxyCodeLine{6265         \};}
\DoxyCodeLine{6266 }
\DoxyCodeLine{6267         XmlWriter( std::ostream\& os = Catch::cout() );}
\DoxyCodeLine{6268         \string~XmlWriter();}
\DoxyCodeLine{6269 }
\DoxyCodeLine{6270         XmlWriter( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6271         XmlWriter\& operator=( XmlWriter \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{6272 }
\DoxyCodeLine{6273         XmlWriter\& startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6274 }
\DoxyCodeLine{6275         ScopedElement scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6276 }
\DoxyCodeLine{6277         XmlWriter\& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6278 }
\DoxyCodeLine{6279         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute );}
\DoxyCodeLine{6280 }
\DoxyCodeLine{6281         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute );}
\DoxyCodeLine{6282 }
\DoxyCodeLine{6283         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6284         XmlWriter\& writeAttribute( std::string \textcolor{keyword}{const}\& name, T \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{6285             ReusableStringStream rss;}
\DoxyCodeLine{6286             rss << attribute;}
\DoxyCodeLine{6287             \textcolor{keywordflow}{return} writeAttribute( name, rss.str() );}
\DoxyCodeLine{6288         \}}
\DoxyCodeLine{6289 }
\DoxyCodeLine{6290         XmlWriter\& writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6291 }
\DoxyCodeLine{6292         XmlWriter\& writeComment(std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);}
\DoxyCodeLine{6293 }
\DoxyCodeLine{6294         \textcolor{keywordtype}{void} writeStylesheetRef( std::string \textcolor{keyword}{const}\& url );}
\DoxyCodeLine{6295 }
\DoxyCodeLine{6296         XmlWriter\& writeBlankLine();}
\DoxyCodeLine{6297 }
\DoxyCodeLine{6298         \textcolor{keywordtype}{void} ensureTagClosed();}
\DoxyCodeLine{6299 }
\DoxyCodeLine{6300     \textcolor{keyword}{private}:}
\DoxyCodeLine{6301 }
\DoxyCodeLine{6302         \textcolor{keywordtype}{void} applyFormatting(XmlFormatting fmt);}
\DoxyCodeLine{6303 }
\DoxyCodeLine{6304         \textcolor{keywordtype}{void} writeDeclaration();}
\DoxyCodeLine{6305 }
\DoxyCodeLine{6306         \textcolor{keywordtype}{void} newlineIfNecessary();}
\DoxyCodeLine{6307 }
\DoxyCodeLine{6308         \textcolor{keywordtype}{bool} m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{6309         \textcolor{keywordtype}{bool} m\_needsNewline = \textcolor{keyword}{false};}
\DoxyCodeLine{6310         std::vector<std::string> m\_tags;}
\DoxyCodeLine{6311         std::string m\_indent;}
\DoxyCodeLine{6312         std::ostream\& m\_os;}
\DoxyCodeLine{6313     \};}
\DoxyCodeLine{6314 }
\DoxyCodeLine{6315 \}}
\DoxyCodeLine{6316 }
\DoxyCodeLine{6317 \textcolor{comment}{// end catch\_xmlwriter.h}}
\DoxyCodeLine{6318 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6319 }
\DoxyCodeLine{6320     \textcolor{keyword}{class }JunitReporter : \textcolor{keyword}{public} CumulativeReporterBase<JunitReporter> \{}
\DoxyCodeLine{6321     \textcolor{keyword}{public}:}
\DoxyCodeLine{6322         JunitReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6323 }
\DoxyCodeLine{6324         \string~JunitReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6325 }
\DoxyCodeLine{6326         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6327 }
\DoxyCodeLine{6328         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/}) \textcolor{keyword}{override};}
\DoxyCodeLine{6329 }
\DoxyCodeLine{6330         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& runInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6331 }
\DoxyCodeLine{6332         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6333 }
\DoxyCodeLine{6334         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6335         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6336 }
\DoxyCodeLine{6337         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6338 }
\DoxyCodeLine{6339         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6340 }
\DoxyCodeLine{6341         \textcolor{keywordtype}{void} testRunEndedCumulative() \textcolor{keyword}{override};}
\DoxyCodeLine{6342 }
\DoxyCodeLine{6343         \textcolor{keywordtype}{void} writeGroup(TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime);}
\DoxyCodeLine{6344 }
\DoxyCodeLine{6345         \textcolor{keywordtype}{void} writeTestCase(TestCaseNode \textcolor{keyword}{const}\& testCaseNode);}
\DoxyCodeLine{6346 }
\DoxyCodeLine{6347         \textcolor{keywordtype}{void} writeSection( std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{6348                            std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{6349                            SectionNode \textcolor{keyword}{const}\& sectionNode,}
\DoxyCodeLine{6350                            \textcolor{keywordtype}{bool} testOkToFail );}
\DoxyCodeLine{6351 }
\DoxyCodeLine{6352         \textcolor{keywordtype}{void} writeAssertions(SectionNode \textcolor{keyword}{const}\& sectionNode);}
\DoxyCodeLine{6353         \textcolor{keywordtype}{void} writeAssertion(AssertionStats \textcolor{keyword}{const}\& stats);}
\DoxyCodeLine{6354 }
\DoxyCodeLine{6355         XmlWriter xml;}
\DoxyCodeLine{6356         Timer suiteTimer;}
\DoxyCodeLine{6357         std::string stdOutForSuite;}
\DoxyCodeLine{6358         std::string stdErrForSuite;}
\DoxyCodeLine{6359         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} unexpectedExceptions = 0;}
\DoxyCodeLine{6360         \textcolor{keywordtype}{bool} m\_okToFail = \textcolor{keyword}{false};}
\DoxyCodeLine{6361     \};}
\DoxyCodeLine{6362 }
\DoxyCodeLine{6363 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6364 }
\DoxyCodeLine{6365 \textcolor{comment}{// end catch\_reporter\_junit.h}}
\DoxyCodeLine{6366 \textcolor{comment}{// start catch\_reporter\_xml.h}}
\DoxyCodeLine{6367 }
\DoxyCodeLine{6368 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6369     \textcolor{keyword}{class }XmlReporter : \textcolor{keyword}{public} StreamingReporterBase<XmlReporter> \{}
\DoxyCodeLine{6370     \textcolor{keyword}{public}:}
\DoxyCodeLine{6371         XmlReporter(ReporterConfig \textcolor{keyword}{const}\& \_config);}
\DoxyCodeLine{6372 }
\DoxyCodeLine{6373         \string~XmlReporter() \textcolor{keyword}{override};}
\DoxyCodeLine{6374 }
\DoxyCodeLine{6375         \textcolor{keyword}{static} std::string getDescription();}
\DoxyCodeLine{6376 }
\DoxyCodeLine{6377         \textcolor{keyword}{virtual} std::string getStylesheetRef() \textcolor{keyword}{const};}
\DoxyCodeLine{6378 }
\DoxyCodeLine{6379         \textcolor{keywordtype}{void} writeSourceInfo(SourceLineInfo \textcolor{keyword}{const}\& sourceInfo);}
\DoxyCodeLine{6380 }
\DoxyCodeLine{6381     \textcolor{keyword}{public}: \textcolor{comment}{// StreamingReporterBase}}
\DoxyCodeLine{6382 }
\DoxyCodeLine{6383         \textcolor{keywordtype}{void} noMatchingTestCases(std::string \textcolor{keyword}{const}\& s) \textcolor{keyword}{override};}
\DoxyCodeLine{6384 }
\DoxyCodeLine{6385         \textcolor{keywordtype}{void} testRunStarting(TestRunInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6386 }
\DoxyCodeLine{6387         \textcolor{keywordtype}{void} testGroupStarting(GroupInfo \textcolor{keyword}{const}\& groupInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6388 }
\DoxyCodeLine{6389         \textcolor{keywordtype}{void} testCaseStarting(TestCaseInfo \textcolor{keyword}{const}\& testInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6390 }
\DoxyCodeLine{6391         \textcolor{keywordtype}{void} sectionStarting(SectionInfo \textcolor{keyword}{const}\& sectionInfo) \textcolor{keyword}{override};}
\DoxyCodeLine{6392 }
\DoxyCodeLine{6393         \textcolor{keywordtype}{void} assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6394 }
\DoxyCodeLine{6395         \textcolor{keywordtype}{bool} assertionEnded(AssertionStats \textcolor{keyword}{const}\& assertionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6396 }
\DoxyCodeLine{6397         \textcolor{keywordtype}{void} sectionEnded(SectionStats \textcolor{keyword}{const}\& sectionStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6398 }
\DoxyCodeLine{6399         \textcolor{keywordtype}{void} testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& testCaseStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6400 }
\DoxyCodeLine{6401         \textcolor{keywordtype}{void} testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& testGroupStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6402 }
\DoxyCodeLine{6403         \textcolor{keywordtype}{void} testRunEnded(TestRunStats \textcolor{keyword}{const}\& testRunStats) \textcolor{keyword}{override};}
\DoxyCodeLine{6404 }
\DoxyCodeLine{6405 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6406         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{6407         \textcolor{keywordtype}{void} benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6408         \textcolor{keywordtype}{void} benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6409         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{6410 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{6411 }
\DoxyCodeLine{6412     \textcolor{keyword}{private}:}
\DoxyCodeLine{6413         Timer m\_testCaseTimer;}
\DoxyCodeLine{6414         XmlWriter m\_xml;}
\DoxyCodeLine{6415         \textcolor{keywordtype}{int} m\_sectionDepth = 0;}
\DoxyCodeLine{6416     \};}
\DoxyCodeLine{6417 }
\DoxyCodeLine{6418 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{6419 }
\DoxyCodeLine{6420 \textcolor{comment}{// end catch\_reporter\_xml.h}}
\DoxyCodeLine{6421 }
\DoxyCodeLine{6422 \textcolor{comment}{// end catch\_external\_interfaces.h}}
\DoxyCodeLine{6423 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6424 }
\DoxyCodeLine{6425 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{6426 \textcolor{comment}{// start catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{6427 }
\DoxyCodeLine{6428 \textcolor{comment}{// A proxy header that includes all of the benchmarking headers to allow}}
\DoxyCodeLine{6429 \textcolor{comment}{// concise include of the benchmarking features. You should prefer the}}
\DoxyCodeLine{6430 \textcolor{comment}{// individual includes in standard use.}}
\DoxyCodeLine{6431 }
\DoxyCodeLine{6432 \textcolor{comment}{// start catch\_benchmark.hpp}}
\DoxyCodeLine{6433 }
\DoxyCodeLine{6434  \textcolor{comment}{// Benchmark}}
\DoxyCodeLine{6435 }
\DoxyCodeLine{6436 \textcolor{comment}{// start catch\_chronometer.hpp}}
\DoxyCodeLine{6437 }
\DoxyCodeLine{6438 \textcolor{comment}{// User-\/facing chronometer}}
\DoxyCodeLine{6439 }
\DoxyCodeLine{6440 }
\DoxyCodeLine{6441 \textcolor{comment}{// start catch\_clock.hpp}}
\DoxyCodeLine{6442 }
\DoxyCodeLine{6443 \textcolor{comment}{// Clocks}}
\DoxyCodeLine{6444 }
\DoxyCodeLine{6445 }
\DoxyCodeLine{6446 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{6447 \textcolor{preprocessor}{\#include <ratio>}}
\DoxyCodeLine{6448 }
\DoxyCodeLine{6449 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6450     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6451         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6452         \textcolor{keyword}{using} ClockDuration = \textcolor{keyword}{typename} Clock::duration;}
\DoxyCodeLine{6453         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6454         \textcolor{keyword}{using} FloatDuration = std::chrono::duration<double, typename Clock::period>;}
\DoxyCodeLine{6455 }
\DoxyCodeLine{6456         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6457         \textcolor{keyword}{using} TimePoint = \textcolor{keyword}{typename} Clock::time\_point;}
\DoxyCodeLine{6458 }
\DoxyCodeLine{6459         \textcolor{keyword}{using} default\_clock = std::chrono::steady\_clock;}
\DoxyCodeLine{6460 }
\DoxyCodeLine{6461         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6462         \textcolor{keyword}{struct }now \{}
\DoxyCodeLine{6463             TimePoint<Clock> operator()()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6464                 \textcolor{keywordflow}{return} Clock::now();}
\DoxyCodeLine{6465             \}}
\DoxyCodeLine{6466         \};}
\DoxyCodeLine{6467 }
\DoxyCodeLine{6468         \textcolor{keyword}{using} fp\_seconds = std::chrono::duration<double, std::ratio<1>>;}
\DoxyCodeLine{6469     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6470 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6471 }
\DoxyCodeLine{6472 \textcolor{comment}{// end catch\_clock.hpp}}
\DoxyCodeLine{6473 \textcolor{comment}{// start catch\_optimizer.hpp}}
\DoxyCodeLine{6474 }
\DoxyCodeLine{6475  \textcolor{comment}{// Hinting the optimizer}}
\DoxyCodeLine{6476 }
\DoxyCodeLine{6477 }
\DoxyCodeLine{6478 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{6479 \textcolor{preprocessor}{\#   include <atomic>} \textcolor{comment}{// atomic\_thread\_fence}}
\DoxyCodeLine{6480 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6481 }
\DoxyCodeLine{6482 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6483     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6484 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{6485         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6486         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6487             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : \textcolor{stringliteral}{"{}g"{}}(p) : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6488         \}}
\DoxyCodeLine{6489         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory() \{}
\DoxyCodeLine{6490             \textcolor{keyword}{asm} \textcolor{keyword}{volatile}(\textcolor{stringliteral}{"{}"{}} : : : \textcolor{stringliteral}{"{}memory"{}});}
\DoxyCodeLine{6491         \}}
\DoxyCodeLine{6492 }
\DoxyCodeLine{6493         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6494             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{ keep\_memory(); \}}
\DoxyCodeLine{6495         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6496 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{6497 }
\DoxyCodeLine{6498 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, off)}
\DoxyCodeLine{6499         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6500         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} keep\_memory(T* p) \{}
\DoxyCodeLine{6501             \textcolor{comment}{// thanks @milleniumbug}}
\DoxyCodeLine{6502             *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} volatile*\textcolor{keyword}{>}(p) = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} \textcolor{keyword}{const }volatile*\textcolor{keyword}{>}(p);}
\DoxyCodeLine{6503         \}}
\DoxyCodeLine{6504         \textcolor{comment}{// TODO equivalent keep\_memory()}}
\DoxyCodeLine{6505 \textcolor{preprocessor}{\#pragma optimize("{}"{}}, on)}
\DoxyCodeLine{6506 }
\DoxyCodeLine{6507         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6508             \textcolor{keyword}{inline} \textcolor{keywordtype}{void} optimizer\_barrier() \{}
\DoxyCodeLine{6509                 std::atomic\_thread\_fence(std::memory\_order\_seq\_cst);}
\DoxyCodeLine{6510             \}}
\DoxyCodeLine{6511         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6512 }
\DoxyCodeLine{6513 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{6514 }
\DoxyCodeLine{6515         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6516         \textcolor{keyword}{inline} \textcolor{keywordtype}{void} deoptimize\_value(T\&\& x) \{}
\DoxyCodeLine{6517             keep\_memory(\&x);}
\DoxyCodeLine{6518         \}}
\DoxyCodeLine{6519 }
\DoxyCodeLine{6520         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6521         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<!std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6522             deoptimize\_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));}
\DoxyCodeLine{6523         \}}
\DoxyCodeLine{6524 }
\DoxyCodeLine{6525         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fn, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6526         \textcolor{keyword}{inline} \textcolor{keyword}{auto} invoke\_deoptimized(Fn\&\& fn, Args\&\&... args) -\/> \textcolor{keyword}{typename} std::enable\_if<std::is\_same<void, \textcolor{keyword}{decltype}(fn(args...))>::value>::type \{}
\DoxyCodeLine{6527             std::forward<Fn>(fn) (std::forward<Args...>(args...));}
\DoxyCodeLine{6528         \}}
\DoxyCodeLine{6529     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6530 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6531 }
\DoxyCodeLine{6532 \textcolor{comment}{// end catch\_optimizer.hpp}}
\DoxyCodeLine{6533 \textcolor{comment}{// start catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6534 }
\DoxyCodeLine{6535 \textcolor{comment}{// Invoke with a special case for void}}
\DoxyCodeLine{6536 }
\DoxyCodeLine{6537 }
\DoxyCodeLine{6538 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6539 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6540 }
\DoxyCodeLine{6541 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6542     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6543         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6544             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6545             \textcolor{keyword}{struct }CompleteType \{ \textcolor{keyword}{using} type = T; \};}
\DoxyCodeLine{6546             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6547             \textcolor{keyword}{struct }CompleteType<void> \{ \textcolor{keyword}{struct }type \{\}; \};}
\DoxyCodeLine{6548 }
\DoxyCodeLine{6549             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6550             \textcolor{keyword}{using} CompleteType\_t = \textcolor{keyword}{typename} CompleteType<T>::type;}
\DoxyCodeLine{6551 }
\DoxyCodeLine{6552             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6553             \textcolor{keyword}{struct }CompleteInvoker \{}
\DoxyCodeLine{6554                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6555                 \textcolor{keyword}{static} Result invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6556                     \textcolor{keywordflow}{return} std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6557                 \}}
\DoxyCodeLine{6558             \};}
\DoxyCodeLine{6559             \textcolor{keyword}{template} <>}
\DoxyCodeLine{6560             \textcolor{keyword}{struct }CompleteInvoker<void> \{}
\DoxyCodeLine{6561                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6562                 \textcolor{keyword}{static} CompleteType\_t<void> invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6563                     std::forward<Fun>(fun)(std::forward<Args>(args)...);}
\DoxyCodeLine{6564                     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{6565                 \}}
\DoxyCodeLine{6566             \};}
\DoxyCodeLine{6567 }
\DoxyCodeLine{6568             \textcolor{comment}{// invoke and not return void :(}}
\DoxyCodeLine{6569             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6570             CompleteType\_t<FunctionReturnType<Fun, Args...>> complete\_invoke(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6571                 \textcolor{keywordflow}{return} CompleteInvoker<FunctionReturnType<Fun, Args...>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);}
\DoxyCodeLine{6572             \}}
\DoxyCodeLine{6573 }
\DoxyCodeLine{6574             \textcolor{keyword}{const} std::string benchmarkErrorMsg = \textcolor{stringliteral}{"{}a benchmark failed to run successfully"{}};}
\DoxyCodeLine{6575         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6576 }
\DoxyCodeLine{6577         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6578         Detail::CompleteType\_t<FunctionReturnType<Fun>> user\_code(Fun\&\& fun) \{}
\DoxyCodeLine{6579             CATCH\_TRY\{}
\DoxyCodeLine{6580                 \textcolor{keywordflow}{return} Detail::complete\_invoke(std::forward<Fun>(fun));}
\DoxyCodeLine{6581             \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{6582                 getResultCapture().benchmarkFailed(translateActiveException());}
\DoxyCodeLine{6583                 CATCH\_RUNTIME\_ERROR(Detail::benchmarkErrorMsg);}
\DoxyCodeLine{6584             \}}
\DoxyCodeLine{6585         \}}
\DoxyCodeLine{6586     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6587 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6588 }
\DoxyCodeLine{6589 \textcolor{comment}{// end catch\_complete\_invoke.hpp}}
\DoxyCodeLine{6590 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6591     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6592         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6593             \textcolor{keyword}{struct }ChronometerConcept \{}
\DoxyCodeLine{6594                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} start() = 0;}
\DoxyCodeLine{6595                 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} finish() = 0;}
\DoxyCodeLine{6596                 \textcolor{keyword}{virtual} \string~ChronometerConcept() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6597             \};}
\DoxyCodeLine{6598             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6599             \textcolor{keyword}{struct }ChronometerModel final : \textcolor{keyword}{public} ChronometerConcept \{}
\DoxyCodeLine{6600                 \textcolor{keywordtype}{void} start()\textcolor{keyword}{ override }\{ started = Clock::now(); \}}
\DoxyCodeLine{6601                 \textcolor{keywordtype}{void} finish()\textcolor{keyword}{ override }\{ finished = Clock::now(); \}}
\DoxyCodeLine{6602 }
\DoxyCodeLine{6603                 ClockDuration<Clock> elapsed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} finished -\/ started; \}}
\DoxyCodeLine{6604 }
\DoxyCodeLine{6605                 TimePoint<Clock> started;}
\DoxyCodeLine{6606                 TimePoint<Clock> finished;}
\DoxyCodeLine{6607             \};}
\DoxyCodeLine{6608         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6609 }
\DoxyCodeLine{6610         \textcolor{keyword}{struct }Chronometer \{}
\DoxyCodeLine{6611         \textcolor{keyword}{public}:}
\DoxyCodeLine{6612             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6613             \textcolor{keywordtype}{void} measure(Fun\&\& fun) \{ measure(std::forward<Fun>(fun), is\_callable<Fun(\textcolor{keywordtype}{int})>()); \}}
\DoxyCodeLine{6614 }
\DoxyCodeLine{6615             \textcolor{keywordtype}{int} runs()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} k; \}}
\DoxyCodeLine{6616 }
\DoxyCodeLine{6617             Chronometer(Detail::ChronometerConcept\& meter, \textcolor{keywordtype}{int} k)}
\DoxyCodeLine{6618                 : impl(\&meter)}
\DoxyCodeLine{6619                 , k(k) \{\}}
\DoxyCodeLine{6620 }
\DoxyCodeLine{6621         \textcolor{keyword}{private}:}
\DoxyCodeLine{6622             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6623             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::false\_type) \{}
\DoxyCodeLine{6624                 measure([\&fun](\textcolor{keywordtype}{int}) \{ \textcolor{keywordflow}{return} fun(); \}, std::true\_type());}
\DoxyCodeLine{6625             \}}
\DoxyCodeLine{6626 }
\DoxyCodeLine{6627             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6628             \textcolor{keywordtype}{void} measure(Fun\&\& fun, std::true\_type) \{}
\DoxyCodeLine{6629                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6630                 impl-\/>start();}
\DoxyCodeLine{6631                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) invoke\_deoptimized(fun, i);}
\DoxyCodeLine{6632                 impl-\/>finish();}
\DoxyCodeLine{6633                 Detail::optimizer\_barrier();}
\DoxyCodeLine{6634             \}}
\DoxyCodeLine{6635 }
\DoxyCodeLine{6636             Detail::ChronometerConcept* impl;}
\DoxyCodeLine{6637             \textcolor{keywordtype}{int} k;}
\DoxyCodeLine{6638         \};}
\DoxyCodeLine{6639     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6640 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6641 }
\DoxyCodeLine{6642 \textcolor{comment}{// end catch\_chronometer.hpp}}
\DoxyCodeLine{6643 \textcolor{comment}{// start catch\_environment.hpp}}
\DoxyCodeLine{6644 }
\DoxyCodeLine{6645 \textcolor{comment}{// Environment information}}
\DoxyCodeLine{6646 }
\DoxyCodeLine{6647 }
\DoxyCodeLine{6648 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6649     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6650         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6651         \textcolor{keyword}{struct }EnvironmentEstimate \{}
\DoxyCodeLine{6652             Duration mean;}
\DoxyCodeLine{6653             OutlierClassification outliers;}
\DoxyCodeLine{6654 }
\DoxyCodeLine{6655             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6656             \textcolor{keyword}{operator} EnvironmentEstimate<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6657                 \textcolor{keywordflow}{return} \{ mean, outliers \};}
\DoxyCodeLine{6658             \}}
\DoxyCodeLine{6659         \};}
\DoxyCodeLine{6660         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6661         \textcolor{keyword}{struct }Environment \{}
\DoxyCodeLine{6662             \textcolor{keyword}{using} clock\_type = Clock;}
\DoxyCodeLine{6663             EnvironmentEstimate<FloatDuration<Clock>> clock\_resolution;}
\DoxyCodeLine{6664             EnvironmentEstimate<FloatDuration<Clock>> clock\_cost;}
\DoxyCodeLine{6665         \};}
\DoxyCodeLine{6666     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6667 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6668 }
\DoxyCodeLine{6669 \textcolor{comment}{// end catch\_environment.hpp}}
\DoxyCodeLine{6670 \textcolor{comment}{// start catch\_execution\_plan.hpp}}
\DoxyCodeLine{6671 }
\DoxyCodeLine{6672  \textcolor{comment}{// Execution plan}}
\DoxyCodeLine{6673 }
\DoxyCodeLine{6674 }
\DoxyCodeLine{6675 \textcolor{comment}{// start catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6676 }
\DoxyCodeLine{6677  \textcolor{comment}{// Dumb std::function implementation for consistent call overhead}}
\DoxyCodeLine{6678 }
\DoxyCodeLine{6679 }
\DoxyCodeLine{6680 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{6681 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6682 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6683 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{6684 }
\DoxyCodeLine{6685 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6686     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6687         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6688             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6689             \textcolor{keyword}{using} Decay = \textcolor{keyword}{typename} std::decay<T>::type;}
\DoxyCodeLine{6690             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U>}
\DoxyCodeLine{6691             \textcolor{keyword}{struct }is\_related}
\DoxyCodeLine{6692                 : std::is\_same<Decay<T>, Decay<U>> \{\};}
\DoxyCodeLine{6693 }
\DoxyCodeLine{6701             \textcolor{keyword}{struct }BenchmarkFunction \{}
\DoxyCodeLine{6702             \textcolor{keyword}{private}:}
\DoxyCodeLine{6703                 \textcolor{keyword}{struct }callable \{}
\DoxyCodeLine{6704                     \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} call(Chronometer meter) \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6705                     \textcolor{keyword}{virtual} callable* clone() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{6706                     \textcolor{keyword}{virtual} \string~callable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{6707                 \};}
\DoxyCodeLine{6708                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6709                 \textcolor{keyword}{struct }model : \textcolor{keyword}{public} callable \{}
\DoxyCodeLine{6710                     model(Fun\&\& fun) : fun(std::move(fun)) \{\}}
\DoxyCodeLine{6711                     model(Fun \textcolor{keyword}{const}\& fun) : fun(fun) \{\}}
\DoxyCodeLine{6712 }
\DoxyCodeLine{6713                     model<Fun>* clone()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{new} model<Fun>(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{6714 }
\DoxyCodeLine{6715                     \textcolor{keywordtype}{void} call(Chronometer meter)\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{6716                         call(meter, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6717                     \}}
\DoxyCodeLine{6718                     \textcolor{keywordtype}{void} call(Chronometer meter, std::true\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6719                         fun(meter);}
\DoxyCodeLine{6720                     \}}
\DoxyCodeLine{6721                     \textcolor{keywordtype}{void} call(Chronometer meter, std::false\_type)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6722                         meter.measure(fun);}
\DoxyCodeLine{6723                     \}}
\DoxyCodeLine{6724 }
\DoxyCodeLine{6725                     Fun fun;}
\DoxyCodeLine{6726                 \};}
\DoxyCodeLine{6727 }
\DoxyCodeLine{6728                 \textcolor{keyword}{struct }do\_nothing \{ \textcolor{keywordtype}{void} operator()()\textcolor{keyword}{ const }\{\} \};}
\DoxyCodeLine{6729 }
\DoxyCodeLine{6730                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{6731                 BenchmarkFunction(model<T>* c) : f(c) \{\}}
\DoxyCodeLine{6732 }
\DoxyCodeLine{6733             \textcolor{keyword}{public}:}
\DoxyCodeLine{6734                 BenchmarkFunction()}
\DoxyCodeLine{6735                     : f(new model<do\_nothing>\{ \{\} \}) \{\}}
\DoxyCodeLine{6736 }
\DoxyCodeLine{6737                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{6738                     \textcolor{keyword}{typename} std::enable\_if<!is\_related<Fun, BenchmarkFunction>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{6739                     BenchmarkFunction(Fun\&\& fun)}
\DoxyCodeLine{6740                     : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) \{\}}
\DoxyCodeLine{6741 }
\DoxyCodeLine{6742                 BenchmarkFunction(BenchmarkFunction\&\& that)}
\DoxyCodeLine{6743                     : f(std::move(that.f)) \{\}}
\DoxyCodeLine{6744 }
\DoxyCodeLine{6745                 BenchmarkFunction(BenchmarkFunction \textcolor{keyword}{const}\& that)}
\DoxyCodeLine{6746                     : f(that.f-\/>clone()) \{\}}
\DoxyCodeLine{6747 }
\DoxyCodeLine{6748                 BenchmarkFunction\& operator=(BenchmarkFunction\&\& that) \{}
\DoxyCodeLine{6749                     f = std::move(that.f);}
\DoxyCodeLine{6750                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6751                 \}}
\DoxyCodeLine{6752 }
\DoxyCodeLine{6753                 BenchmarkFunction\& operator=(BenchmarkFunction \textcolor{keyword}{const}\& that) \{}
\DoxyCodeLine{6754                     f.reset(that.f-\/>clone());}
\DoxyCodeLine{6755                     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{6756                 \}}
\DoxyCodeLine{6757 }
\DoxyCodeLine{6758                 \textcolor{keywordtype}{void} operator()(Chronometer meter)\textcolor{keyword}{ const }\{ f-\/>call(meter); \}}
\DoxyCodeLine{6759 }
\DoxyCodeLine{6760             \textcolor{keyword}{private}:}
\DoxyCodeLine{6761                 std::unique\_ptr<callable> f;}
\DoxyCodeLine{6762             \};}
\DoxyCodeLine{6763         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6764     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6765 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6766 }
\DoxyCodeLine{6767 \textcolor{comment}{// end catch\_benchmark\_function.hpp}}
\DoxyCodeLine{6768 \textcolor{comment}{// start catch\_repeat.hpp}}
\DoxyCodeLine{6769 }
\DoxyCodeLine{6770 \textcolor{comment}{// repeat algorithm}}
\DoxyCodeLine{6771 }
\DoxyCodeLine{6772 }
\DoxyCodeLine{6773 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6774 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6775 }
\DoxyCodeLine{6776 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6777     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6778         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6779             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6780             \textcolor{keyword}{struct }repeater \{}
\DoxyCodeLine{6781                 \textcolor{keywordtype}{void} operator()(\textcolor{keywordtype}{int} k)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6782                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{6783                         fun();}
\DoxyCodeLine{6784                     \}}
\DoxyCodeLine{6785                 \}}
\DoxyCodeLine{6786                 Fun fun;}
\DoxyCodeLine{6787             \};}
\DoxyCodeLine{6788             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6789             repeater<typename std::decay<Fun>::type> repeat(Fun\&\& fun) \{}
\DoxyCodeLine{6790                 \textcolor{keywordflow}{return} \{ std::forward<Fun>(fun) \};}
\DoxyCodeLine{6791             \}}
\DoxyCodeLine{6792         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6793     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6794 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6795 }
\DoxyCodeLine{6796 \textcolor{comment}{// end catch\_repeat.hpp}}
\DoxyCodeLine{6797 \textcolor{comment}{// start catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6798 }
\DoxyCodeLine{6799 \textcolor{comment}{// Run a function for a minimum amount of time}}
\DoxyCodeLine{6800 }
\DoxyCodeLine{6801 }
\DoxyCodeLine{6802 \textcolor{comment}{// start catch\_measure.hpp}}
\DoxyCodeLine{6803 }
\DoxyCodeLine{6804 \textcolor{comment}{// Measure}}
\DoxyCodeLine{6805 }
\DoxyCodeLine{6806 }
\DoxyCodeLine{6807 \textcolor{comment}{// start catch\_timing.hpp}}
\DoxyCodeLine{6808 }
\DoxyCodeLine{6809 \textcolor{comment}{// Timing}}
\DoxyCodeLine{6810 }
\DoxyCodeLine{6811 }
\DoxyCodeLine{6812 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6813 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6814 }
\DoxyCodeLine{6815 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6816     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6817         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Result>}
\DoxyCodeLine{6818         \textcolor{keyword}{struct }Timing \{}
\DoxyCodeLine{6819             Duration elapsed;}
\DoxyCodeLine{6820             Result result;}
\DoxyCodeLine{6821             \textcolor{keywordtype}{int} iterations;}
\DoxyCodeLine{6822         \};}
\DoxyCodeLine{6823         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Func, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6824         \textcolor{keyword}{using} TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType\_t<FunctionReturnType<Func, Args...>>>;}
\DoxyCodeLine{6825     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6826 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6827 }
\DoxyCodeLine{6828 \textcolor{comment}{// end catch\_timing.hpp}}
\DoxyCodeLine{6829 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6830 }
\DoxyCodeLine{6831 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6832     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6833         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6834             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{6835             TimingOf<Clock, Fun, Args...> measure(Fun\&\& fun, Args\&\&... args) \{}
\DoxyCodeLine{6836                 \textcolor{keyword}{auto} start = Clock::now();}
\DoxyCodeLine{6837                 \textcolor{keyword}{auto}\&\& r = Detail::complete\_invoke(fun, std::forward<Args>(args)...);}
\DoxyCodeLine{6838                 \textcolor{keyword}{auto} end = Clock::now();}
\DoxyCodeLine{6839                 \textcolor{keyword}{auto} delta = end -\/ start;}
\DoxyCodeLine{6840                 \textcolor{keywordflow}{return} \{ delta, std::forward<decltype(r)>(r), 1 \};}
\DoxyCodeLine{6841             \}}
\DoxyCodeLine{6842         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6843     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6844 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6845 }
\DoxyCodeLine{6846 \textcolor{comment}{// end catch\_measure.hpp}}
\DoxyCodeLine{6847 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6848 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{6849 }
\DoxyCodeLine{6850 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6851     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6852         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6853             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6854             TimingOf<Clock, Fun, int> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::false\_type) \{}
\DoxyCodeLine{6855                 \textcolor{keywordflow}{return} Detail::measure<Clock>(fun, iters);}
\DoxyCodeLine{6856             \}}
\DoxyCodeLine{6857             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6858             TimingOf<Clock, Fun, Chronometer> measure\_one(Fun\&\& fun, \textcolor{keywordtype}{int} iters, std::true\_type) \{}
\DoxyCodeLine{6859                 Detail::ChronometerModel<Clock> meter;}
\DoxyCodeLine{6860                 \textcolor{keyword}{auto}\&\& result = Detail::complete\_invoke(fun, Chronometer(meter, iters));}
\DoxyCodeLine{6861 }
\DoxyCodeLine{6862                 \textcolor{keywordflow}{return} \{ meter.elapsed(), std::move(result), iters \};}
\DoxyCodeLine{6863             \}}
\DoxyCodeLine{6864 }
\DoxyCodeLine{6865             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6866             \textcolor{keyword}{using} run\_for\_at\_least\_argument\_t = \textcolor{keyword}{typename} std::conditional<is\_callable<Fun(Chronometer)>::value, Chronometer, \textcolor{keywordtype}{int}>::type;}
\DoxyCodeLine{6867 }
\DoxyCodeLine{6868             \textcolor{keyword}{struct }optimized\_away\_error : std::exception \{}
\DoxyCodeLine{6869                 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* what() const noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{6870                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}could not measure benchmark, maybe it was optimized away"{}};}
\DoxyCodeLine{6871                 \}}
\DoxyCodeLine{6872             \};}
\DoxyCodeLine{6873 }
\DoxyCodeLine{6874             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock, \textcolor{keyword}{typename} Fun>}
\DoxyCodeLine{6875             TimingOf<Clock, Fun, run\_for\_at\_least\_argument\_t<Clock, Fun>> run\_for\_at\_least(ClockDuration<Clock> how\_long, \textcolor{keywordtype}{int} seed, Fun\&\& fun) \{}
\DoxyCodeLine{6876                 \textcolor{keyword}{auto} iters = seed;}
\DoxyCodeLine{6877                 \textcolor{keywordflow}{while} (iters < (1 << 30)) \{}
\DoxyCodeLine{6878                     \textcolor{keyword}{auto}\&\& Timing = measure\_one<Clock>(fun, iters, is\_callable<Fun(Chronometer)>());}
\DoxyCodeLine{6879 }
\DoxyCodeLine{6880                     \textcolor{keywordflow}{if} (Timing.elapsed >= how\_long) \{}
\DoxyCodeLine{6881                         \textcolor{keywordflow}{return} \{ Timing.elapsed, std::move(Timing.result), iters \};}
\DoxyCodeLine{6882                     \}}
\DoxyCodeLine{6883                     iters *= 2;}
\DoxyCodeLine{6884                 \}}
\DoxyCodeLine{6885                 Catch::throw\_exception(optimized\_away\_error\{\});}
\DoxyCodeLine{6886             \}}
\DoxyCodeLine{6887         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{6888     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6889 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6890 }
\DoxyCodeLine{6891 \textcolor{comment}{// end catch\_run\_for\_at\_least.hpp}}
\DoxyCodeLine{6892 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6893 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{6894 }
\DoxyCodeLine{6895 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6896     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6897         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{6898         \textcolor{keyword}{struct }ExecutionPlan \{}
\DoxyCodeLine{6899             \textcolor{keywordtype}{int} iterations\_per\_sample;}
\DoxyCodeLine{6900             Duration estimated\_duration;}
\DoxyCodeLine{6901             Detail::BenchmarkFunction benchmark;}
\DoxyCodeLine{6902             Duration warmup\_time;}
\DoxyCodeLine{6903             \textcolor{keywordtype}{int} warmup\_iterations;}
\DoxyCodeLine{6904 }
\DoxyCodeLine{6905             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{6906             \textcolor{keyword}{operator} ExecutionPlan<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6907                 \textcolor{keywordflow}{return} \{ iterations\_per\_sample, estimated\_duration, benchmark, warmup\_time, warmup\_iterations \};}
\DoxyCodeLine{6908             \}}
\DoxyCodeLine{6909 }
\DoxyCodeLine{6910             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{6911             std::vector<FloatDuration<Clock>> run(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{6912                 \textcolor{comment}{// warmup a bit}}
\DoxyCodeLine{6913                 Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_iterations, Detail::repeat(now<Clock>\{\}));}
\DoxyCodeLine{6914 }
\DoxyCodeLine{6915                 std::vector<FloatDuration<Clock>> times;}
\DoxyCodeLine{6916                 times.reserve(cfg.benchmarkSamples());}
\DoxyCodeLine{6917                 std::generate\_n(std::back\_inserter(times), cfg.benchmarkSamples(), [\textcolor{keyword}{this}, env] \{}
\DoxyCodeLine{6918                     Detail::ChronometerModel<Clock> model;}
\DoxyCodeLine{6919                     this-\/>benchmark(Chronometer(model, iterations\_per\_sample));}
\DoxyCodeLine{6920                     auto sample\_time = model.elapsed() -\/ env.clock\_cost.mean;}
\DoxyCodeLine{6921                     if (sample\_time < FloatDuration<Clock>::zero()) sample\_time = FloatDuration<Clock>::zero();}
\DoxyCodeLine{6922                     return sample\_time / iterations\_per\_sample;}
\DoxyCodeLine{6923                 \});}
\DoxyCodeLine{6924                 \textcolor{keywordflow}{return} times;}
\DoxyCodeLine{6925             \}}
\DoxyCodeLine{6926         \};}
\DoxyCodeLine{6927     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{6928 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{6929 }
\DoxyCodeLine{6930 \textcolor{comment}{// end catch\_execution\_plan.hpp}}
\DoxyCodeLine{6931 \textcolor{comment}{// start catch\_estimate\_clock.hpp}}
\DoxyCodeLine{6932 }
\DoxyCodeLine{6933  \textcolor{comment}{// Environment measurement}}
\DoxyCodeLine{6934 }
\DoxyCodeLine{6935 }
\DoxyCodeLine{6936 \textcolor{comment}{// start catch\_stats.hpp}}
\DoxyCodeLine{6937 }
\DoxyCodeLine{6938 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{6939 }
\DoxyCodeLine{6940 }
\DoxyCodeLine{6941 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{6942 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{6943 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{6944 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{6945 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{6946 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{6947 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{6948 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{6949 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{6950 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{6951 }
\DoxyCodeLine{6952 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{6953     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{6954         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{6955             \textcolor{keyword}{using} sample = std::vector<double>;}
\DoxyCodeLine{6956 }
\DoxyCodeLine{6957             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{6958 }
\DoxyCodeLine{6959             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6960             OutlierClassification classify\_outliers(Iterator first, Iterator last) \{}
\DoxyCodeLine{6961                 std::vector<double> copy(first, last);}
\DoxyCodeLine{6962 }
\DoxyCodeLine{6963                 \textcolor{keyword}{auto} q1 = weighted\_average\_quantile(1, 4, copy.begin(), copy.end());}
\DoxyCodeLine{6964                 \textcolor{keyword}{auto} q3 = weighted\_average\_quantile(3, 4, copy.begin(), copy.end());}
\DoxyCodeLine{6965                 \textcolor{keyword}{auto} iqr = q3 -\/ q1;}
\DoxyCodeLine{6966                 \textcolor{keyword}{auto} los = q1 -\/ (iqr * 3.);}
\DoxyCodeLine{6967                 \textcolor{keyword}{auto} lom = q1 -\/ (iqr * 1.5);}
\DoxyCodeLine{6968                 \textcolor{keyword}{auto} him = q3 + (iqr * 1.5);}
\DoxyCodeLine{6969                 \textcolor{keyword}{auto} his = q3 + (iqr * 3.);}
\DoxyCodeLine{6970 }
\DoxyCodeLine{6971                 OutlierClassification o;}
\DoxyCodeLine{6972                 \textcolor{keywordflow}{for} (; first != last; ++first) \{}
\DoxyCodeLine{6973                     \textcolor{keyword}{auto}\&\& t = *first;}
\DoxyCodeLine{6974                     \textcolor{keywordflow}{if} (t < los) ++o.low\_severe;}
\DoxyCodeLine{6975                     \textcolor{keywordflow}{else} if (t < lom) ++o.low\_mild;}
\DoxyCodeLine{6976                     \textcolor{keywordflow}{else} if (t > his) ++o.high\_severe;}
\DoxyCodeLine{6977                     \textcolor{keywordflow}{else} if (t > him) ++o.high\_mild;}
\DoxyCodeLine{6978                     ++o.samples\_seen;}
\DoxyCodeLine{6979                 \}}
\DoxyCodeLine{6980                 \textcolor{keywordflow}{return} o;}
\DoxyCodeLine{6981             \}}
\DoxyCodeLine{6982 }
\DoxyCodeLine{6983             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{6984             \textcolor{keywordtype}{double} mean(Iterator first, Iterator last) \{}
\DoxyCodeLine{6985                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{6986                 \textcolor{keywordtype}{double} sum = std::accumulate(first, last, 0.);}
\DoxyCodeLine{6987                 \textcolor{keywordflow}{return} sum / count;}
\DoxyCodeLine{6988             \}}
\DoxyCodeLine{6989 }
\DoxyCodeLine{6990             \textcolor{keyword}{template} <\textcolor{keyword}{typename} URng, \textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{6991             sample resample(URng\& rng, \textcolor{keywordtype}{int} resamples, Iterator first, Iterator last, Estimator\& estimator) \{}
\DoxyCodeLine{6992                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{6993                 std::uniform\_int\_distribution<\textcolor{keyword}{decltype}(n)> dist(0, n -\/ 1);}
\DoxyCodeLine{6994 }
\DoxyCodeLine{6995                 sample out;}
\DoxyCodeLine{6996                 out.reserve(resamples);}
\DoxyCodeLine{6997                 std::generate\_n(std::back\_inserter(out), resamples, [n, first, \&estimator, \&dist, \&rng] \{}
\DoxyCodeLine{6998                     std::vector<double> resampled;}
\DoxyCodeLine{6999                     resampled.reserve(n);}
\DoxyCodeLine{7000                     std::generate\_n(std::back\_inserter(resampled), n, [first, \&dist, \&rng] \{ \textcolor{keywordflow}{return} first[dist(rng)]; \});}
\DoxyCodeLine{7001                     \textcolor{keywordflow}{return} estimator(resampled.begin(), resampled.end());}
\DoxyCodeLine{7002                 \});}
\DoxyCodeLine{7003                 std::sort(out.begin(), out.end());}
\DoxyCodeLine{7004                 \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{7005             \}}
\DoxyCodeLine{7006 }
\DoxyCodeLine{7007             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Estimator, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7008             sample jackknife(Estimator\&\& estimator, Iterator first, Iterator last) \{}
\DoxyCodeLine{7009                 \textcolor{keyword}{auto} n = last -\/ first;}
\DoxyCodeLine{7010                 \textcolor{keyword}{auto} second = std::next(first);}
\DoxyCodeLine{7011                 sample results;}
\DoxyCodeLine{7012                 results.reserve(n);}
\DoxyCodeLine{7013 }
\DoxyCodeLine{7014                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it != last; ++it) \{}
\DoxyCodeLine{7015                     std::iter\_swap(it, first);}
\DoxyCodeLine{7016                     results.push\_back(estimator(second, last));}
\DoxyCodeLine{7017                 \}}
\DoxyCodeLine{7018 }
\DoxyCodeLine{7019                 \textcolor{keywordflow}{return} results;}
\DoxyCodeLine{7020             \}}
\DoxyCodeLine{7021 }
\DoxyCodeLine{7022             \textcolor{keyword}{inline} \textcolor{keywordtype}{double} normal\_cdf(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7023                 \textcolor{keywordflow}{return} std::erfc(-\/x / std::sqrt(2.0)) / 2.0;}
\DoxyCodeLine{7024             \}}
\DoxyCodeLine{7025 }
\DoxyCodeLine{7026             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x);}
\DoxyCodeLine{7027 }
\DoxyCodeLine{7028             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p);}
\DoxyCodeLine{7029 }
\DoxyCodeLine{7030             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator, \textcolor{keyword}{typename} Estimator>}
\DoxyCodeLine{7031             Estimate<double> bootstrap(\textcolor{keywordtype}{double} confidence\_level, Iterator first, Iterator last, sample \textcolor{keyword}{const}\& resample, Estimator\&\& estimator) \{}
\DoxyCodeLine{7032                 \textcolor{keyword}{auto} n\_samples = last -\/ first;}
\DoxyCodeLine{7033 }
\DoxyCodeLine{7034                 \textcolor{keywordtype}{double} point = estimator(first, last);}
\DoxyCodeLine{7035                 \textcolor{comment}{// Degenerate case with a single sample}}
\DoxyCodeLine{7036                 \textcolor{keywordflow}{if} (n\_samples == 1) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7037 }
\DoxyCodeLine{7038                 sample jack = jackknife(estimator, first, last);}
\DoxyCodeLine{7039                 \textcolor{keywordtype}{double} jack\_mean = mean(jack.begin(), jack.end());}
\DoxyCodeLine{7040                 \textcolor{keywordtype}{double} sum\_squares, sum\_cubes;}
\DoxyCodeLine{7041                 std::tie(sum\_squares, sum\_cubes) = std::accumulate(jack.begin(), jack.end(), std::make\_pair(0., 0.), [jack\_mean](std::pair<double, double> sqcb, \textcolor{keywordtype}{double} x) -\/> std::pair<double, double> \{}
\DoxyCodeLine{7042                     auto d = jack\_mean -\/ x;}
\DoxyCodeLine{7043                     auto d2 = d * d;}
\DoxyCodeLine{7044                     auto d3 = d2 * d;}
\DoxyCodeLine{7045                     return \{ sqcb.first + d2, sqcb.second + d3 \};}
\DoxyCodeLine{7046                 \});}
\DoxyCodeLine{7047 }
\DoxyCodeLine{7048                 \textcolor{keywordtype}{double} accel = sum\_cubes / (6 * std::pow(sum\_squares, 1.5));}
\DoxyCodeLine{7049                 \textcolor{keywordtype}{int} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(resample.size());}
\DoxyCodeLine{7050                 \textcolor{keywordtype}{double} prob\_n = std::count\_if(resample.begin(), resample.end(), [point](\textcolor{keywordtype}{double} x) \{ return x < point; \}) / (double)n;}
\DoxyCodeLine{7051                 \textcolor{comment}{// degenerate case with uniform samples}}
\DoxyCodeLine{7052                 \textcolor{keywordflow}{if} (prob\_n == 0) \textcolor{keywordflow}{return} \{ point, point, point, confidence\_level \};}
\DoxyCodeLine{7053 }
\DoxyCodeLine{7054                 \textcolor{keywordtype}{double} bias = normal\_quantile(prob\_n);}
\DoxyCodeLine{7055                 \textcolor{keywordtype}{double} z1 = normal\_quantile((1. -\/ confidence\_level) / 2.);}
\DoxyCodeLine{7056 }
\DoxyCodeLine{7057                 \textcolor{keyword}{auto} cumn = [n](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{7058                     \textcolor{keywordflow}{return} std::lround(normal\_cdf(x) * n); \};}
\DoxyCodeLine{7059                 \textcolor{keyword}{auto} a = [bias, accel](\textcolor{keywordtype}{double} b) \{ \textcolor{keywordflow}{return} bias + b / (1. -\/ accel * b); \};}
\DoxyCodeLine{7060                 \textcolor{keywordtype}{double} b1 = bias + z1;}
\DoxyCodeLine{7061                 \textcolor{keywordtype}{double} b2 = bias -\/ z1;}
\DoxyCodeLine{7062                 \textcolor{keywordtype}{double} a1 = a(b1);}
\DoxyCodeLine{7063                 \textcolor{keywordtype}{double} a2 = a(b2);}
\DoxyCodeLine{7064                 \textcolor{keyword}{auto} lo = (std::max)(cumn(a1), 0);}
\DoxyCodeLine{7065                 \textcolor{keyword}{auto} hi = (std::min)(cumn(a2), n -\/ 1);}
\DoxyCodeLine{7066 }
\DoxyCodeLine{7067                 \textcolor{keywordflow}{return} \{ point, resample[lo], resample[hi], confidence\_level \};}
\DoxyCodeLine{7068             \}}
\DoxyCodeLine{7069 }
\DoxyCodeLine{7070             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n);}
\DoxyCodeLine{7071 }
\DoxyCodeLine{7072             \textcolor{keyword}{struct }bootstrap\_analysis \{}
\DoxyCodeLine{7073                 Estimate<double> mean;}
\DoxyCodeLine{7074                 Estimate<double> standard\_deviation;}
\DoxyCodeLine{7075                 \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7076             \};}
\DoxyCodeLine{7077 }
\DoxyCodeLine{7078             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);}
\DoxyCodeLine{7079         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7080     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7081 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7082 }
\DoxyCodeLine{7083 \textcolor{comment}{// end catch\_stats.hpp}}
\DoxyCodeLine{7084 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7085 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7086 \textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{7087 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7088 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7089 }
\DoxyCodeLine{7090 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7091     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7092         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7093             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7094             std::vector<double> resolution(\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7095                 std::vector<TimePoint<Clock>> times;}
\DoxyCodeLine{7096                 times.reserve(k + 1);}
\DoxyCodeLine{7097                 std::generate\_n(std::back\_inserter(times), k + 1, now<Clock>\{\});}
\DoxyCodeLine{7098 }
\DoxyCodeLine{7099                 std::vector<double> deltas;}
\DoxyCodeLine{7100                 deltas.reserve(k);}
\DoxyCodeLine{7101                 std::transform(std::next(times.begin()), times.end(), times.begin(),}
\DoxyCodeLine{7102                     std::back\_inserter(deltas),}
\DoxyCodeLine{7103                     [](TimePoint<Clock> a, TimePoint<Clock> b) \{ return static\_cast<double>((a -\/ b).count()); \});}
\DoxyCodeLine{7104 }
\DoxyCodeLine{7105                 \textcolor{keywordflow}{return} deltas;}
\DoxyCodeLine{7106             \}}
\DoxyCodeLine{7107 }
\DoxyCodeLine{7108             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_iterations = 10000;}
\DoxyCodeLine{7109             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_time = std::chrono::milliseconds(100);}
\DoxyCodeLine{7110             \textcolor{keyword}{const} \textcolor{keyword}{auto} minimum\_ticks = 1000;}
\DoxyCodeLine{7111             \textcolor{keyword}{const} \textcolor{keyword}{auto} warmup\_seed = 10000;}
\DoxyCodeLine{7112             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_resolution\_estimation\_time = std::chrono::milliseconds(500);}
\DoxyCodeLine{7113             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time\_limit = std::chrono::seconds(1);}
\DoxyCodeLine{7114             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_tick\_limit = 100000;}
\DoxyCodeLine{7115             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_time = std::chrono::milliseconds(10);}
\DoxyCodeLine{7116             \textcolor{keyword}{const} \textcolor{keyword}{auto} clock\_cost\_estimation\_iterations = 10000;}
\DoxyCodeLine{7117 }
\DoxyCodeLine{7118             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7119             \textcolor{keywordtype}{int} warmup() \{}
\DoxyCodeLine{7120                 \textcolor{keywordflow}{return} run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(warmup\_time), warmup\_seed, \&resolution<Clock>)}
\DoxyCodeLine{7121                     .iterations;}
\DoxyCodeLine{7122             \}}
\DoxyCodeLine{7123             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7124             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_resolution(\textcolor{keywordtype}{int} iterations) \{}
\DoxyCodeLine{7125                 \textcolor{keyword}{auto} r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_resolution\_estimation\_time), iterations, \&resolution<Clock>)}
\DoxyCodeLine{7126                     .result;}
\DoxyCodeLine{7127                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7128                     FloatDuration<Clock>(mean(r.begin(), r.end())),}
\DoxyCodeLine{7129                     classify\_outliers(r.begin(), r.end()),}
\DoxyCodeLine{7130                 \};}
\DoxyCodeLine{7131             \}}
\DoxyCodeLine{7132             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7133             EnvironmentEstimate<FloatDuration<Clock>> estimate\_clock\_cost(FloatDuration<Clock> resolution) \{}
\DoxyCodeLine{7134                 \textcolor{keyword}{auto} time\_limit = (std::min)(}
\DoxyCodeLine{7135                     resolution * clock\_cost\_estimation\_tick\_limit,}
\DoxyCodeLine{7136                     FloatDuration<Clock>(clock\_cost\_estimation\_time\_limit));}
\DoxyCodeLine{7137                 \textcolor{keyword}{auto} time\_clock = [](\textcolor{keywordtype}{int} k) \{}
\DoxyCodeLine{7138                     \textcolor{keywordflow}{return} Detail::measure<Clock>([k] \{}
\DoxyCodeLine{7139                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < k; ++i) \{}
\DoxyCodeLine{7140                             \textcolor{keyword}{volatile} \textcolor{keyword}{auto} ignored = Clock::now();}
\DoxyCodeLine{7141                             (void)ignored;}
\DoxyCodeLine{7142                         \}}
\DoxyCodeLine{7143                     \}).elapsed;}
\DoxyCodeLine{7144                 \};}
\DoxyCodeLine{7145                 time\_clock(1);}
\DoxyCodeLine{7146                 \textcolor{keywordtype}{int} iters = clock\_cost\_estimation\_iterations;}
\DoxyCodeLine{7147                 \textcolor{keyword}{auto}\&\& r = run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(clock\_cost\_estimation\_time), iters, time\_clock);}
\DoxyCodeLine{7148                 std::vector<double> times;}
\DoxyCodeLine{7149                 \textcolor{keywordtype}{int} nsamples = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(time\_limit / r.elapsed));}
\DoxyCodeLine{7150                 times.reserve(nsamples);}
\DoxyCodeLine{7151                 std::generate\_n(std::back\_inserter(times), nsamples, [time\_clock, \&r] \{}
\DoxyCodeLine{7152                     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}((time\_clock(r.iterations) / r.iterations).count());}
\DoxyCodeLine{7153                 \});}
\DoxyCodeLine{7154                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7155                     FloatDuration<Clock>(mean(times.begin(), times.end())),}
\DoxyCodeLine{7156                     classify\_outliers(times.begin(), times.end()),}
\DoxyCodeLine{7157                 \};}
\DoxyCodeLine{7158             \}}
\DoxyCodeLine{7159 }
\DoxyCodeLine{7160             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7161             Environment<FloatDuration<Clock>> measure\_environment() \{}
\DoxyCodeLine{7162                 \textcolor{keyword}{static} Environment<FloatDuration<Clock>>* env = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7163                 \textcolor{keywordflow}{if} (env) \{}
\DoxyCodeLine{7164                     \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7165                 \}}
\DoxyCodeLine{7166 }
\DoxyCodeLine{7167                 \textcolor{keyword}{auto} iters = Detail::warmup<Clock>();}
\DoxyCodeLine{7168                 \textcolor{keyword}{auto} resolution = Detail::estimate\_clock\_resolution<Clock>(iters);}
\DoxyCodeLine{7169                 \textcolor{keyword}{auto} cost = Detail::estimate\_clock\_cost<Clock>(resolution.mean);}
\DoxyCodeLine{7170 }
\DoxyCodeLine{7171                 env = \textcolor{keyword}{new} Environment<FloatDuration<Clock>>\{ resolution, cost \};}
\DoxyCodeLine{7172                 \textcolor{keywordflow}{return} *env;}
\DoxyCodeLine{7173             \}}
\DoxyCodeLine{7174         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7175     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7176 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7177 }
\DoxyCodeLine{7178 \textcolor{comment}{// end catch\_estimate\_clock.hpp}}
\DoxyCodeLine{7179 \textcolor{comment}{// start catch\_analyse.hpp}}
\DoxyCodeLine{7180 }
\DoxyCodeLine{7181  \textcolor{comment}{// Run and analyse one benchmark}}
\DoxyCodeLine{7182 }
\DoxyCodeLine{7183 }
\DoxyCodeLine{7184 \textcolor{comment}{// start catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7185 }
\DoxyCodeLine{7186 \textcolor{comment}{// Benchmark results}}
\DoxyCodeLine{7187 }
\DoxyCodeLine{7188 }
\DoxyCodeLine{7189 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7190 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7191 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7192 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7193 }
\DoxyCodeLine{7194 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7195     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7196         \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{7197         \textcolor{keyword}{struct }SampleAnalysis \{}
\DoxyCodeLine{7198             std::vector<Duration> samples;}
\DoxyCodeLine{7199             Estimate<Duration> mean;}
\DoxyCodeLine{7200             Estimate<Duration> standard\_deviation;}
\DoxyCodeLine{7201             OutlierClassification outliers;}
\DoxyCodeLine{7202             \textcolor{keywordtype}{double} outlier\_variance;}
\DoxyCodeLine{7203 }
\DoxyCodeLine{7204             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration2>}
\DoxyCodeLine{7205             \textcolor{keyword}{operator} SampleAnalysis<Duration2>()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7206                 std::vector<Duration2> samples2;}
\DoxyCodeLine{7207                 samples2.reserve(samples.size());}
\DoxyCodeLine{7208                 std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](Duration d) \{ return Duration2(d); \});}
\DoxyCodeLine{7209                 \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7210                     std::move(samples2),}
\DoxyCodeLine{7211                     mean,}
\DoxyCodeLine{7212                     standard\_deviation,}
\DoxyCodeLine{7213                     outliers,}
\DoxyCodeLine{7214                     outlier\_variance,}
\DoxyCodeLine{7215                 \};}
\DoxyCodeLine{7216             \}}
\DoxyCodeLine{7217         \};}
\DoxyCodeLine{7218     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7219 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7220 }
\DoxyCodeLine{7221 \textcolor{comment}{// end catch\_sample\_analysis.hpp}}
\DoxyCodeLine{7222 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7223 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{7224 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7225 }
\DoxyCodeLine{7226 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7227     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7228         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7229             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{7230             SampleAnalysis<Duration> analyse(\textcolor{keyword}{const} IConfig \&cfg, Environment<Duration>, Iterator first, Iterator last) \{}
\DoxyCodeLine{7231                 \textcolor{keywordflow}{if} (!cfg.benchmarkNoAnalysis()) \{}
\DoxyCodeLine{7232                     std::vector<double> samples;}
\DoxyCodeLine{7233                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7234                     std::transform(first, last, std::back\_inserter(samples), [](Duration d) \{ \textcolor{keywordflow}{return} d.count(); \});}
\DoxyCodeLine{7235 }
\DoxyCodeLine{7236                     \textcolor{keyword}{auto} analysis = Catch::Benchmark::Detail::analyse\_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());}
\DoxyCodeLine{7237                     \textcolor{keyword}{auto} outliers = Catch::Benchmark::Detail::classify\_outliers(samples.begin(), samples.end());}
\DoxyCodeLine{7238 }
\DoxyCodeLine{7239                     \textcolor{keyword}{auto} wrap\_estimate = [](Estimate<double> e) \{}
\DoxyCodeLine{7240                         \textcolor{keywordflow}{return} Estimate<Duration> \{}
\DoxyCodeLine{7241                             Duration(e.point),}
\DoxyCodeLine{7242                                 Duration(e.lower\_bound),}
\DoxyCodeLine{7243                                 Duration(e.upper\_bound),}
\DoxyCodeLine{7244                                 e.confidence\_interval,}
\DoxyCodeLine{7245                         \};}
\DoxyCodeLine{7246                     \};}
\DoxyCodeLine{7247                     std::vector<Duration> samples2;}
\DoxyCodeLine{7248                     samples2.reserve(samples.size());}
\DoxyCodeLine{7249                     std::transform(samples.begin(), samples.end(), std::back\_inserter(samples2), [](\textcolor{keywordtype}{double} d) \{ return Duration(d); \});}
\DoxyCodeLine{7250                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7251                         std::move(samples2),}
\DoxyCodeLine{7252                         wrap\_estimate(analysis.mean),}
\DoxyCodeLine{7253                         wrap\_estimate(analysis.standard\_deviation),}
\DoxyCodeLine{7254                         outliers,}
\DoxyCodeLine{7255                         analysis.outlier\_variance,}
\DoxyCodeLine{7256                     \};}
\DoxyCodeLine{7257                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7258                     std::vector<Duration> samples;}
\DoxyCodeLine{7259                     samples.reserve(last -\/ first);}
\DoxyCodeLine{7260 }
\DoxyCodeLine{7261                     Duration mean = Duration(0);}
\DoxyCodeLine{7262                     \textcolor{keywordtype}{int} i = 0;}
\DoxyCodeLine{7263                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = first; it < last; ++it, ++i) \{}
\DoxyCodeLine{7264                         samples.push\_back(Duration(*it));}
\DoxyCodeLine{7265                         mean += Duration(*it);}
\DoxyCodeLine{7266                     \}}
\DoxyCodeLine{7267                     mean /= i;}
\DoxyCodeLine{7268 }
\DoxyCodeLine{7269                     \textcolor{keywordflow}{return} \{}
\DoxyCodeLine{7270                         std::move(samples),}
\DoxyCodeLine{7271                         Estimate<Duration>\{mean, mean, mean, 0.0\},}
\DoxyCodeLine{7272                         Estimate<Duration>\{Duration(0), Duration(0), Duration(0), 0.0\},}
\DoxyCodeLine{7273                         OutlierClassification\{\},}
\DoxyCodeLine{7274                         0.0}
\DoxyCodeLine{7275                     \};}
\DoxyCodeLine{7276                 \}}
\DoxyCodeLine{7277             \}}
\DoxyCodeLine{7278         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7279     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7280 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7281 }
\DoxyCodeLine{7282 \textcolor{comment}{// end catch\_analyse.hpp}}
\DoxyCodeLine{7283 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{7284 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{7285 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7286 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7287 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7288 }
\DoxyCodeLine{7289 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7290     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7291         \textcolor{keyword}{struct }Benchmark \{}
\DoxyCodeLine{7292             Benchmark(std::string \&\&name)}
\DoxyCodeLine{7293                 : name(std::move(name)) \{\}}
\DoxyCodeLine{7294 }
\DoxyCodeLine{7295             \textcolor{keyword}{template} <\textcolor{keyword}{class} FUN>}
\DoxyCodeLine{7296             Benchmark(std::string \&\&name, FUN \&\&func)}
\DoxyCodeLine{7297                 : fun(std::move(func)), name(std::move(name)) \{\}}
\DoxyCodeLine{7298 }
\DoxyCodeLine{7299             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock>}
\DoxyCodeLine{7300             ExecutionPlan<FloatDuration<Clock>> prepare(\textcolor{keyword}{const} IConfig \&cfg, Environment<FloatDuration<Clock>> env)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7301                 \textcolor{keyword}{auto} min\_time = env.clock\_resolution.mean * Detail::minimum\_ticks;}
\DoxyCodeLine{7302                 \textcolor{keyword}{auto} run\_time = std::max(min\_time, std::chrono::duration\_cast<\textcolor{keyword}{decltype}(min\_time)>(cfg.benchmarkWarmupTime()));}
\DoxyCodeLine{7303                 \textcolor{keyword}{auto}\&\& test = Detail::run\_for\_at\_least<Clock>(std::chrono::duration\_cast<ClockDuration<Clock>>(run\_time), 1, fun);}
\DoxyCodeLine{7304                 \textcolor{keywordtype}{int} new\_iters = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(std::ceil(min\_time * test.iterations / test.elapsed));}
\DoxyCodeLine{7305                 \textcolor{keywordflow}{return} \{ new\_iters, test.elapsed / test.iterations * new\_iters * cfg.benchmarkSamples(), fun, std::chrono::duration\_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup\_iterations \};}
\DoxyCodeLine{7306             \}}
\DoxyCodeLine{7307 }
\DoxyCodeLine{7308             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Clock = default\_clock>}
\DoxyCodeLine{7309             \textcolor{keywordtype}{void} run() \{}
\DoxyCodeLine{7310                 IConfigPtr cfg = getCurrentContext().getConfig();}
\DoxyCodeLine{7311 }
\DoxyCodeLine{7312                 \textcolor{keyword}{auto} env = Detail::measure\_environment<Clock>();}
\DoxyCodeLine{7313 }
\DoxyCodeLine{7314                 getResultCapture().benchmarkPreparing(name);}
\DoxyCodeLine{7315                 CATCH\_TRY\{}
\DoxyCodeLine{7316                     \textcolor{keyword}{auto} plan = user\_code([\&] \{}
\DoxyCodeLine{7317                         \textcolor{keywordflow}{return} prepare<Clock>(*cfg, env);}
\DoxyCodeLine{7318                     \});}
\DoxyCodeLine{7319 }
\DoxyCodeLine{7320                     BenchmarkInfo info \{}
\DoxyCodeLine{7321                         name,}
\DoxyCodeLine{7322                         plan.estimated\_duration.count(),}
\DoxyCodeLine{7323                         plan.iterations\_per\_sample,}
\DoxyCodeLine{7324                         cfg-\/>benchmarkSamples(),}
\DoxyCodeLine{7325                         cfg-\/>benchmarkResamples(),}
\DoxyCodeLine{7326                         env.clock\_resolution.mean.count(),}
\DoxyCodeLine{7327                         env.clock\_cost.mean.count()}
\DoxyCodeLine{7328                     \};}
\DoxyCodeLine{7329 }
\DoxyCodeLine{7330                     getResultCapture().benchmarkStarting(info);}
\DoxyCodeLine{7331 }
\DoxyCodeLine{7332                     \textcolor{keyword}{auto} samples = user\_code([\&] \{}
\DoxyCodeLine{7333                         \textcolor{keywordflow}{return} plan.template run<Clock>(*cfg, env);}
\DoxyCodeLine{7334                     \});}
\DoxyCodeLine{7335 }
\DoxyCodeLine{7336                     \textcolor{keyword}{auto} analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());}
\DoxyCodeLine{7337                     BenchmarkStats<FloatDuration<Clock>> stats\{ info, analysis.samples, analysis.mean, analysis.standard\_deviation, analysis.outliers, analysis.outlier\_variance \};}
\DoxyCodeLine{7338                     getResultCapture().benchmarkEnded(stats);}
\DoxyCodeLine{7339 }
\DoxyCodeLine{7340                 \} CATCH\_CATCH\_ALL\{}
\DoxyCodeLine{7341                     \textcolor{keywordflow}{if} (translateActiveException() != Detail::benchmarkErrorMsg) \textcolor{comment}{// benchmark errors have been reported, otherwise rethrow.}}
\DoxyCodeLine{7342                         std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{7343                 \}}
\DoxyCodeLine{7344             \}}
\DoxyCodeLine{7345 }
\DoxyCodeLine{7346             \textcolor{comment}{// sets lambda to be used in fun *and* executes benchmark!}}
\DoxyCodeLine{7347             \textcolor{keyword}{template} <\textcolor{keyword}{typename} Fun,}
\DoxyCodeLine{7348                 \textcolor{keyword}{typename} std::enable\_if<!Detail::is\_related<Fun, Benchmark>::value, \textcolor{keywordtype}{int}>::type = 0>}
\DoxyCodeLine{7349                 Benchmark \& operator=(Fun func) \{}
\DoxyCodeLine{7350                 fun = Detail::BenchmarkFunction(func);}
\DoxyCodeLine{7351                 run();}
\DoxyCodeLine{7352                 \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{7353             \}}
\DoxyCodeLine{7354 }
\DoxyCodeLine{7355             \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \{}
\DoxyCodeLine{7356                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{7357             \}}
\DoxyCodeLine{7358 }
\DoxyCodeLine{7359         \textcolor{keyword}{private}:}
\DoxyCodeLine{7360             Detail::BenchmarkFunction fun;}
\DoxyCodeLine{7361             std::string name;}
\DoxyCodeLine{7362         \};}
\DoxyCodeLine{7363     \}}
\DoxyCodeLine{7364 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7365 }
\DoxyCodeLine{7366 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_1\_ARG(arg1, arg2, ...) arg1}}
\DoxyCodeLine{7367 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_GET\_2\_ARG(arg1, arg2, ...) arg2}}
\DoxyCodeLine{7368 }
\DoxyCodeLine{7369 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK(BenchmarkName, name, benchmarkIndex)\(\backslash\)}}
\DoxyCodeLine{7370 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7371 \textcolor{preprocessor}{        BenchmarkName = [\&](int benchmarkIndex)}}
\DoxyCodeLine{7372 }
\DoxyCodeLine{7373 \textcolor{preprocessor}{\#define INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(BenchmarkName, name)\(\backslash\)}}
\DoxyCodeLine{7374 \textcolor{preprocessor}{    if( Catch::Benchmark::Benchmark BenchmarkName\{name\} ) \(\backslash\)}}
\DoxyCodeLine{7375 \textcolor{preprocessor}{        BenchmarkName = [\&]}}
\DoxyCodeLine{7376 }
\DoxyCodeLine{7377 \textcolor{comment}{// end catch\_benchmark.hpp}}
\DoxyCodeLine{7378 \textcolor{comment}{// start catch\_constructor.hpp}}
\DoxyCodeLine{7379 }
\DoxyCodeLine{7380 \textcolor{comment}{// Constructor and destructor helpers}}
\DoxyCodeLine{7381 }
\DoxyCodeLine{7382 }
\DoxyCodeLine{7383 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{7384 }
\DoxyCodeLine{7385 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7386     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7387         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7388             \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{bool} Destruct>}
\DoxyCodeLine{7389             \textcolor{keyword}{struct }ObjectStorage}
\DoxyCodeLine{7390             \{}
\DoxyCodeLine{7391                 \textcolor{keyword}{using} TStorage = \textcolor{keyword}{typename} std::aligned\_storage<\textcolor{keyword}{sizeof}(T), std::alignment\_of<T>::value>::type;}
\DoxyCodeLine{7392 }
\DoxyCodeLine{7393                 ObjectStorage() : data() \{\}}
\DoxyCodeLine{7394 }
\DoxyCodeLine{7395                 ObjectStorage(\textcolor{keyword}{const} ObjectStorage\& other)}
\DoxyCodeLine{7396                 \{}
\DoxyCodeLine{7397                     \textcolor{keyword}{new}(\&data) T(other.stored\_object());}
\DoxyCodeLine{7398                 \}}
\DoxyCodeLine{7399 }
\DoxyCodeLine{7400                 ObjectStorage(ObjectStorage\&\& other)}
\DoxyCodeLine{7401                 \{}
\DoxyCodeLine{7402                     \textcolor{keyword}{new}(\&data) T(std::move(other.stored\_object()));}
\DoxyCodeLine{7403                 \}}
\DoxyCodeLine{7404 }
\DoxyCodeLine{7405                 \string~ObjectStorage() \{ destruct\_on\_exit<T>(); \}}
\DoxyCodeLine{7406 }
\DoxyCodeLine{7407                 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{7408                 \textcolor{keywordtype}{void} construct(Args\&\&... args)}
\DoxyCodeLine{7409                 \{}
\DoxyCodeLine{7410                     \textcolor{keyword}{new} (\&data) T(std::forward<Args>(args)...);}
\DoxyCodeLine{7411                 \}}
\DoxyCodeLine{7412 }
\DoxyCodeLine{7413                 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} AllowManualDestruction = !Destruct>}
\DoxyCodeLine{7414                 \textcolor{keyword}{typename} std::enable\_if<AllowManualDestruction>::type destruct()}
\DoxyCodeLine{7415                 \{}
\DoxyCodeLine{7416                     stored\_object().\string~T();}
\DoxyCodeLine{7417                 \}}
\DoxyCodeLine{7418 }
\DoxyCodeLine{7419             \textcolor{keyword}{private}:}
\DoxyCodeLine{7420                 \textcolor{comment}{// If this is a constructor benchmark, destruct the underlying object}}
\DoxyCodeLine{7421                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7422                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<Destruct, U>::type* = 0) \{ destruct<true>(); \}}
\DoxyCodeLine{7423                 \textcolor{comment}{// Otherwise, don't}}
\DoxyCodeLine{7424                 \textcolor{keyword}{template} <\textcolor{keyword}{typename} U>}
\DoxyCodeLine{7425                 \textcolor{keywordtype}{void} destruct\_on\_exit(\textcolor{keyword}{typename} std::enable\_if<!Destruct, U>::type* = 0) \{ \}}
\DoxyCodeLine{7426 }
\DoxyCodeLine{7427                 T\& stored\_object() \{}
\DoxyCodeLine{7428                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7429                 \}}
\DoxyCodeLine{7430 }
\DoxyCodeLine{7431                 T \textcolor{keyword}{const}\& stored\_object()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7432                     \textcolor{keywordflow}{return} *\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&data));}
\DoxyCodeLine{7433                 \}}
\DoxyCodeLine{7434 }
\DoxyCodeLine{7435                 TStorage data;}
\DoxyCodeLine{7436             \};}
\DoxyCodeLine{7437         \}}
\DoxyCodeLine{7438 }
\DoxyCodeLine{7439         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7440         \textcolor{keyword}{using} storage\_for = Detail::ObjectStorage<T, true>;}
\DoxyCodeLine{7441 }
\DoxyCodeLine{7442         \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{7443         \textcolor{keyword}{using} destructable\_object = Detail::ObjectStorage<T, false>;}
\DoxyCodeLine{7444     \}}
\DoxyCodeLine{7445 \}}
\DoxyCodeLine{7446 }
\DoxyCodeLine{7447 \textcolor{comment}{// end catch\_constructor.hpp}}
\DoxyCodeLine{7448 \textcolor{comment}{// end catch\_benchmarking\_all.hpp}}
\DoxyCodeLine{7449 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7450 }
\DoxyCodeLine{7451 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{7452 }
\DoxyCodeLine{7453 \textcolor{preprocessor}{\#ifdef CATCH\_IMPL}}
\DoxyCodeLine{7454 \textcolor{comment}{// start catch\_impl.hpp}}
\DoxyCodeLine{7455 }
\DoxyCodeLine{7456 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{7457 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{7458 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{7459 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7460 }
\DoxyCodeLine{7461 \textcolor{comment}{// Keep these here for external reporters}}
\DoxyCodeLine{7462 \textcolor{comment}{// start catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7463 }
\DoxyCodeLine{7464 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{7465 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{7466 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{7467 }
\DoxyCodeLine{7468 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7469 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{7470 }
\DoxyCodeLine{7471     \textcolor{keyword}{struct }NameAndLocation \{}
\DoxyCodeLine{7472         std::string name;}
\DoxyCodeLine{7473         SourceLineInfo location;}
\DoxyCodeLine{7474 }
\DoxyCodeLine{7475         NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location );}
\DoxyCodeLine{7476         \textcolor{keyword}{friend} \textcolor{keywordtype}{bool} operator==(NameAndLocation \textcolor{keyword}{const}\& lhs, NameAndLocation \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{7477             \textcolor{keywordflow}{return} lhs.name == rhs.name}
\DoxyCodeLine{7478                 \&\& lhs.location == rhs.location;}
\DoxyCodeLine{7479         \}}
\DoxyCodeLine{7480     \};}
\DoxyCodeLine{7481 }
\DoxyCodeLine{7482     \textcolor{keyword}{class }ITracker;}
\DoxyCodeLine{7483 }
\DoxyCodeLine{7484     \textcolor{keyword}{using} ITrackerPtr = std::shared\_ptr<ITracker>;}
\DoxyCodeLine{7485 }
\DoxyCodeLine{7486     \textcolor{keyword}{class  }ITracker \{}
\DoxyCodeLine{7487         NameAndLocation m\_nameAndLocation;}
\DoxyCodeLine{7488 }
\DoxyCodeLine{7489     \textcolor{keyword}{public}:}
\DoxyCodeLine{7490         ITracker(NameAndLocation \textcolor{keyword}{const}\& nameAndLoc) :}
\DoxyCodeLine{7491             m\_nameAndLocation(nameAndLoc)}
\DoxyCodeLine{7492         \{\}}
\DoxyCodeLine{7493 }
\DoxyCodeLine{7494         \textcolor{comment}{// static queries}}
\DoxyCodeLine{7495         NameAndLocation \textcolor{keyword}{const}\& nameAndLocation()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7496             \textcolor{keywordflow}{return} m\_nameAndLocation;}
\DoxyCodeLine{7497         \}}
\DoxyCodeLine{7498 }
\DoxyCodeLine{7499         \textcolor{keyword}{virtual} \string~ITracker();}
\DoxyCodeLine{7500 }
\DoxyCodeLine{7501         \textcolor{comment}{// dynamic queries}}
\DoxyCodeLine{7502         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Successfully completed or failed}}
\DoxyCodeLine{7503         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7504         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const} = 0; \textcolor{comment}{// Started but not complete}}
\DoxyCodeLine{7505         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7506         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} hasStarted() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7507 }
\DoxyCodeLine{7508         \textcolor{keyword}{virtual} ITracker\& parent() = 0;}
\DoxyCodeLine{7509 }
\DoxyCodeLine{7510         \textcolor{comment}{// actions}}
\DoxyCodeLine{7511         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} close() = 0; \textcolor{comment}{// Successfully complete}}
\DoxyCodeLine{7512         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} fail() = 0;}
\DoxyCodeLine{7513         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} markAsNeedingAnotherRun() = 0;}
\DoxyCodeLine{7514 }
\DoxyCodeLine{7515         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) = 0;}
\DoxyCodeLine{7516         \textcolor{keyword}{virtual} ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) = 0;}
\DoxyCodeLine{7517         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} openChild() = 0;}
\DoxyCodeLine{7518 }
\DoxyCodeLine{7519         \textcolor{comment}{// Debug/ checking}}
\DoxyCodeLine{7520         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7521         \textcolor{keyword}{virtual} \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{7522     \};}
\DoxyCodeLine{7523 }
\DoxyCodeLine{7524     \textcolor{keyword}{class }TrackerContext \{}
\DoxyCodeLine{7525 }
\DoxyCodeLine{7526         \textcolor{keyword}{enum} RunState \{}
\DoxyCodeLine{7527             NotStarted,}
\DoxyCodeLine{7528             Executing,}
\DoxyCodeLine{7529             CompletedCycle}
\DoxyCodeLine{7530         \};}
\DoxyCodeLine{7531 }
\DoxyCodeLine{7532         ITrackerPtr m\_rootTracker;}
\DoxyCodeLine{7533         ITracker* m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{7534         RunState m\_runState = NotStarted;}
\DoxyCodeLine{7535 }
\DoxyCodeLine{7536     \textcolor{keyword}{public}:}
\DoxyCodeLine{7537 }
\DoxyCodeLine{7538         ITracker\& startRun();}
\DoxyCodeLine{7539         \textcolor{keywordtype}{void} endRun();}
\DoxyCodeLine{7540 }
\DoxyCodeLine{7541         \textcolor{keywordtype}{void} startCycle();}
\DoxyCodeLine{7542         \textcolor{keywordtype}{void} completeCycle();}
\DoxyCodeLine{7543 }
\DoxyCodeLine{7544         \textcolor{keywordtype}{bool} completedCycle() \textcolor{keyword}{const};}
\DoxyCodeLine{7545         ITracker\& currentTracker();}
\DoxyCodeLine{7546         \textcolor{keywordtype}{void} setCurrentTracker( ITracker* tracker );}
\DoxyCodeLine{7547     \};}
\DoxyCodeLine{7548 }
\DoxyCodeLine{7549     \textcolor{keyword}{class }TrackerBase : \textcolor{keyword}{public} ITracker \{}
\DoxyCodeLine{7550     \textcolor{keyword}{protected}:}
\DoxyCodeLine{7551         \textcolor{keyword}{enum} CycleState \{}
\DoxyCodeLine{7552             NotStarted,}
\DoxyCodeLine{7553             Executing,}
\DoxyCodeLine{7554             ExecutingChildren,}
\DoxyCodeLine{7555             NeedsAnotherRun,}
\DoxyCodeLine{7556             CompletedSuccessfully,}
\DoxyCodeLine{7557             Failed}
\DoxyCodeLine{7558         \};}
\DoxyCodeLine{7559 }
\DoxyCodeLine{7560         \textcolor{keyword}{using} Children = std::vector<ITrackerPtr>;}
\DoxyCodeLine{7561         TrackerContext\& m\_ctx;}
\DoxyCodeLine{7562         ITracker* m\_parent;}
\DoxyCodeLine{7563         Children m\_children;}
\DoxyCodeLine{7564         CycleState m\_runState = NotStarted;}
\DoxyCodeLine{7565 }
\DoxyCodeLine{7566     \textcolor{keyword}{public}:}
\DoxyCodeLine{7567         TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7568 }
\DoxyCodeLine{7569         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7570         \textcolor{keywordtype}{bool} isSuccessfullyCompleted() \textcolor{keyword}{const override};}
\DoxyCodeLine{7571         \textcolor{keywordtype}{bool} isOpen() \textcolor{keyword}{const override};}
\DoxyCodeLine{7572         \textcolor{keywordtype}{bool} hasChildren() \textcolor{keyword}{const override};}
\DoxyCodeLine{7573         \textcolor{keywordtype}{bool} hasStarted()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{7574             \textcolor{keywordflow}{return} m\_runState != NotStarted;}
\DoxyCodeLine{7575         \}}
\DoxyCodeLine{7576 }
\DoxyCodeLine{7577         \textcolor{keywordtype}{void} addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \textcolor{keyword}{override};}
\DoxyCodeLine{7578 }
\DoxyCodeLine{7579         ITrackerPtr findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \textcolor{keyword}{override};}
\DoxyCodeLine{7580         ITracker\& parent() \textcolor{keyword}{override};}
\DoxyCodeLine{7581 }
\DoxyCodeLine{7582         \textcolor{keywordtype}{void} openChild() \textcolor{keyword}{override};}
\DoxyCodeLine{7583 }
\DoxyCodeLine{7584         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7585         \textcolor{keywordtype}{bool} isGeneratorTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7586 }
\DoxyCodeLine{7587         \textcolor{keywordtype}{void} open();}
\DoxyCodeLine{7588 }
\DoxyCodeLine{7589         \textcolor{keywordtype}{void} close() \textcolor{keyword}{override};}
\DoxyCodeLine{7590         \textcolor{keywordtype}{void} fail() \textcolor{keyword}{override};}
\DoxyCodeLine{7591         \textcolor{keywordtype}{void} markAsNeedingAnotherRun() \textcolor{keyword}{override};}
\DoxyCodeLine{7592 }
\DoxyCodeLine{7593     \textcolor{keyword}{private}:}
\DoxyCodeLine{7594         \textcolor{keywordtype}{void} moveToParent();}
\DoxyCodeLine{7595         \textcolor{keywordtype}{void} moveToThis();}
\DoxyCodeLine{7596     \};}
\DoxyCodeLine{7597 }
\DoxyCodeLine{7598     \textcolor{keyword}{class }SectionTracker : \textcolor{keyword}{public} TrackerBase \{}
\DoxyCodeLine{7599         std::vector<std::string> m\_filters;}
\DoxyCodeLine{7600         std::string m\_trimmed\_name;}
\DoxyCodeLine{7601     \textcolor{keyword}{public}:}
\DoxyCodeLine{7602         SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent );}
\DoxyCodeLine{7603 }
\DoxyCodeLine{7604         \textcolor{keywordtype}{bool} isSectionTracker() \textcolor{keyword}{const override};}
\DoxyCodeLine{7605 }
\DoxyCodeLine{7606         \textcolor{keywordtype}{bool} isComplete() \textcolor{keyword}{const override};}
\DoxyCodeLine{7607 }
\DoxyCodeLine{7608         \textcolor{keyword}{static} SectionTracker\& acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation );}
\DoxyCodeLine{7609 }
\DoxyCodeLine{7610         \textcolor{keywordtype}{void} tryOpen();}
\DoxyCodeLine{7611 }
\DoxyCodeLine{7612         \textcolor{keywordtype}{void} addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7613         \textcolor{keywordtype}{void} addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters );}
\DoxyCodeLine{7615         std::vector<std::string> \textcolor{keyword}{const}\& getFilters() \textcolor{keyword}{const};}
\DoxyCodeLine{7617         std::string \textcolor{keyword}{const}\& trimmedName() \textcolor{keyword}{const};}
\DoxyCodeLine{7618     \};}
\DoxyCodeLine{7619 }
\DoxyCodeLine{7620 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{7621 }
\DoxyCodeLine{7622 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{7623 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{7624 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{7625 }
\DoxyCodeLine{7626 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7627 }
\DoxyCodeLine{7628 \textcolor{comment}{// end catch\_test\_case\_tracker.h}}
\DoxyCodeLine{7629 }
\DoxyCodeLine{7630 \textcolor{comment}{// start catch\_leak\_detector.h}}
\DoxyCodeLine{7631 }
\DoxyCodeLine{7632 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7633 }
\DoxyCodeLine{7634     \textcolor{keyword}{struct }LeakDetector \{}
\DoxyCodeLine{7635         LeakDetector();}
\DoxyCodeLine{7636         \string~LeakDetector();}
\DoxyCodeLine{7637     \};}
\DoxyCodeLine{7638 }
\DoxyCodeLine{7639 \}}
\DoxyCodeLine{7640 \textcolor{comment}{// end catch\_leak\_detector.h}}
\DoxyCodeLine{7641 \textcolor{comment}{// Cpp files will be included in the single-\/header file here}}
\DoxyCodeLine{7642 \textcolor{comment}{// start catch\_stats.cpp}}
\DoxyCodeLine{7643 }
\DoxyCodeLine{7644 \textcolor{comment}{// Statistical analysis tools}}
\DoxyCodeLine{7645 }
\DoxyCodeLine{7646 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{7647 }
\DoxyCodeLine{7648 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{7649 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{7650 }
\DoxyCodeLine{7651 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7652 \textcolor{preprocessor}{\#include <future>}}
\DoxyCodeLine{7653 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7654 }
\DoxyCodeLine{7655 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7656     \textcolor{keywordtype}{double} erf\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7657         \textcolor{comment}{// Code accompanying the article "{}Approximating the erfinv function"{} in GPU Computing Gems, Volume 2}}
\DoxyCodeLine{7658         \textcolor{keywordtype}{double} w, p;}
\DoxyCodeLine{7659 }
\DoxyCodeLine{7660         w = -\/log((1.0 -\/ x) * (1.0 + x));}
\DoxyCodeLine{7661 }
\DoxyCodeLine{7662         \textcolor{keywordflow}{if} (w < 6.250000) \{}
\DoxyCodeLine{7663             w = w -\/ 3.125000;}
\DoxyCodeLine{7664             p = -\/3.6444120640178196996e-\/21;}
\DoxyCodeLine{7665             p = -\/1.685059138182016589e-\/19 + p * w;}
\DoxyCodeLine{7666             p = 1.2858480715256400167e-\/18 + p * w;}
\DoxyCodeLine{7667             p = 1.115787767802518096e-\/17 + p * w;}
\DoxyCodeLine{7668             p = -\/1.333171662854620906e-\/16 + p * w;}
\DoxyCodeLine{7669             p = 2.0972767875968561637e-\/17 + p * w;}
\DoxyCodeLine{7670             p = 6.6376381343583238325e-\/15 + p * w;}
\DoxyCodeLine{7671             p = -\/4.0545662729752068639e-\/14 + p * w;}
\DoxyCodeLine{7672             p = -\/8.1519341976054721522e-\/14 + p * w;}
\DoxyCodeLine{7673             p = 2.6335093153082322977e-\/12 + p * w;}
\DoxyCodeLine{7674             p = -\/1.2975133253453532498e-\/11 + p * w;}
\DoxyCodeLine{7675             p = -\/5.4154120542946279317e-\/11 + p * w;}
\DoxyCodeLine{7676             p = 1.051212273321532285e-\/09 + p * w;}
\DoxyCodeLine{7677             p = -\/4.1126339803469836976e-\/09 + p * w;}
\DoxyCodeLine{7678             p = -\/2.9070369957882005086e-\/08 + p * w;}
\DoxyCodeLine{7679             p = 4.2347877827932403518e-\/07 + p * w;}
\DoxyCodeLine{7680             p = -\/1.3654692000834678645e-\/06 + p * w;}
\DoxyCodeLine{7681             p = -\/1.3882523362786468719e-\/05 + p * w;}
\DoxyCodeLine{7682             p = 0.0001867342080340571352 + p * w;}
\DoxyCodeLine{7683             p = -\/0.00074070253416626697512 + p * w;}
\DoxyCodeLine{7684             p = -\/0.0060336708714301490533 + p * w;}
\DoxyCodeLine{7685             p = 0.24015818242558961693 + p * w;}
\DoxyCodeLine{7686             p = 1.6536545626831027356 + p * w;}
\DoxyCodeLine{7687         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (w < 16.000000) \{}
\DoxyCodeLine{7688             w = sqrt(w) -\/ 3.250000;}
\DoxyCodeLine{7689             p = 2.2137376921775787049e-\/09;}
\DoxyCodeLine{7690             p = 9.0756561938885390979e-\/08 + p * w;}
\DoxyCodeLine{7691             p = -\/2.7517406297064545428e-\/07 + p * w;}
\DoxyCodeLine{7692             p = 1.8239629214389227755e-\/08 + p * w;}
\DoxyCodeLine{7693             p = 1.5027403968909827627e-\/06 + p * w;}
\DoxyCodeLine{7694             p = -\/4.013867526981545969e-\/06 + p * w;}
\DoxyCodeLine{7695             p = 2.9234449089955446044e-\/06 + p * w;}
\DoxyCodeLine{7696             p = 1.2475304481671778723e-\/05 + p * w;}
\DoxyCodeLine{7697             p = -\/4.7318229009055733981e-\/05 + p * w;}
\DoxyCodeLine{7698             p = 6.8284851459573175448e-\/05 + p * w;}
\DoxyCodeLine{7699             p = 2.4031110387097893999e-\/05 + p * w;}
\DoxyCodeLine{7700             p = -\/0.0003550375203628474796 + p * w;}
\DoxyCodeLine{7701             p = 0.00095328937973738049703 + p * w;}
\DoxyCodeLine{7702             p = -\/0.0016882755560235047313 + p * w;}
\DoxyCodeLine{7703             p = 0.0024914420961078508066 + p * w;}
\DoxyCodeLine{7704             p = -\/0.0037512085075692412107 + p * w;}
\DoxyCodeLine{7705             p = 0.005370914553590063617 + p * w;}
\DoxyCodeLine{7706             p = 1.0052589676941592334 + p * w;}
\DoxyCodeLine{7707             p = 3.0838856104922207635 + p * w;}
\DoxyCodeLine{7708         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{7709             w = sqrt(w) -\/ 5.000000;}
\DoxyCodeLine{7710             p = -\/2.7109920616438573243e-\/11;}
\DoxyCodeLine{7711             p = -\/2.5556418169965252055e-\/10 + p * w;}
\DoxyCodeLine{7712             p = 1.5076572693500548083e-\/09 + p * w;}
\DoxyCodeLine{7713             p = -\/3.7894654401267369937e-\/09 + p * w;}
\DoxyCodeLine{7714             p = 7.6157012080783393804e-\/09 + p * w;}
\DoxyCodeLine{7715             p = -\/1.4960026627149240478e-\/08 + p * w;}
\DoxyCodeLine{7716             p = 2.9147953450901080826e-\/08 + p * w;}
\DoxyCodeLine{7717             p = -\/6.7711997758452339498e-\/08 + p * w;}
\DoxyCodeLine{7718             p = 2.2900482228026654717e-\/07 + p * w;}
\DoxyCodeLine{7719             p = -\/9.9298272942317002539e-\/07 + p * w;}
\DoxyCodeLine{7720             p = 4.5260625972231537039e-\/06 + p * w;}
\DoxyCodeLine{7721             p = -\/1.9681778105531670567e-\/05 + p * w;}
\DoxyCodeLine{7722             p = 7.5995277030017761139e-\/05 + p * w;}
\DoxyCodeLine{7723             p = -\/0.00021503011930044477347 + p * w;}
\DoxyCodeLine{7724             p = -\/0.00013871931833623122026 + p * w;}
\DoxyCodeLine{7725             p = 1.0103004648645343977 + p * w;}
\DoxyCodeLine{7726             p = 4.8499064014085844221 + p * w;}
\DoxyCodeLine{7727         \}}
\DoxyCodeLine{7728         \textcolor{keywordflow}{return} p * x;}
\DoxyCodeLine{7729     \}}
\DoxyCodeLine{7730 }
\DoxyCodeLine{7731     \textcolor{keywordtype}{double} standard\_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7732         \textcolor{keyword}{auto} m = Catch::Benchmark::Detail::mean(first, last);}
\DoxyCodeLine{7733         \textcolor{keywordtype}{double} variance = std::accumulate(first, last, 0., [m](\textcolor{keywordtype}{double} a, \textcolor{keywordtype}{double} b) \{}
\DoxyCodeLine{7734             \textcolor{keywordtype}{double} diff = b -\/ m;}
\DoxyCodeLine{7735             \textcolor{keywordflow}{return} a + diff * diff;}
\DoxyCodeLine{7736             \}) / (last -\/ first);}
\DoxyCodeLine{7737             \textcolor{keywordflow}{return} std::sqrt(variance);}
\DoxyCodeLine{7738     \}}
\DoxyCodeLine{7739 }
\DoxyCodeLine{7740 \}}
\DoxyCodeLine{7741 }
\DoxyCodeLine{7742 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7743     \textcolor{keyword}{namespace }Benchmark \{}
\DoxyCodeLine{7744         \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7745 }
\DoxyCodeLine{7746             \textcolor{keywordtype}{double} weighted\_average\_quantile(\textcolor{keywordtype}{int} k, \textcolor{keywordtype}{int} q, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7747                 \textcolor{keyword}{auto} count = last -\/ first;}
\DoxyCodeLine{7748                 \textcolor{keywordtype}{double} idx = (count -\/ 1) * k / static\_cast<double>(q);}
\DoxyCodeLine{7749                 \textcolor{keywordtype}{int} j = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(idx);}
\DoxyCodeLine{7750                 \textcolor{keywordtype}{double} g = idx -\/ j;}
\DoxyCodeLine{7751                 std::nth\_element(first, first + j, last);}
\DoxyCodeLine{7752                 \textcolor{keyword}{auto} xj = first[j];}
\DoxyCodeLine{7753                 \textcolor{keywordflow}{if} (g == 0) \textcolor{keywordflow}{return} xj;}
\DoxyCodeLine{7754 }
\DoxyCodeLine{7755                 \textcolor{keyword}{auto} xj1 = *std::min\_element(first + (j + 1), last);}
\DoxyCodeLine{7756                 \textcolor{keywordflow}{return} xj + g * (xj1 -\/ xj);}
\DoxyCodeLine{7757             \}}
\DoxyCodeLine{7758 }
\DoxyCodeLine{7759             \textcolor{keywordtype}{double} erfc\_inv(\textcolor{keywordtype}{double} x) \{}
\DoxyCodeLine{7760                 \textcolor{keywordflow}{return} erf\_inv(1.0 -\/ x);}
\DoxyCodeLine{7761             \}}
\DoxyCodeLine{7762 }
\DoxyCodeLine{7763             \textcolor{keywordtype}{double} normal\_quantile(\textcolor{keywordtype}{double} p) \{}
\DoxyCodeLine{7764                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{double} ROOT\_TWO = std::sqrt(2.0);}
\DoxyCodeLine{7765 }
\DoxyCodeLine{7766                 \textcolor{keywordtype}{double} result = 0.0;}
\DoxyCodeLine{7767                 assert(p >= 0 \&\& p <= 1);}
\DoxyCodeLine{7768                 \textcolor{keywordflow}{if} (p < 0 || p > 1) \{}
\DoxyCodeLine{7769                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7770                 \}}
\DoxyCodeLine{7771 }
\DoxyCodeLine{7772                 result = -\/erfc\_inv(2.0 * p);}
\DoxyCodeLine{7773                 \textcolor{comment}{// result *= normal distribution standard deviation (1.0) * sqrt(2)}}
\DoxyCodeLine{7774                 result *= \textcolor{comment}{/*sd * */} ROOT\_TWO;}
\DoxyCodeLine{7775                 \textcolor{comment}{// result += normal disttribution mean (0)}}
\DoxyCodeLine{7776                 \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{7777             \}}
\DoxyCodeLine{7778 }
\DoxyCodeLine{7779             \textcolor{keywordtype}{double} outlier\_variance(Estimate<double> mean, Estimate<double> stddev, \textcolor{keywordtype}{int} n) \{}
\DoxyCodeLine{7780                 \textcolor{keywordtype}{double} sb = stddev.point;}
\DoxyCodeLine{7781                 \textcolor{keywordtype}{double} mn = mean.point / n;}
\DoxyCodeLine{7782                 \textcolor{keywordtype}{double} mg\_min = mn / 2.;}
\DoxyCodeLine{7783                 \textcolor{keywordtype}{double} sg = (std::min)(mg\_min / 4., sb / std::sqrt(n));}
\DoxyCodeLine{7784                 \textcolor{keywordtype}{double} sg2 = sg * sg;}
\DoxyCodeLine{7785                 \textcolor{keywordtype}{double} sb2 = sb * sb;}
\DoxyCodeLine{7786 }
\DoxyCodeLine{7787                 \textcolor{keyword}{auto} c\_max = [n, mn, sb2, sg2](\textcolor{keywordtype}{double} x) -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{7788                     \textcolor{keywordtype}{double} k = mn -\/ x;}
\DoxyCodeLine{7789                     \textcolor{keywordtype}{double} d = k * k;}
\DoxyCodeLine{7790                     \textcolor{keywordtype}{double} nd = n * d;}
\DoxyCodeLine{7791                     \textcolor{keywordtype}{double} k0 = -\/n * nd;}
\DoxyCodeLine{7792                     \textcolor{keywordtype}{double} k1 = sb2 -\/ n * sg2 + nd;}
\DoxyCodeLine{7793                     \textcolor{keywordtype}{double} det = k1 * k1 -\/ 4 * sg2 * k0;}
\DoxyCodeLine{7794                     \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})(-\/2. * k0 / (k1 + std::sqrt(det)));}
\DoxyCodeLine{7795                 \};}
\DoxyCodeLine{7796 }
\DoxyCodeLine{7797                 \textcolor{keyword}{auto} var\_out = [n, sb2, sg2](\textcolor{keywordtype}{double} c) \{}
\DoxyCodeLine{7798                     \textcolor{keywordtype}{double} nc = n -\/ c;}
\DoxyCodeLine{7799                     \textcolor{keywordflow}{return} (nc / n) * (sb2 -\/ nc * sg2);}
\DoxyCodeLine{7800                 \};}
\DoxyCodeLine{7801 }
\DoxyCodeLine{7802                 \textcolor{keywordflow}{return} (std::min)(var\_out(1), var\_out((std::min)(c\_max(0.), c\_max(mg\_min)))) / sb2;}
\DoxyCodeLine{7803             \}}
\DoxyCodeLine{7804 }
\DoxyCodeLine{7805             bootstrap\_analysis analyse\_samples(\textcolor{keywordtype}{double} confidence\_level, \textcolor{keywordtype}{int} n\_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) \{}
\DoxyCodeLine{7806                 CATCH\_INTERNAL\_START\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7807                 CATCH\_INTERNAL\_SUPPRESS\_GLOBALS\_WARNINGS}
\DoxyCodeLine{7808                 \textcolor{keyword}{static} std::random\_device entropy;}
\DoxyCodeLine{7809                 CATCH\_INTERNAL\_STOP\_WARNINGS\_SUPPRESSION}
\DoxyCodeLine{7810 }
\DoxyCodeLine{7811                 \textcolor{keyword}{auto} n = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(last -\/ first); \textcolor{comment}{// seriously, one can't use integral types without hell in C++}}
\DoxyCodeLine{7812 }
\DoxyCodeLine{7813                 \textcolor{keyword}{auto} mean = \&Detail::mean<std::vector<double>::iterator>;}
\DoxyCodeLine{7814                 \textcolor{keyword}{auto} stddev = \&standard\_deviation;}
\DoxyCodeLine{7815 }
\DoxyCodeLine{7816 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_USE\_ASYNC)}}
\DoxyCodeLine{7817                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7818                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7819                     \textcolor{keywordflow}{return} std::async(std::launch::async, [=] \{}
\DoxyCodeLine{7820                         std::mt19937 rng(seed);}
\DoxyCodeLine{7821                         \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7822                         \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7823                     \});}
\DoxyCodeLine{7824                 \};}
\DoxyCodeLine{7825 }
\DoxyCodeLine{7826                 \textcolor{keyword}{auto} mean\_future = Estimate(mean);}
\DoxyCodeLine{7827                 \textcolor{keyword}{auto} stddev\_future = Estimate(stddev);}
\DoxyCodeLine{7828 }
\DoxyCodeLine{7829                 \textcolor{keyword}{auto} mean\_estimate = mean\_future.get();}
\DoxyCodeLine{7830                 \textcolor{keyword}{auto} stddev\_estimate = stddev\_future.get();}
\DoxyCodeLine{7831 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{7832                 \textcolor{keyword}{auto} Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) \{}
\DoxyCodeLine{7833                     \textcolor{keyword}{auto} seed = entropy();}
\DoxyCodeLine{7834                     std::mt19937 rng(seed);}
\DoxyCodeLine{7835                     \textcolor{keyword}{auto} resampled = resample(rng, n\_resamples, first, last, f);}
\DoxyCodeLine{7836                     \textcolor{keywordflow}{return} bootstrap(confidence\_level, first, last, resampled, f);}
\DoxyCodeLine{7837                 \};}
\DoxyCodeLine{7838 }
\DoxyCodeLine{7839                 \textcolor{keyword}{auto} mean\_estimate = Estimate(mean);}
\DoxyCodeLine{7840                 \textcolor{keyword}{auto} stddev\_estimate = Estimate(stddev);}
\DoxyCodeLine{7841 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_USE\_ASYNC}}
\DoxyCodeLine{7842 }
\DoxyCodeLine{7843                 \textcolor{keywordtype}{double} outlier\_variance = Detail::outlier\_variance(mean\_estimate, stddev\_estimate, n);}
\DoxyCodeLine{7844 }
\DoxyCodeLine{7845                 \textcolor{keywordflow}{return} \{ mean\_estimate, stddev\_estimate, outlier\_variance \};}
\DoxyCodeLine{7846             \}}
\DoxyCodeLine{7847         \} \textcolor{comment}{// namespace Detail}}
\DoxyCodeLine{7848     \} \textcolor{comment}{// namespace Benchmark}}
\DoxyCodeLine{7849 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{7850 }
\DoxyCodeLine{7851 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{7852 \textcolor{comment}{// end catch\_stats.cpp}}
\DoxyCodeLine{7853 \textcolor{comment}{// start catch\_approx.cpp}}
\DoxyCodeLine{7854 }
\DoxyCodeLine{7855 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{7856 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{7857 }
\DoxyCodeLine{7858 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{7859 }
\DoxyCodeLine{7860 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{7861 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{7862 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{7863     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{7864 \}}
\DoxyCodeLine{7865 }
\DoxyCodeLine{7866 \}}
\DoxyCodeLine{7867 }
\DoxyCodeLine{7868 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7869 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{7870 }
\DoxyCodeLine{7871     Approx::Approx ( \textcolor{keywordtype}{double} value )}
\DoxyCodeLine{7872     :   m\_epsilon( std::numeric\_limits<float>::epsilon()*100 ),}
\DoxyCodeLine{7873         m\_margin( 0.0 ),}
\DoxyCodeLine{7874         m\_scale( 0.0 ),}
\DoxyCodeLine{7875         m\_value( value )}
\DoxyCodeLine{7876     \{\}}
\DoxyCodeLine{7877 }
\DoxyCodeLine{7878     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} Approx::custom() \{}
\DoxyCodeLine{7879         \textcolor{keywordflow}{return} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}}( 0 );}
\DoxyCodeLine{7880     \}}
\DoxyCodeLine{7881 }
\DoxyCodeLine{7882     \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Approx}} Approx::operator-\/()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7883         \textcolor{keyword}{auto} temp(*\textcolor{keyword}{this});}
\DoxyCodeLine{7884         temp.m\_value = -\/temp.m\_value;}
\DoxyCodeLine{7885         \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{7886     \}}
\DoxyCodeLine{7887 }
\DoxyCodeLine{7888     std::string Approx::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7889         ReusableStringStream rss;}
\DoxyCodeLine{7890         rss << \textcolor{stringliteral}{"{}Approx( "{}} << ::Catch::Detail::stringify( m\_value ) << \textcolor{stringliteral}{"{} )"{}};}
\DoxyCodeLine{7891         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{7892     \}}
\DoxyCodeLine{7893 }
\DoxyCodeLine{7894     \textcolor{keywordtype}{bool} Approx::equalityComparisonImpl(\textcolor{keyword}{const} \textcolor{keywordtype}{double} other)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{7895         \textcolor{comment}{// First try with fixed margin, then compute margin based on epsilon, scale and Approx's value}}
\DoxyCodeLine{7896         \textcolor{comment}{// Thanks to Richard Harris for his help refining the scaled margin value}}
\DoxyCodeLine{7897         \textcolor{keywordflow}{return} marginComparison(m\_value, other, m\_margin)}
\DoxyCodeLine{7898             || marginComparison(m\_value, other, m\_epsilon * (m\_scale + std::fabs(std::isinf(m\_value)? 0 : m\_value)));}
\DoxyCodeLine{7899     \}}
\DoxyCodeLine{7900 }
\DoxyCodeLine{7901     \textcolor{keywordtype}{void} Approx::setMargin(\textcolor{keywordtype}{double} newMargin) \{}
\DoxyCodeLine{7902         CATCH\_ENFORCE(newMargin >= 0,}
\DoxyCodeLine{7903             \textcolor{stringliteral}{"{}Invalid Approx::margin: "{}} << newMargin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7904             << \textcolor{stringliteral}{"{} Approx::Margin has to be non-\/negative."{}});}
\DoxyCodeLine{7905         m\_margin = newMargin;}
\DoxyCodeLine{7906     \}}
\DoxyCodeLine{7907 }
\DoxyCodeLine{7908     \textcolor{keywordtype}{void} Approx::setEpsilon(\textcolor{keywordtype}{double} newEpsilon) \{}
\DoxyCodeLine{7909         CATCH\_ENFORCE(newEpsilon >= 0 \&\& newEpsilon <= 1.0,}
\DoxyCodeLine{7910             \textcolor{stringliteral}{"{}Invalid Approx::epsilon: "{}} << newEpsilon << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{7911             << \textcolor{stringliteral}{"{} Approx::epsilon has to be in [0, 1]"{}});}
\DoxyCodeLine{7912         m\_epsilon = newEpsilon;}
\DoxyCodeLine{7913     \}}
\DoxyCodeLine{7914 }
\DoxyCodeLine{7915 \} \textcolor{comment}{// end namespace Detail}}
\DoxyCodeLine{7916 }
\DoxyCodeLine{7917 \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{7918     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) \{}
\DoxyCodeLine{7919         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7920     \}}
\DoxyCodeLine{7921     Detail::Approx \textcolor{keyword}{operator} \textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) \{}
\DoxyCodeLine{7922         \textcolor{keywordflow}{return} Detail::Approx(val);}
\DoxyCodeLine{7923     \}}
\DoxyCodeLine{7924 \} \textcolor{comment}{// end namespace literals}}
\DoxyCodeLine{7925 }
\DoxyCodeLine{7926 std::string StringMaker<Catch::Detail::Approx>::convert(\mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}} \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{7927     \textcolor{keywordflow}{return} value.toString();}
\DoxyCodeLine{7928 \}}
\DoxyCodeLine{7929 }
\DoxyCodeLine{7930 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{7931 \textcolor{comment}{// end catch\_approx.cpp}}
\DoxyCodeLine{7932 \textcolor{comment}{// start catch\_assertionhandler.cpp}}
\DoxyCodeLine{7933 }
\DoxyCodeLine{7934 \textcolor{comment}{// start catch\_debugger.h}}
\DoxyCodeLine{7935 }
\DoxyCodeLine{7936 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7937     \textcolor{keywordtype}{bool} isDebuggerActive();}
\DoxyCodeLine{7938 \}}
\DoxyCodeLine{7939 }
\DoxyCodeLine{7940 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{7941 }
\DoxyCodeLine{7942 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7943 \textcolor{preprocessor}{        \#define CATCH\_TRAP() \_\_asm\_\_("{}int \$3\(\backslash\)n"{}} : : ) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7944 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7945 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd4200000"{}})}
\DoxyCodeLine{7946 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7947 }
\DoxyCodeLine{7948 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{7949 }
\DoxyCodeLine{7950     \textcolor{comment}{// use inline assembler}}
\DoxyCodeLine{7951 \textcolor{preprocessor}{    \#if defined(\_\_i386\_\_) || defined(\_\_x86\_64\_\_)}}
\DoxyCodeLine{7952 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}int \$3"{}})}
\DoxyCodeLine{7953 \textcolor{preprocessor}{    \#elif defined(\_\_aarch64\_\_)}}
\DoxyCodeLine{7954 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xd4200000"{}})}
\DoxyCodeLine{7955 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\& !defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7956 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xe7f001f0"{}})}
\DoxyCodeLine{7957 \textcolor{preprocessor}{    \#elif defined(\_\_arm\_\_) \&\&  defined(\_\_thumb\_\_)}}
\DoxyCodeLine{7958 \textcolor{preprocessor}{        \#define CATCH\_TRAP()  \_\_asm\_\_("{}.inst 0xde01"{}})}
\DoxyCodeLine{7959 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7960 }
\DoxyCodeLine{7961 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{7962     \textcolor{comment}{// If we can use inline assembler, do it because this allows us to break}}
\DoxyCodeLine{7963     \textcolor{comment}{// directly at the location of the failing check instead of breaking inside}}
\DoxyCodeLine{7964     \textcolor{comment}{// raise() called from it, i.e. one stack frame below.}}
\DoxyCodeLine{7965 \textcolor{preprocessor}{    \#if defined(\_\_GNUC\_\_) \&\& (defined(\_\_i386) || defined(\_\_x86\_64))}}
\DoxyCodeLine{7966 \textcolor{preprocessor}{        \#define CATCH\_TRAP() asm volatile ("{}int \$3"{}}) \textcolor{comment}{/* NOLINT */}\textcolor{preprocessor}{}}
\DoxyCodeLine{7967 \textcolor{preprocessor}{    \#else }\textcolor{comment}{// Fall back to the generic way.}}
\DoxyCodeLine{7968 \textcolor{preprocessor}{        \#include <signal.h>}}
\DoxyCodeLine{7969 }
\DoxyCodeLine{7970 \textcolor{preprocessor}{        \#define CATCH\_TRAP() raise(SIGTRAP)}}
\DoxyCodeLine{7971 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7972 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{7973 \textcolor{preprocessor}{    \#define CATCH\_TRAP() \_\_debugbreak()}}
\DoxyCodeLine{7974 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{7975     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{void} \_\_stdcall DebugBreak();}
\DoxyCodeLine{7976 \textcolor{preprocessor}{    \#define CATCH\_TRAP() DebugBreak()}}
\DoxyCodeLine{7977 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7978 }
\DoxyCodeLine{7979 \textcolor{preprocessor}{\#ifndef CATCH\_BREAK\_INTO\_DEBUGGER}}
\DoxyCodeLine{7980 \textcolor{preprocessor}{    \#ifdef CATCH\_TRAP}}
\DoxyCodeLine{7981 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{ if( Catch::isDebuggerActive() ) \{ CATCH\_TRAP(); \} \}()}}
\DoxyCodeLine{7982 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{7983 \textcolor{preprocessor}{        \#define CATCH\_BREAK\_INTO\_DEBUGGER() []\{\}()}}
\DoxyCodeLine{7984 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{7985 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{7986 }
\DoxyCodeLine{7987 \textcolor{comment}{// end catch\_debugger.h}}
\DoxyCodeLine{7988 \textcolor{comment}{// start catch\_run\_context.h}}
\DoxyCodeLine{7989 }
\DoxyCodeLine{7990 \textcolor{comment}{// start catch\_fatal\_condition.h}}
\DoxyCodeLine{7991 }
\DoxyCodeLine{7992 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{7993 }
\DoxyCodeLine{7994 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{7995 }
\DoxyCodeLine{7996     \textcolor{comment}{// Wrapper for platform-\/specific fatal error (signals/SEH) handlers}}
\DoxyCodeLine{7997     \textcolor{comment}{//}}
\DoxyCodeLine{7998     \textcolor{comment}{// Tries to be cooperative with other handlers, and not step over}}
\DoxyCodeLine{7999     \textcolor{comment}{// other handlers. This means that unknown structured exceptions}}
\DoxyCodeLine{8000     \textcolor{comment}{// are passed on, previous signal handlers are called, and so on.}}
\DoxyCodeLine{8001     \textcolor{comment}{//}}
\DoxyCodeLine{8002     \textcolor{comment}{// Can only be instantiated once, and assumes that once a signal}}
\DoxyCodeLine{8003     \textcolor{comment}{// is caught, the binary will end up terminating. Thus, there}}
\DoxyCodeLine{8004     \textcolor{keyword}{class }FatalConditionHandler \{}
\DoxyCodeLine{8005         \textcolor{keywordtype}{bool} m\_started = \textcolor{keyword}{false};}
\DoxyCodeLine{8006 }
\DoxyCodeLine{8007         \textcolor{comment}{// Install/disengage implementation for specific platform.}}
\DoxyCodeLine{8008         \textcolor{comment}{// Should be if-\/defed to work on current platform, can assume}}
\DoxyCodeLine{8009         \textcolor{comment}{// engage-\/disengage 1:1 pairing.}}
\DoxyCodeLine{8010         \textcolor{keywordtype}{void} engage\_platform();}
\DoxyCodeLine{8011         \textcolor{keywordtype}{void} disengage\_platform();}
\DoxyCodeLine{8012     \textcolor{keyword}{public}:}
\DoxyCodeLine{8013         \textcolor{comment}{// Should also have platform-\/specific implementations as needed}}
\DoxyCodeLine{8014         FatalConditionHandler();}
\DoxyCodeLine{8015         \string~FatalConditionHandler();}
\DoxyCodeLine{8016 }
\DoxyCodeLine{8017         \textcolor{keywordtype}{void} engage() \{}
\DoxyCodeLine{8018             assert(!m\_started \&\& \textcolor{stringliteral}{"{}Handler cannot be installed twice."{}});}
\DoxyCodeLine{8019             m\_started = \textcolor{keyword}{true};}
\DoxyCodeLine{8020             engage\_platform();}
\DoxyCodeLine{8021         \}}
\DoxyCodeLine{8022 }
\DoxyCodeLine{8023         \textcolor{keywordtype}{void} disengage() \{}
\DoxyCodeLine{8024             assert(m\_started \&\& \textcolor{stringliteral}{"{}Handler cannot be uninstalled without being installed first"{}});}
\DoxyCodeLine{8025             m\_started = \textcolor{keyword}{false};}
\DoxyCodeLine{8026             disengage\_platform();}
\DoxyCodeLine{8027         \}}
\DoxyCodeLine{8028     \};}
\DoxyCodeLine{8029 }
\DoxyCodeLine{8031     \textcolor{keyword}{class }FatalConditionHandlerGuard \{}
\DoxyCodeLine{8032         FatalConditionHandler* m\_handler;}
\DoxyCodeLine{8033     \textcolor{keyword}{public}:}
\DoxyCodeLine{8034         FatalConditionHandlerGuard(FatalConditionHandler* handler):}
\DoxyCodeLine{8035             m\_handler(handler) \{}
\DoxyCodeLine{8036             m\_handler-\/>engage();}
\DoxyCodeLine{8037         \}}
\DoxyCodeLine{8038         \string~FatalConditionHandlerGuard() \{}
\DoxyCodeLine{8039             m\_handler-\/>disengage();}
\DoxyCodeLine{8040         \}}
\DoxyCodeLine{8041     \};}
\DoxyCodeLine{8042 }
\DoxyCodeLine{8043 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8044 }
\DoxyCodeLine{8045 \textcolor{comment}{// end catch\_fatal\_condition.h}}
\DoxyCodeLine{8046 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8047 }
\DoxyCodeLine{8048 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8049 }
\DoxyCodeLine{8050     \textcolor{keyword}{struct }IMutableContext;}
\DoxyCodeLine{8051 }
\DoxyCodeLine{8053 }
\DoxyCodeLine{8054     \textcolor{keyword}{class }RunContext : \textcolor{keyword}{public} IResultCapture, \textcolor{keyword}{public} IRunner \{}
\DoxyCodeLine{8055 }
\DoxyCodeLine{8056     \textcolor{keyword}{public}:}
\DoxyCodeLine{8057         RunContext( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8058         RunContext\& operator =( RunContext \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{8059 }
\DoxyCodeLine{8060         \textcolor{keyword}{explicit} RunContext( IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{8061 }
\DoxyCodeLine{8062         \string~RunContext() \textcolor{keyword}{override};}
\DoxyCodeLine{8063 }
\DoxyCodeLine{8064         \textcolor{keywordtype}{void} testGroupStarting( std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8065         \textcolor{keywordtype}{void} testGroupEnded( std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount );}
\DoxyCodeLine{8066 }
\DoxyCodeLine{8067         Totals runTest(TestCase \textcolor{keyword}{const}\& testCase);}
\DoxyCodeLine{8068 }
\DoxyCodeLine{8069         IConfigPtr config() \textcolor{keyword}{const};}
\DoxyCodeLine{8070         IStreamingReporter\& reporter() \textcolor{keyword}{const};}
\DoxyCodeLine{8071 }
\DoxyCodeLine{8072     \textcolor{keyword}{public}: \textcolor{comment}{// IResultCapture}}
\DoxyCodeLine{8073 }
\DoxyCodeLine{8074         \textcolor{comment}{// Assertion handlers}}
\DoxyCodeLine{8075         \textcolor{keywordtype}{void} handleExpr}
\DoxyCodeLine{8076                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8077                     ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{8078                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8079         \textcolor{keywordtype}{void} handleMessage}
\DoxyCodeLine{8080                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8081                     ResultWas::OfType resultType,}
\DoxyCodeLine{8082                     StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8083                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8084         \textcolor{keywordtype}{void} handleUnexpectedExceptionNotThrown}
\DoxyCodeLine{8085                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8086                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8087         \textcolor{keywordtype}{void} handleUnexpectedInflightException}
\DoxyCodeLine{8088                 (   AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{8089                     std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{8090                     AssertionReaction\& reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8091         \textcolor{keywordtype}{void} handleIncomplete}
\DoxyCodeLine{8092                 (   AssertionInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8093         \textcolor{keywordtype}{void} handleNonExpr}
\DoxyCodeLine{8094                 (   AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{8095                     ResultWas::OfType resultType,}
\DoxyCodeLine{8096                     AssertionReaction \&reaction ) \textcolor{keyword}{override};}
\DoxyCodeLine{8097 }
\DoxyCodeLine{8098         \textcolor{keywordtype}{bool} sectionStarted( SectionInfo \textcolor{keyword}{const}\& sectionInfo, Counts\& assertions ) \textcolor{keyword}{override};}
\DoxyCodeLine{8099 }
\DoxyCodeLine{8100         \textcolor{keywordtype}{void} sectionEnded( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8101         \textcolor{keywordtype}{void} sectionEndedEarly( SectionEndInfo \textcolor{keyword}{const}\& endInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{8102 }
\DoxyCodeLine{8103         \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \textcolor{keyword}{override};}
\DoxyCodeLine{8104 }
\DoxyCodeLine{8105 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{8106         \textcolor{keywordtype}{void} benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \textcolor{keyword}{override};}
\DoxyCodeLine{8107         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \textcolor{keyword}{override};}
\DoxyCodeLine{8108         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \textcolor{keyword}{override};}
\DoxyCodeLine{8109         \textcolor{keywordtype}{void} benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \textcolor{keyword}{override};}
\DoxyCodeLine{8110 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{8111 }
\DoxyCodeLine{8112         \textcolor{keywordtype}{void} pushScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8113         \textcolor{keywordtype}{void} popScopedMessage( MessageInfo \textcolor{keyword}{const}\& message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8114 }
\DoxyCodeLine{8115         \textcolor{keywordtype}{void} emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \textcolor{keyword}{override};}
\DoxyCodeLine{8116 }
\DoxyCodeLine{8117         std::string getCurrentTestName() \textcolor{keyword}{const override};}
\DoxyCodeLine{8118 }
\DoxyCodeLine{8119         \textcolor{keyword}{const} AssertionResult* getLastResult() \textcolor{keyword}{const override};}
\DoxyCodeLine{8120 }
\DoxyCodeLine{8121         \textcolor{keywordtype}{void} exceptionEarlyReported() \textcolor{keyword}{override};}
\DoxyCodeLine{8122 }
\DoxyCodeLine{8123         \textcolor{keywordtype}{void} handleFatalErrorCondition( StringRef message ) \textcolor{keyword}{override};}
\DoxyCodeLine{8124 }
\DoxyCodeLine{8125         \textcolor{keywordtype}{bool} lastAssertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8126 }
\DoxyCodeLine{8127         \textcolor{keywordtype}{void} assertionPassed() \textcolor{keyword}{override};}
\DoxyCodeLine{8128 }
\DoxyCodeLine{8129     \textcolor{keyword}{public}:}
\DoxyCodeLine{8130         \textcolor{comment}{// !TBD We need to do this another way!}}
\DoxyCodeLine{8131         \textcolor{keywordtype}{bool} aborting() const final;}
\DoxyCodeLine{8132 }
\DoxyCodeLine{8133     private:}
\DoxyCodeLine{8134 }
\DoxyCodeLine{8135         \textcolor{keywordtype}{void} runCurrentTest( std::\textcolor{keywordtype}{string}\& redirectedCout, std::\textcolor{keywordtype}{string}\& redirectedCerr );}
\DoxyCodeLine{8136         \textcolor{keywordtype}{void} invokeActiveTestCase();}
\DoxyCodeLine{8137 }
\DoxyCodeLine{8138         \textcolor{keywordtype}{void} resetAssertionInfo();}
\DoxyCodeLine{8139         \textcolor{keywordtype}{bool} testForMissingAssertions( Counts\& assertions );}
\DoxyCodeLine{8140 }
\DoxyCodeLine{8141         \textcolor{keywordtype}{void} assertionEnded( AssertionResult const\& result );}
\DoxyCodeLine{8142         \textcolor{keywordtype}{void} reportExpr}
\DoxyCodeLine{8143                 (   AssertionInfo const \&info,}
\DoxyCodeLine{8144                     ResultWas::OfType resultType,}
\DoxyCodeLine{8145                     ITransientExpression const *expr,}
\DoxyCodeLine{8146                     \textcolor{keywordtype}{bool} negated );}
\DoxyCodeLine{8147 }
\DoxyCodeLine{8148         \textcolor{keywordtype}{void} populateReaction( AssertionReaction\& reaction );}
\DoxyCodeLine{8149 }
\DoxyCodeLine{8150     private:}
\DoxyCodeLine{8151 }
\DoxyCodeLine{8152         \textcolor{keywordtype}{void} handleUnfinishedSections();}
\DoxyCodeLine{8153 }
\DoxyCodeLine{8154         TestRunInfo m\_runInfo;}
\DoxyCodeLine{8155         IMutableContext\& m\_context;}
\DoxyCodeLine{8156         TestCase const* m\_activeTestCase = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8157         ITracker* m\_testCaseTracker = \textcolor{keywordtype}{nullptr};}
\DoxyCodeLine{8158         Option<AssertionResult> m\_lastResult;}
\DoxyCodeLine{8159 }
\DoxyCodeLine{8160         IConfigPtr m\_config;}
\DoxyCodeLine{8161         Totals m\_totals;}
\DoxyCodeLine{8162         IStreamingReporterPtr m\_reporter;}
\DoxyCodeLine{8163         std::vector<MessageInfo> m\_messages;}
\DoxyCodeLine{8164         std::vector<ScopedMessage> m\_messageScopes; \textcolor{comment}{/* Keeps owners of so-\/called unscoped messages. */}}
\DoxyCodeLine{8165         AssertionInfo m\_lastAssertionInfo;}
\DoxyCodeLine{8166         std::vector<SectionEndInfo> m\_unfinishedSections;}
\DoxyCodeLine{8167         std::vector<ITracker*> m\_activeSections;}
\DoxyCodeLine{8168         TrackerContext m\_trackerContext;}
\DoxyCodeLine{8169         FatalConditionHandler m\_fatalConditionhandler;}
\DoxyCodeLine{8170         \textcolor{keywordtype}{bool} m\_lastAssertionPassed = false;}
\DoxyCodeLine{8171         \textcolor{keywordtype}{bool} m\_shouldReportUnexpected = true;}
\DoxyCodeLine{8172         \textcolor{keywordtype}{bool} m\_includeSuccessfulResults;}
\DoxyCodeLine{8173     \};}
\DoxyCodeLine{8174 }
\DoxyCodeLine{8175     \textcolor{keywordtype}{void} seedRng(IConfig const\& config);}
\DoxyCodeLine{8176     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed();}
\DoxyCodeLine{8177 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8178 }
\DoxyCodeLine{8179 \textcolor{comment}{// end catch\_run\_context.h}}
\DoxyCodeLine{8180 namespace Catch \{}
\DoxyCodeLine{8181 }
\DoxyCodeLine{8182     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{8183         \textcolor{keyword}{auto} operator <<( std::ostream\& os, ITransientExpression \textcolor{keyword}{const}\& expr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8184             expr.streamReconstructedExpression( os );}
\DoxyCodeLine{8185             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8186         \}}
\DoxyCodeLine{8187     \}}
\DoxyCodeLine{8188 }
\DoxyCodeLine{8189     LazyExpression::LazyExpression( \textcolor{keywordtype}{bool} isNegated )}
\DoxyCodeLine{8190     :   m\_isNegated( isNegated )}
\DoxyCodeLine{8191     \{\}}
\DoxyCodeLine{8192 }
\DoxyCodeLine{8193     LazyExpression::LazyExpression( LazyExpression \textcolor{keyword}{const}\& other ) : m\_isNegated( other.m\_isNegated ) \{\}}
\DoxyCodeLine{8194 }
\DoxyCodeLine{8195     LazyExpression::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8196         \textcolor{keywordflow}{return} m\_transientExpression != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{8197     \}}
\DoxyCodeLine{8198 }
\DoxyCodeLine{8199     \textcolor{keyword}{auto} operator << ( std::ostream\& os, LazyExpression \textcolor{keyword}{const}\& lazyExpr ) -\/> std::ostream\& \{}
\DoxyCodeLine{8200         \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated )}
\DoxyCodeLine{8201             os << \textcolor{stringliteral}{"{}!"{}};}
\DoxyCodeLine{8202 }
\DoxyCodeLine{8203         \textcolor{keywordflow}{if}( lazyExpr ) \{}
\DoxyCodeLine{8204             \textcolor{keywordflow}{if}( lazyExpr.m\_isNegated \&\& lazyExpr.m\_transientExpression-\/>isBinaryExpression() )}
\DoxyCodeLine{8205                 os << \textcolor{stringliteral}{"{}("{}} << *lazyExpr.m\_transientExpression << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{8206             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8207                 os << *lazyExpr.m\_transientExpression;}
\DoxyCodeLine{8208         \}}
\DoxyCodeLine{8209         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8210             os << \textcolor{stringliteral}{"{}\{** error -\/ unchecked empty expression requested **\}"{}};}
\DoxyCodeLine{8211         \}}
\DoxyCodeLine{8212         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8213     \}}
\DoxyCodeLine{8214 }
\DoxyCodeLine{8215     AssertionHandler::AssertionHandler}
\DoxyCodeLine{8216         (   StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{8217             SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{8218             StringRef capturedExpression,}
\DoxyCodeLine{8219             ResultDisposition::Flags resultDisposition )}
\DoxyCodeLine{8220     :   m\_assertionInfo\{ macroName, lineInfo, capturedExpression, resultDisposition \},}
\DoxyCodeLine{8221         m\_resultCapture( getResultCapture() )}
\DoxyCodeLine{8222     \{\}}
\DoxyCodeLine{8223 }
\DoxyCodeLine{8224     \textcolor{keywordtype}{void} AssertionHandler::handleExpr( ITransientExpression \textcolor{keyword}{const}\& expr ) \{}
\DoxyCodeLine{8225         m\_resultCapture.handleExpr( m\_assertionInfo, expr, m\_reaction );}
\DoxyCodeLine{8226     \}}
\DoxyCodeLine{8227     \textcolor{keywordtype}{void} AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{8228         m\_resultCapture.handleMessage( m\_assertionInfo, resultType, message, m\_reaction );}
\DoxyCodeLine{8229     \}}
\DoxyCodeLine{8230 }
\DoxyCodeLine{8231     \textcolor{keyword}{auto} AssertionHandler::allowThrows() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8232         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>allowThrows();}
\DoxyCodeLine{8233     \}}
\DoxyCodeLine{8234 }
\DoxyCodeLine{8235     \textcolor{keywordtype}{void} AssertionHandler::complete() \{}
\DoxyCodeLine{8236         setCompleted();}
\DoxyCodeLine{8237         \textcolor{keywordflow}{if}( m\_reaction.shouldDebugBreak ) \{}
\DoxyCodeLine{8238 }
\DoxyCodeLine{8239             \textcolor{comment}{// If you find your debugger stopping you here then go one level up on the}}
\DoxyCodeLine{8240             \textcolor{comment}{// call-\/stack for the code that caused it (typically a failed assertion)}}
\DoxyCodeLine{8241 }
\DoxyCodeLine{8242             \textcolor{comment}{// (To go back to the test and change execution, jump over the throw, next)}}
\DoxyCodeLine{8243             CATCH\_BREAK\_INTO\_DEBUGGER();}
\DoxyCodeLine{8244         \}}
\DoxyCodeLine{8245         \textcolor{keywordflow}{if} (m\_reaction.shouldThrow) \{}
\DoxyCodeLine{8246 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{8247             \textcolor{keywordflow}{throw} \mbox{\hyperlink{struct_catch_1_1_test_failure_exception}{Catch::TestFailureException}}();}
\DoxyCodeLine{8248 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{8249             CATCH\_ERROR( \textcolor{stringliteral}{"{}Test failure requires aborting test!"{}} );}
\DoxyCodeLine{8250 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8251         \}}
\DoxyCodeLine{8252     \}}
\DoxyCodeLine{8253     \textcolor{keywordtype}{void} AssertionHandler::setCompleted() \{}
\DoxyCodeLine{8254         m\_completed = \textcolor{keyword}{true};}
\DoxyCodeLine{8255     \}}
\DoxyCodeLine{8256 }
\DoxyCodeLine{8257     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedInflightException() \{}
\DoxyCodeLine{8258         m\_resultCapture.handleUnexpectedInflightException( m\_assertionInfo, Catch::translateActiveException(), m\_reaction );}
\DoxyCodeLine{8259     \}}
\DoxyCodeLine{8260 }
\DoxyCodeLine{8261     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionThrownAsExpected() \{}
\DoxyCodeLine{8262         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8263     \}}
\DoxyCodeLine{8264     \textcolor{keywordtype}{void} AssertionHandler::handleExceptionNotThrownAsExpected() \{}
\DoxyCodeLine{8265         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8266     \}}
\DoxyCodeLine{8267 }
\DoxyCodeLine{8268     \textcolor{keywordtype}{void} AssertionHandler::handleUnexpectedExceptionNotThrown() \{}
\DoxyCodeLine{8269         m\_resultCapture.handleUnexpectedExceptionNotThrown( m\_assertionInfo, m\_reaction );}
\DoxyCodeLine{8270     \}}
\DoxyCodeLine{8271 }
\DoxyCodeLine{8272     \textcolor{keywordtype}{void} AssertionHandler::handleThrowingCallSkipped() \{}
\DoxyCodeLine{8273         m\_resultCapture.handleNonExpr(m\_assertionInfo, ResultWas::Ok, m\_reaction);}
\DoxyCodeLine{8274     \}}
\DoxyCodeLine{8275 }
\DoxyCodeLine{8276     \textcolor{comment}{// This is the overload that takes a string and infers the Equals matcher from it}}
\DoxyCodeLine{8277     \textcolor{comment}{// The more general overload, that takes any string matcher, is in catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8278     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, std::string \textcolor{keyword}{const}\& str, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8279         handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );}
\DoxyCodeLine{8280     \}}
\DoxyCodeLine{8281 }
\DoxyCodeLine{8282 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8283 \textcolor{comment}{// end catch\_assertionhandler.cpp}}
\DoxyCodeLine{8284 \textcolor{comment}{// start catch\_assertionresult.cpp}}
\DoxyCodeLine{8285 }
\DoxyCodeLine{8286 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8287     AssertionResultData::AssertionResultData(ResultWas::OfType \_resultType, LazyExpression \textcolor{keyword}{const} \& \_lazyExpression):}
\DoxyCodeLine{8288         lazyExpression(\_lazyExpression),}
\DoxyCodeLine{8289         resultType(\_resultType) \{\}}
\DoxyCodeLine{8290 }
\DoxyCodeLine{8291     std::string AssertionResultData::reconstructExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8292 }
\DoxyCodeLine{8293         \textcolor{keywordflow}{if}( reconstructedExpression.empty() ) \{}
\DoxyCodeLine{8294             \textcolor{keywordflow}{if}( lazyExpression ) \{}
\DoxyCodeLine{8295                 ReusableStringStream rss;}
\DoxyCodeLine{8296                 rss << lazyExpression;}
\DoxyCodeLine{8297                 reconstructedExpression = rss.str();}
\DoxyCodeLine{8298             \}}
\DoxyCodeLine{8299         \}}
\DoxyCodeLine{8300         \textcolor{keywordflow}{return} reconstructedExpression;}
\DoxyCodeLine{8301     \}}
\DoxyCodeLine{8302 }
\DoxyCodeLine{8303     AssertionResult::AssertionResult( AssertionInfo \textcolor{keyword}{const}\& info, AssertionResultData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{8304     :   m\_info( info ),}
\DoxyCodeLine{8305         m\_resultData( data )}
\DoxyCodeLine{8306     \{\}}
\DoxyCodeLine{8307 }
\DoxyCodeLine{8308     \textcolor{comment}{// Result was a success}}
\DoxyCodeLine{8309     \textcolor{keywordtype}{bool} AssertionResult::succeeded()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8310         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType );}
\DoxyCodeLine{8311     \}}
\DoxyCodeLine{8312 }
\DoxyCodeLine{8313     \textcolor{comment}{// Result was a success, or failure is suppressed}}
\DoxyCodeLine{8314     \textcolor{keywordtype}{bool} AssertionResult::isOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8315         \textcolor{keywordflow}{return} Catch::isOk( m\_resultData.resultType ) || shouldSuppressFailure( m\_info.resultDisposition );}
\DoxyCodeLine{8316     \}}
\DoxyCodeLine{8317 }
\DoxyCodeLine{8318     ResultWas::OfType AssertionResult::getResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8319         \textcolor{keywordflow}{return} m\_resultData.resultType;}
\DoxyCodeLine{8320     \}}
\DoxyCodeLine{8321 }
\DoxyCodeLine{8322     \textcolor{keywordtype}{bool} AssertionResult::hasExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8323         \textcolor{keywordflow}{return} !m\_info.capturedExpression.empty();}
\DoxyCodeLine{8324     \}}
\DoxyCodeLine{8325 }
\DoxyCodeLine{8326     \textcolor{keywordtype}{bool} AssertionResult::hasMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8327         \textcolor{keywordflow}{return} !m\_resultData.message.empty();}
\DoxyCodeLine{8328     \}}
\DoxyCodeLine{8329 }
\DoxyCodeLine{8330     std::string AssertionResult::getExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8331         \textcolor{comment}{// Possibly overallocating by 3 characters should be basically free}}
\DoxyCodeLine{8332         std::string expr; expr.reserve(m\_info.capturedExpression.size() + 3);}
\DoxyCodeLine{8333         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8334             expr += "{}!("{};}
\DoxyCodeLine{8335         \}}
\DoxyCodeLine{8336         expr += m\_info.capturedExpression;}
\DoxyCodeLine{8337         \textcolor{keywordflow}{if} (isFalseTest(m\_info.resultDisposition)) \{}
\DoxyCodeLine{8338             expr += ')';}
\DoxyCodeLine{8339         \}}
\DoxyCodeLine{8340         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8341     \}}
\DoxyCodeLine{8342 }
\DoxyCodeLine{8343     std::string AssertionResult::getExpressionInMacro()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8344         std::string expr;}
\DoxyCodeLine{8345         \textcolor{keywordflow}{if}( m\_info.macroName.empty() )}
\DoxyCodeLine{8346             expr = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(m\_info.capturedExpression);}
\DoxyCodeLine{8347         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8348             expr.reserve( m\_info.macroName.size() + m\_info.capturedExpression.size() + 4 );}
\DoxyCodeLine{8349             expr += m\_info.macroName;}
\DoxyCodeLine{8350             expr += "{}( "{};}
\DoxyCodeLine{8351             expr += m\_info.capturedExpression;}
\DoxyCodeLine{8352             expr += "{} )"{};}
\DoxyCodeLine{8353         \}}
\DoxyCodeLine{8354         \textcolor{keywordflow}{return} expr;}
\DoxyCodeLine{8355     \}}
\DoxyCodeLine{8356 }
\DoxyCodeLine{8357     \textcolor{keywordtype}{bool} AssertionResult::hasExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8358         \textcolor{keywordflow}{return} hasExpression() \&\& getExpandedExpression() != getExpression();}
\DoxyCodeLine{8359     \}}
\DoxyCodeLine{8360 }
\DoxyCodeLine{8361     std::string AssertionResult::getExpandedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8362         std::string expr = m\_resultData.reconstructExpression();}
\DoxyCodeLine{8363         \textcolor{keywordflow}{return} expr.empty()}
\DoxyCodeLine{8364                 ? getExpression()}
\DoxyCodeLine{8365                 : expr;}
\DoxyCodeLine{8366     \}}
\DoxyCodeLine{8367 }
\DoxyCodeLine{8368     std::string AssertionResult::getMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8369         \textcolor{keywordflow}{return} m\_resultData.message;}
\DoxyCodeLine{8370     \}}
\DoxyCodeLine{8371     SourceLineInfo AssertionResult::getSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8372         \textcolor{keywordflow}{return} m\_info.lineInfo;}
\DoxyCodeLine{8373     \}}
\DoxyCodeLine{8374 }
\DoxyCodeLine{8375     StringRef AssertionResult::getTestMacroName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8376         \textcolor{keywordflow}{return} m\_info.macroName;}
\DoxyCodeLine{8377     \}}
\DoxyCodeLine{8378 }
\DoxyCodeLine{8379 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{8380 \textcolor{comment}{// end catch\_assertionresult.cpp}}
\DoxyCodeLine{8381 \textcolor{comment}{// start catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8382 }
\DoxyCodeLine{8383 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8384 }
\DoxyCodeLine{8385     \textcolor{keyword}{using} StringMatcher = Matchers::Impl::MatcherBase<std::string>;}
\DoxyCodeLine{8386 }
\DoxyCodeLine{8387     \textcolor{comment}{// This is the general overload that takes a any string matcher}}
\DoxyCodeLine{8388     \textcolor{comment}{// There is another overload, in catch\_assertionhandler.h/.cpp, that only takes a string and infers}}
\DoxyCodeLine{8389     \textcolor{comment}{// the Equals matcher (so the header does not mention matchers)}}
\DoxyCodeLine{8390     \textcolor{keywordtype}{void} handleExceptionMatchExpr( AssertionHandler\& handler, StringMatcher \textcolor{keyword}{const}\& matcher, StringRef \textcolor{keyword}{const}\& matcherString  ) \{}
\DoxyCodeLine{8391         std::string exceptionMessage = Catch::translateActiveException();}
\DoxyCodeLine{8392         MatchExpr<std::string, StringMatcher const\&> expr( exceptionMessage, matcher, matcherString );}
\DoxyCodeLine{8393         handler.handleExpr( expr );}
\DoxyCodeLine{8394     \}}
\DoxyCodeLine{8395 }
\DoxyCodeLine{8396 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{8397 \textcolor{comment}{// end catch\_capture\_matchers.cpp}}
\DoxyCodeLine{8398 \textcolor{comment}{// start catch\_commandline.cpp}}
\DoxyCodeLine{8399 }
\DoxyCodeLine{8400 \textcolor{comment}{// start catch\_commandline.h}}
\DoxyCodeLine{8401 }
\DoxyCodeLine{8402 \textcolor{comment}{// start catch\_clara.h}}
\DoxyCodeLine{8403 }
\DoxyCodeLine{8404 \textcolor{comment}{// Use Catch's value for console width (store Clara's off to the side, if present)}}
\DoxyCodeLine{8405 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8406 \textcolor{preprocessor}{\#define CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8407 \textcolor{preprocessor}{\#undef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8409 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CONFIG\_CONSOLE\_WIDTH-\/1}}
\DoxyCodeLine{8410 }
\DoxyCodeLine{8411 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{8412 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{8413 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{8414 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{8415 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wshadow"{}}}
\DoxyCodeLine{8416 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8417 }
\DoxyCodeLine{8418 \textcolor{comment}{// start clara.hpp}}
\DoxyCodeLine{8419 \textcolor{comment}{// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.}}
\DoxyCodeLine{8420 \textcolor{comment}{//}}
\DoxyCodeLine{8421 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8422 \textcolor{comment}{// file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8423 \textcolor{comment}{//}}
\DoxyCodeLine{8424 \textcolor{comment}{// See https://github.com/philsquared/Clara for more details}}
\DoxyCodeLine{8425 }
\DoxyCodeLine{8426 \textcolor{comment}{// Clara v1.1.5}}
\DoxyCodeLine{8427 }
\DoxyCodeLine{8428 }
\DoxyCodeLine{8429 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8430 \textcolor{preprocessor}{\#define CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8431 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8432 }
\DoxyCodeLine{8433 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8434 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8435 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8436 }
\DoxyCodeLine{8437 \textcolor{preprocessor}{\#ifndef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{8438 \textcolor{preprocessor}{\#ifdef \_\_has\_include}}
\DoxyCodeLine{8439 \textcolor{preprocessor}{\#if \_\_has\_include(<optional>) \&\& \_\_cplusplus >= 201703L}}
\DoxyCodeLine{8440 \textcolor{preprocessor}{\#include <optional>}}
\DoxyCodeLine{8441 \textcolor{preprocessor}{\#define CLARA\_CONFIG\_OPTIONAL\_TYPE std::optional}}
\DoxyCodeLine{8442 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8443 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8444 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8445 }
\DoxyCodeLine{8446 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ \#included from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8447 }
\DoxyCodeLine{8448 \textcolor{comment}{// TextFlowCpp}}
\DoxyCodeLine{8449 \textcolor{comment}{//}}
\DoxyCodeLine{8450 \textcolor{comment}{// A single-\/header library for wrapping and laying out basic text, by Phil Nash}}
\DoxyCodeLine{8451 \textcolor{comment}{//}}
\DoxyCodeLine{8452 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0. (See accompanying}}
\DoxyCodeLine{8453 \textcolor{comment}{// file LICENSE.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8454 \textcolor{comment}{//}}
\DoxyCodeLine{8455 \textcolor{comment}{// This project is hosted at https://github.com/philsquared/textflowcpp}}
\DoxyCodeLine{8456 }
\DoxyCodeLine{8457 }
\DoxyCodeLine{8458 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{8459 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{8460 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{8461 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8462 }
\DoxyCodeLine{8463 \textcolor{preprocessor}{\#ifndef CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{8464 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH 80}}
\DoxyCodeLine{8465 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8466 }
\DoxyCodeLine{8467 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{8468 \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8469 \textcolor{keyword}{namespace }TextFlow \{}
\DoxyCodeLine{8470 }
\DoxyCodeLine{8471 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isWhitespace(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8472     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{} \(\backslash\)t\(\backslash\)n\(\backslash\)r"{}};}
\DoxyCodeLine{8473     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8474 \}}
\DoxyCodeLine{8475 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableBefore(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8476     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}[(\{<|"{}};}
\DoxyCodeLine{8477     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8478 \}}
\DoxyCodeLine{8479 \textcolor{keyword}{inline} \textcolor{keyword}{auto} isBreakableAfter(\textcolor{keywordtype}{char} c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8480     \textcolor{keyword}{static} std::string chars = \textcolor{stringliteral}{"{}])\}>.,:;*+-\/=\&/\(\backslash\)\(\backslash\)"{}};}
\DoxyCodeLine{8481     \textcolor{keywordflow}{return} chars.find(c) != std::string::npos;}
\DoxyCodeLine{8482 \}}
\DoxyCodeLine{8483 }
\DoxyCodeLine{8484 \textcolor{keyword}{class }Columns;}
\DoxyCodeLine{8485 }
\DoxyCodeLine{8486 \textcolor{keyword}{class }Column \{}
\DoxyCodeLine{8487     std::vector<std::string> m\_strings;}
\DoxyCodeLine{8488     \textcolor{keywordtype}{size\_t} m\_width = CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{8489     \textcolor{keywordtype}{size\_t} m\_indent = 0;}
\DoxyCodeLine{8490     \textcolor{keywordtype}{size\_t} m\_initialIndent = std::string::npos;}
\DoxyCodeLine{8491 }
\DoxyCodeLine{8492 \textcolor{keyword}{public}:}
\DoxyCodeLine{8493     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8494         \textcolor{keyword}{friend} Column;}
\DoxyCodeLine{8495 }
\DoxyCodeLine{8496         Column \textcolor{keyword}{const}\& m\_column;}
\DoxyCodeLine{8497         \textcolor{keywordtype}{size\_t} m\_stringIndex = 0;}
\DoxyCodeLine{8498         \textcolor{keywordtype}{size\_t} m\_pos = 0;}
\DoxyCodeLine{8499 }
\DoxyCodeLine{8500         \textcolor{keywordtype}{size\_t} m\_len = 0;}
\DoxyCodeLine{8501         \textcolor{keywordtype}{size\_t} m\_end = 0;}
\DoxyCodeLine{8502         \textcolor{keywordtype}{bool} m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8503 }
\DoxyCodeLine{8504         iterator(Column \textcolor{keyword}{const}\& column, \textcolor{keywordtype}{size\_t} stringIndex)}
\DoxyCodeLine{8505             : m\_column(column),}
\DoxyCodeLine{8506             m\_stringIndex(stringIndex) \{\}}
\DoxyCodeLine{8507 }
\DoxyCodeLine{8508         \textcolor{keyword}{auto} line() const -\/> std::\textcolor{keywordtype}{string} const\& \{ \textcolor{keywordflow}{return} m\_column.m\_strings[m\_stringIndex]; \}}
\DoxyCodeLine{8509 }
\DoxyCodeLine{8510         \textcolor{keyword}{auto} isBoundary(\textcolor{keywordtype}{size\_t} at) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8511             assert(at > 0);}
\DoxyCodeLine{8512             assert(at <= line().size());}
\DoxyCodeLine{8513 }
\DoxyCodeLine{8514             \textcolor{keywordflow}{return} at == line().size() ||}
\DoxyCodeLine{8515                 (isWhitespace(line()[at]) \&\& !isWhitespace(line()[at -\/ 1])) ||}
\DoxyCodeLine{8516                 isBreakableBefore(line()[at]) ||}
\DoxyCodeLine{8517                 isBreakableAfter(line()[at -\/ 1]);}
\DoxyCodeLine{8518         \}}
\DoxyCodeLine{8519 }
\DoxyCodeLine{8520         \textcolor{keywordtype}{void} calcLength() \{}
\DoxyCodeLine{8521             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8522 }
\DoxyCodeLine{8523             m\_suffix = \textcolor{keyword}{false};}
\DoxyCodeLine{8524             \textcolor{keyword}{auto} width = m\_column.m\_width -\/ indent();}
\DoxyCodeLine{8525             m\_end = m\_pos;}
\DoxyCodeLine{8526             \textcolor{keywordflow}{if} (line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{8527                 ++m\_end;}
\DoxyCodeLine{8528             \}}
\DoxyCodeLine{8529             \textcolor{keywordflow}{while} (m\_end < line().size() \&\& line()[m\_end] != \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8530                 ++m\_end;}
\DoxyCodeLine{8531 }
\DoxyCodeLine{8532             \textcolor{keywordflow}{if} (m\_end < m\_pos + width) \{}
\DoxyCodeLine{8533                 m\_len = m\_end -\/ m\_pos;}
\DoxyCodeLine{8534             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8535                 \textcolor{keywordtype}{size\_t} len = width;}
\DoxyCodeLine{8536                 \textcolor{keywordflow}{while} (len > 0 \&\& !isBoundary(m\_pos + len))}
\DoxyCodeLine{8537                     -\/-\/len;}
\DoxyCodeLine{8538                 \textcolor{keywordflow}{while} (len > 0 \&\& isWhitespace(line()[m\_pos + len -\/ 1]))}
\DoxyCodeLine{8539                     -\/-\/len;}
\DoxyCodeLine{8540 }
\DoxyCodeLine{8541                 \textcolor{keywordflow}{if} (len > 0) \{}
\DoxyCodeLine{8542                     m\_len = len;}
\DoxyCodeLine{8543                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8544                     m\_suffix = \textcolor{keyword}{true};}
\DoxyCodeLine{8545                     m\_len = width -\/ 1;}
\DoxyCodeLine{8546                 \}}
\DoxyCodeLine{8547             \}}
\DoxyCodeLine{8548         \}}
\DoxyCodeLine{8549 }
\DoxyCodeLine{8550         \textcolor{keyword}{auto} indent() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{8551             \textcolor{keyword}{auto} initial = m\_pos == 0 \&\& m\_stringIndex == 0 ? m\_column.m\_initialIndent : std::string::npos;}
\DoxyCodeLine{8552             \textcolor{keywordflow}{return} initial == std::string::npos ? m\_column.m\_indent : initial;}
\DoxyCodeLine{8553         \}}
\DoxyCodeLine{8554 }
\DoxyCodeLine{8555         \textcolor{keyword}{auto} addIndentAndSuffix(std::string \textcolor{keyword}{const} \&plain) \textcolor{keyword}{const} -\/> std::string \{}
\DoxyCodeLine{8556             \textcolor{keywordflow}{return} std::string(indent(), \textcolor{charliteral}{' '}) + (m\_suffix ? plain + "{}-\/"{} : plain);}
\DoxyCodeLine{8557         \}}
\DoxyCodeLine{8558 }
\DoxyCodeLine{8559     \textcolor{keyword}{public}:}
\DoxyCodeLine{8560         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8561         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{8562         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{8563         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{8564         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8565 }
\DoxyCodeLine{8566         \textcolor{keyword}{explicit} iterator(Column \textcolor{keyword}{const}\& column) : m\_column(column) \{}
\DoxyCodeLine{8567             assert(m\_column.m\_width > m\_column.m\_indent);}
\DoxyCodeLine{8568             assert(m\_column.m\_initialIndent == std::string::npos || m\_column.m\_width > m\_column.m\_initialIndent);}
\DoxyCodeLine{8569             calcLength();}
\DoxyCodeLine{8570             \textcolor{keywordflow}{if} (m\_len == 0)}
\DoxyCodeLine{8571                 m\_stringIndex++; \textcolor{comment}{// Empty string}}
\DoxyCodeLine{8572         \}}
\DoxyCodeLine{8573 }
\DoxyCodeLine{8574         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8575             assert(m\_stringIndex < m\_column.m\_strings.size());}
\DoxyCodeLine{8576             assert(m\_pos <= m\_end);}
\DoxyCodeLine{8577             \textcolor{keywordflow}{return} addIndentAndSuffix(line().substr(m\_pos, m\_len));}
\DoxyCodeLine{8578         \}}
\DoxyCodeLine{8579 }
\DoxyCodeLine{8580         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8581             m\_pos += m\_len;}
\DoxyCodeLine{8582             \textcolor{keywordflow}{if} (m\_pos < line().size() \&\& line()[m\_pos] == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{8583                 m\_pos += 1;}
\DoxyCodeLine{8584             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8585                 \textcolor{keywordflow}{while} (m\_pos < line().size() \&\& isWhitespace(line()[m\_pos]))}
\DoxyCodeLine{8586                     ++m\_pos;}
\DoxyCodeLine{8587 }
\DoxyCodeLine{8588             \textcolor{keywordflow}{if} (m\_pos == line().size()) \{}
\DoxyCodeLine{8589                 m\_pos = 0;}
\DoxyCodeLine{8590                 ++m\_stringIndex;}
\DoxyCodeLine{8591             \}}
\DoxyCodeLine{8592             \textcolor{keywordflow}{if} (m\_stringIndex < m\_column.m\_strings.size())}
\DoxyCodeLine{8593                 calcLength();}
\DoxyCodeLine{8594             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8595         \}}
\DoxyCodeLine{8596         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8597             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8598             operator++();}
\DoxyCodeLine{8599             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8600         \}}
\DoxyCodeLine{8601 }
\DoxyCodeLine{8602         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8603             \textcolor{keywordflow}{return}}
\DoxyCodeLine{8604                 m\_pos == other.m\_pos \&\&}
\DoxyCodeLine{8605                 m\_stringIndex == other.m\_stringIndex \&\&}
\DoxyCodeLine{8606                 \&m\_column == \&other.m\_column;}
\DoxyCodeLine{8607         \}}
\DoxyCodeLine{8608         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8609             \textcolor{keywordflow}{return} !operator==(other);}
\DoxyCodeLine{8610         \}}
\DoxyCodeLine{8611     \};}
\DoxyCodeLine{8612     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{8613 }
\DoxyCodeLine{8614     \textcolor{keyword}{explicit} Column(std::string \textcolor{keyword}{const}\& text) \{ m\_strings.push\_back(text); \}}
\DoxyCodeLine{8615 }
\DoxyCodeLine{8616     \textcolor{keyword}{auto} width(\textcolor{keywordtype}{size\_t} newWidth) -\/> Column\& \{}
\DoxyCodeLine{8617         assert(newWidth > 0);}
\DoxyCodeLine{8618         m\_width = newWidth;}
\DoxyCodeLine{8619         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8620     \}}
\DoxyCodeLine{8621     \textcolor{keyword}{auto} indent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8622         m\_indent = newIndent;}
\DoxyCodeLine{8623         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8624     \}}
\DoxyCodeLine{8625     \textcolor{keyword}{auto} initialIndent(\textcolor{keywordtype}{size\_t} newIndent) -\/> Column\& \{}
\DoxyCodeLine{8626         m\_initialIndent = newIndent;}
\DoxyCodeLine{8627         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8628     \}}
\DoxyCodeLine{8629 }
\DoxyCodeLine{8630     \textcolor{keyword}{auto} width() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_width; \}}
\DoxyCodeLine{8631     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8632     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, m\_strings.size() \}; \}}
\DoxyCodeLine{8633 }
\DoxyCodeLine{8634     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Column \textcolor{keyword}{const}\& col) \{}
\DoxyCodeLine{8635         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8636         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : col) \{}
\DoxyCodeLine{8637             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8638                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8639             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8640                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8641             os << line;}
\DoxyCodeLine{8642         \}}
\DoxyCodeLine{8643         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8644     \}}
\DoxyCodeLine{8645 }
\DoxyCodeLine{8646     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& other)-\/>Columns;}
\DoxyCodeLine{8647 }
\DoxyCodeLine{8648     \textcolor{keyword}{auto} toString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8649         std::ostringstream oss;}
\DoxyCodeLine{8650         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8651         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8652     \}}
\DoxyCodeLine{8653 \};}
\DoxyCodeLine{8654 }
\DoxyCodeLine{8655 \textcolor{keyword}{class }Spacer : \textcolor{keyword}{public} Column \{}
\DoxyCodeLine{8656 }
\DoxyCodeLine{8657 \textcolor{keyword}{public}:}
\DoxyCodeLine{8658     \textcolor{keyword}{explicit} Spacer(\textcolor{keywordtype}{size\_t} spaceWidth) : Column(\textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{8659         width(spaceWidth);}
\DoxyCodeLine{8660     \}}
\DoxyCodeLine{8661 \};}
\DoxyCodeLine{8662 }
\DoxyCodeLine{8663 \textcolor{keyword}{class }Columns \{}
\DoxyCodeLine{8664     std::vector<Column> m\_columns;}
\DoxyCodeLine{8665 }
\DoxyCodeLine{8666 \textcolor{keyword}{public}:}
\DoxyCodeLine{8667 }
\DoxyCodeLine{8668     \textcolor{keyword}{class }iterator \{}
\DoxyCodeLine{8669         \textcolor{keyword}{friend} Columns;}
\DoxyCodeLine{8670         \textcolor{keyword}{struct }EndTag \{\};}
\DoxyCodeLine{8671 }
\DoxyCodeLine{8672         std::vector<Column> \textcolor{keyword}{const}\& m\_columns;}
\DoxyCodeLine{8673         std::vector<Column::iterator> m\_iterators;}
\DoxyCodeLine{8674         \textcolor{keywordtype}{size\_t} m\_activeIterators;}
\DoxyCodeLine{8675 }
\DoxyCodeLine{8676         iterator(Columns \textcolor{keyword}{const}\& columns, EndTag)}
\DoxyCodeLine{8677             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8678             m\_activeIterators(0) \{}
\DoxyCodeLine{8679             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8680 }
\DoxyCodeLine{8681             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8682                 m\_iterators.push\_back(col.end());}
\DoxyCodeLine{8683         \}}
\DoxyCodeLine{8684 }
\DoxyCodeLine{8685     \textcolor{keyword}{public}:}
\DoxyCodeLine{8686         \textcolor{keyword}{using} difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{8687         \textcolor{keyword}{using} value\_type = std::string;}
\DoxyCodeLine{8688         \textcolor{keyword}{using} pointer = value\_type * ;}
\DoxyCodeLine{8689         \textcolor{keyword}{using} reference = value\_type \& ;}
\DoxyCodeLine{8690         \textcolor{keyword}{using} iterator\_category = std::forward\_iterator\_tag;}
\DoxyCodeLine{8691 }
\DoxyCodeLine{8692         \textcolor{keyword}{explicit} iterator(Columns \textcolor{keyword}{const}\& columns)}
\DoxyCodeLine{8693             : m\_columns(columns.m\_columns),}
\DoxyCodeLine{8694             m\_activeIterators(m\_columns.size()) \{}
\DoxyCodeLine{8695             m\_iterators.reserve(m\_columns.size());}
\DoxyCodeLine{8696 }
\DoxyCodeLine{8697             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& col : m\_columns)}
\DoxyCodeLine{8698                 m\_iterators.push\_back(col.begin());}
\DoxyCodeLine{8699         \}}
\DoxyCodeLine{8700 }
\DoxyCodeLine{8701         \textcolor{keyword}{auto} operator ==(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8702             \textcolor{keywordflow}{return} m\_iterators == other.m\_iterators;}
\DoxyCodeLine{8703         \}}
\DoxyCodeLine{8704         \textcolor{keyword}{auto} operator !=(iterator \textcolor{keyword}{const}\& other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8705             \textcolor{keywordflow}{return} m\_iterators != other.m\_iterators;}
\DoxyCodeLine{8706         \}}
\DoxyCodeLine{8707         \textcolor{keyword}{auto} operator *() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8708             std::string row, padding;}
\DoxyCodeLine{8709 }
\DoxyCodeLine{8710             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8711                 \textcolor{keyword}{auto} width = m\_columns[i].width();}
\DoxyCodeLine{8712                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end()) \{}
\DoxyCodeLine{8713                     std::string col = *m\_iterators[i];}
\DoxyCodeLine{8714                     row += padding + col;}
\DoxyCodeLine{8715                     \textcolor{keywordflow}{if} (col.size() < width)}
\DoxyCodeLine{8716                         padding = std::string(width -\/ col.size(), \textcolor{charliteral}{' '});}
\DoxyCodeLine{8717                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{8718                         padding = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{8719                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8720                     padding += std::string(width, ' ');}
\DoxyCodeLine{8721                 \}}
\DoxyCodeLine{8722             \}}
\DoxyCodeLine{8723             \textcolor{keywordflow}{return} row;}
\DoxyCodeLine{8724         \}}
\DoxyCodeLine{8725         \textcolor{keyword}{auto} operator ++() -\/> iterator\& \{}
\DoxyCodeLine{8726             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < m\_columns.size(); ++i) \{}
\DoxyCodeLine{8727                 \textcolor{keywordflow}{if} (m\_iterators[i] != m\_columns[i].end())}
\DoxyCodeLine{8728                     ++m\_iterators[i];}
\DoxyCodeLine{8729             \}}
\DoxyCodeLine{8730             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8731         \}}
\DoxyCodeLine{8732         \textcolor{keyword}{auto} operator ++(\textcolor{keywordtype}{int}) -\/> iterator \{}
\DoxyCodeLine{8733             iterator prev(*\textcolor{keyword}{this});}
\DoxyCodeLine{8734             operator++();}
\DoxyCodeLine{8735             \textcolor{keywordflow}{return} prev;}
\DoxyCodeLine{8736         \}}
\DoxyCodeLine{8737     \};}
\DoxyCodeLine{8738     \textcolor{keyword}{using} const\_iterator = iterator;}
\DoxyCodeLine{8739 }
\DoxyCodeLine{8740     \textcolor{keyword}{auto} begin() const -\/> iterator \{ \textcolor{keywordflow}{return} iterator(*\textcolor{keyword}{this}); \}}
\DoxyCodeLine{8741     \textcolor{keyword}{auto} end() const -\/> iterator \{ \textcolor{keywordflow}{return} \{ *\textcolor{keyword}{this}, iterator::EndTag() \}; \}}
\DoxyCodeLine{8742 }
\DoxyCodeLine{8743     \textcolor{keyword}{auto} operator += (Column \textcolor{keyword}{const}\& col) -\/> Columns\& \{}
\DoxyCodeLine{8744         m\_columns.push\_back(col);}
\DoxyCodeLine{8745         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8746     \}}
\DoxyCodeLine{8747     \textcolor{keyword}{auto} operator + (Column \textcolor{keyword}{const}\& col) -\/> Columns \{}
\DoxyCodeLine{8748         Columns combined = *\textcolor{keyword}{this};}
\DoxyCodeLine{8749         combined += col;}
\DoxyCodeLine{8750         \textcolor{keywordflow}{return} combined;}
\DoxyCodeLine{8751     \}}
\DoxyCodeLine{8752 }
\DoxyCodeLine{8753     \textcolor{keyword}{inline} \textcolor{keyword}{friend} std::ostream\& operator << (std::ostream\& os, Columns \textcolor{keyword}{const}\& cols) \{}
\DoxyCodeLine{8754 }
\DoxyCodeLine{8755         \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{8756         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : cols) \{}
\DoxyCodeLine{8757             \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{8758                 first = \textcolor{keyword}{false};}
\DoxyCodeLine{8759             \textcolor{keywordflow}{else}}
\DoxyCodeLine{8760                 os << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{8761             os << line;}
\DoxyCodeLine{8762         \}}
\DoxyCodeLine{8763         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{8764     \}}
\DoxyCodeLine{8765 }
\DoxyCodeLine{8766     \textcolor{keyword}{auto} toString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8767         std::ostringstream oss;}
\DoxyCodeLine{8768         oss << *\textcolor{keyword}{this};}
\DoxyCodeLine{8769         \textcolor{keywordflow}{return} oss.str();}
\DoxyCodeLine{8770     \}}
\DoxyCodeLine{8771 \};}
\DoxyCodeLine{8772 }
\DoxyCodeLine{8773 \textcolor{keyword}{inline} \textcolor{keyword}{auto} Column::operator + (Column \textcolor{keyword}{const}\& other) -\/> Columns \{}
\DoxyCodeLine{8774     Columns cols;}
\DoxyCodeLine{8775     cols += *this;}
\DoxyCodeLine{8776     cols += other;}
\DoxyCodeLine{8777     \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{8778 \}}
\DoxyCodeLine{8779 \}}
\DoxyCodeLine{8780 }
\DoxyCodeLine{8781 \}}
\DoxyCodeLine{8782 \}}
\DoxyCodeLine{8783 }
\DoxyCodeLine{8784 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ end of \#include from clara\_textflow.hpp -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{8785 \textcolor{comment}{// ........... back in clara.hpp}}
\DoxyCodeLine{8786 }
\DoxyCodeLine{8787 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{8788 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{8789 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{8790 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{8791 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{8792 }
\DoxyCodeLine{8793 \textcolor{preprocessor}{\#if !defined(CATCH\_PLATFORM\_WINDOWS) \&\& ( defined(WIN32) || defined(\_\_WIN32\_\_) || defined(\_WIN32) || defined(\_MSC\_VER) )}}
\DoxyCodeLine{8794 \textcolor{preprocessor}{\#define CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8795 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8796 }
\DoxyCodeLine{8797 \textcolor{keyword}{namespace }Catch \{ \textcolor{keyword}{namespace }clara \{}
\DoxyCodeLine{8798 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{8799 }
\DoxyCodeLine{8800     \textcolor{comment}{// Traits for extracting arg and return type of lambdas (for single argument lambdas)}}
\DoxyCodeLine{8801     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{8802     \textcolor{keyword}{struct }UnaryLambdaTraits : UnaryLambdaTraits<decltype( \&L::operator() )> \{\};}
\DoxyCodeLine{8803 }
\DoxyCodeLine{8804     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{8805     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> \{}
\DoxyCodeLine{8806         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{false};}
\DoxyCodeLine{8807     \};}
\DoxyCodeLine{8808 }
\DoxyCodeLine{8809     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ClassT, \textcolor{keyword}{typename} ReturnT, \textcolor{keyword}{typename} ArgT>}
\DoxyCodeLine{8810     \textcolor{keyword}{struct }UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> \{}
\DoxyCodeLine{8811         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{true};}
\DoxyCodeLine{8812         \textcolor{keyword}{using} ArgType = \textcolor{keyword}{typename} std::remove\_const<typename std::remove\_reference<ArgT>::type>::type;}
\DoxyCodeLine{8813         \textcolor{keyword}{using} ReturnType = ReturnT;}
\DoxyCodeLine{8814     \};}
\DoxyCodeLine{8815 }
\DoxyCodeLine{8816     \textcolor{keyword}{class }TokenStream;}
\DoxyCodeLine{8817 }
\DoxyCodeLine{8818     \textcolor{comment}{// Transport for raw args (copied from main args, or supplied via init list for testing)}}
\DoxyCodeLine{8819     \textcolor{keyword}{class }Args \{}
\DoxyCodeLine{8820         \textcolor{keyword}{friend} TokenStream;}
\DoxyCodeLine{8821         std::string m\_exeName;}
\DoxyCodeLine{8822         std::vector<std::string> m\_args;}
\DoxyCodeLine{8823 }
\DoxyCodeLine{8824     \textcolor{keyword}{public}:}
\DoxyCodeLine{8825         Args( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* \textcolor{keyword}{const}* argv )}
\DoxyCodeLine{8826             : m\_exeName(argv[0]),}
\DoxyCodeLine{8827               m\_args(argv + 1, argv + argc) \{\}}
\DoxyCodeLine{8828 }
\DoxyCodeLine{8829         Args( std::initializer\_list<std::string> args )}
\DoxyCodeLine{8830         :   m\_exeName( *args.begin() ),}
\DoxyCodeLine{8831             m\_args( args.begin()+1, args.end() )}
\DoxyCodeLine{8832         \{\}}
\DoxyCodeLine{8833 }
\DoxyCodeLine{8834         \textcolor{keyword}{auto} exeName() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{8835             \textcolor{keywordflow}{return} m\_exeName;}
\DoxyCodeLine{8836         \}}
\DoxyCodeLine{8837     \};}
\DoxyCodeLine{8838 }
\DoxyCodeLine{8839     \textcolor{comment}{// Wraps a token coming from a token stream. These may not directly correspond to strings as a single string}}
\DoxyCodeLine{8840     \textcolor{comment}{// may encode an option + its argument if the : or = form is used}}
\DoxyCodeLine{8841     \textcolor{keyword}{enum class} TokenType \{}
\DoxyCodeLine{8842         Option, Argument}
\DoxyCodeLine{8843     \};}
\DoxyCodeLine{8844     \textcolor{keyword}{struct }Token \{}
\DoxyCodeLine{8845         TokenType type;}
\DoxyCodeLine{8846         std::string token;}
\DoxyCodeLine{8847     \};}
\DoxyCodeLine{8848 }
\DoxyCodeLine{8849     \textcolor{keyword}{inline} \textcolor{keyword}{auto} isOptPrefix( \textcolor{keywordtype}{char} c ) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{8850         \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'-\/'}}
\DoxyCodeLine{8851 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{8852             || c == \textcolor{charliteral}{'/'}}
\DoxyCodeLine{8853 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{8854         ;}
\DoxyCodeLine{8855     \}}
\DoxyCodeLine{8856 }
\DoxyCodeLine{8857     \textcolor{comment}{// Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled}}
\DoxyCodeLine{8858     \textcolor{keyword}{class }TokenStream \{}
\DoxyCodeLine{8859         \textcolor{keyword}{using} Iterator = std::vector<std::string>::const\_iterator;}
\DoxyCodeLine{8860         Iterator it;}
\DoxyCodeLine{8861         Iterator itEnd;}
\DoxyCodeLine{8862         std::vector<Token> m\_tokenBuffer;}
\DoxyCodeLine{8863 }
\DoxyCodeLine{8864         \textcolor{keywordtype}{void} loadBuffer() \{}
\DoxyCodeLine{8865             m\_tokenBuffer.resize( 0 );}
\DoxyCodeLine{8866 }
\DoxyCodeLine{8867             \textcolor{comment}{// Skip any empty strings}}
\DoxyCodeLine{8868             \textcolor{keywordflow}{while}( it != itEnd \&\& it-\/>empty() )}
\DoxyCodeLine{8869                 ++it;}
\DoxyCodeLine{8870 }
\DoxyCodeLine{8871             \textcolor{keywordflow}{if}( it != itEnd ) \{}
\DoxyCodeLine{8872                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&next = *it;}
\DoxyCodeLine{8873                 \textcolor{keywordflow}{if}( isOptPrefix( next[0] ) ) \{}
\DoxyCodeLine{8874                     \textcolor{keyword}{auto} delimiterPos = next.find\_first\_of( \textcolor{stringliteral}{"{} :="{}} );}
\DoxyCodeLine{8875                     \textcolor{keywordflow}{if}( delimiterPos != std::string::npos ) \{}
\DoxyCodeLine{8876                         m\_tokenBuffer.push\_back( \{ TokenType::Option, next.substr( 0, delimiterPos ) \} );}
\DoxyCodeLine{8877                         m\_tokenBuffer.push\_back( \{ TokenType::Argument, next.substr( delimiterPos + 1 ) \} );}
\DoxyCodeLine{8878                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8879                         \textcolor{keywordflow}{if}( next[1] != \textcolor{charliteral}{'-\/'} \&\& next.size() > 2 ) \{}
\DoxyCodeLine{8880                             std::string opt = \textcolor{stringliteral}{"{}-\/ "{}};}
\DoxyCodeLine{8881                             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 1; i < next.size(); ++i ) \{}
\DoxyCodeLine{8882                                 opt[1] = next[i];}
\DoxyCodeLine{8883                                 m\_tokenBuffer.push\_back( \{ TokenType::Option, opt \} );}
\DoxyCodeLine{8884                             \}}
\DoxyCodeLine{8885                         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8886                             m\_tokenBuffer.push\_back( \{ TokenType::Option, next \} );}
\DoxyCodeLine{8887                         \}}
\DoxyCodeLine{8888                     \}}
\DoxyCodeLine{8889                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8890                     m\_tokenBuffer.push\_back( \{ TokenType::Argument, next \} );}
\DoxyCodeLine{8891                 \}}
\DoxyCodeLine{8892             \}}
\DoxyCodeLine{8893         \}}
\DoxyCodeLine{8894 }
\DoxyCodeLine{8895     \textcolor{keyword}{public}:}
\DoxyCodeLine{8896         \textcolor{keyword}{explicit} TokenStream( Args \textcolor{keyword}{const} \&args ) : TokenStream( args.m\_args.begin(), args.m\_args.end() ) \{\}}
\DoxyCodeLine{8897 }
\DoxyCodeLine{8898         TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) \{}
\DoxyCodeLine{8899             loadBuffer();}
\DoxyCodeLine{8900         \}}
\DoxyCodeLine{8901 }
\DoxyCodeLine{8902         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{8903             \textcolor{keywordflow}{return} !m\_tokenBuffer.empty() || it != itEnd;}
\DoxyCodeLine{8904         \}}
\DoxyCodeLine{8905 }
\DoxyCodeLine{8906         \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} m\_tokenBuffer.size() + (itEnd -\/ it); \}}
\DoxyCodeLine{8907 }
\DoxyCodeLine{8908         \textcolor{keyword}{auto} operator*() const -\/> Token \{}
\DoxyCodeLine{8909             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8910             \textcolor{keywordflow}{return} m\_tokenBuffer.front();}
\DoxyCodeLine{8911         \}}
\DoxyCodeLine{8912 }
\DoxyCodeLine{8913         \textcolor{keyword}{auto} operator-\/>() const -\/> Token const * \{}
\DoxyCodeLine{8914             assert( !m\_tokenBuffer.empty() );}
\DoxyCodeLine{8915             \textcolor{keywordflow}{return} \&m\_tokenBuffer.front();}
\DoxyCodeLine{8916         \}}
\DoxyCodeLine{8917 }
\DoxyCodeLine{8918         \textcolor{keyword}{auto} operator++() -\/> TokenStream \& \{}
\DoxyCodeLine{8919             \textcolor{keywordflow}{if}( m\_tokenBuffer.size() >= 2 ) \{}
\DoxyCodeLine{8920                 m\_tokenBuffer.erase( m\_tokenBuffer.begin() );}
\DoxyCodeLine{8921             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{8922                 \textcolor{keywordflow}{if}( it != itEnd )}
\DoxyCodeLine{8923                     ++it;}
\DoxyCodeLine{8924                 loadBuffer();}
\DoxyCodeLine{8925             \}}
\DoxyCodeLine{8926             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8927         \}}
\DoxyCodeLine{8928     \};}
\DoxyCodeLine{8929 }
\DoxyCodeLine{8930     \textcolor{keyword}{class }ResultBase \{}
\DoxyCodeLine{8931     \textcolor{keyword}{public}:}
\DoxyCodeLine{8932         \textcolor{keyword}{enum} Type \{}
\DoxyCodeLine{8933             Ok, LogicError, RuntimeError}
\DoxyCodeLine{8934         \};}
\DoxyCodeLine{8935 }
\DoxyCodeLine{8936     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8937         ResultBase( Type type ) : m\_type( type ) \{\}}
\DoxyCodeLine{8938         \textcolor{keyword}{virtual} \string~ResultBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{8939 }
\DoxyCodeLine{8940         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} enforceOk() \textcolor{keyword}{const} = 0;}
\DoxyCodeLine{8941 }
\DoxyCodeLine{8942         Type m\_type;}
\DoxyCodeLine{8943     \};}
\DoxyCodeLine{8944 }
\DoxyCodeLine{8945     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{8946     \textcolor{keyword}{class }ResultValueBase : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{8947     \textcolor{keyword}{public}:}
\DoxyCodeLine{8948         \textcolor{keyword}{auto} value() const -\/> T const \& \{}
\DoxyCodeLine{8949             enforceOk();}
\DoxyCodeLine{8950             \textcolor{keywordflow}{return} m\_value;}
\DoxyCodeLine{8951         \}}
\DoxyCodeLine{8952 }
\DoxyCodeLine{8953     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8954         ResultValueBase( Type type ) : ResultBase( type ) \{\}}
\DoxyCodeLine{8955 }
\DoxyCodeLine{8956         ResultValueBase( ResultValueBase \textcolor{keyword}{const} \&other ) : ResultBase( other ) \{}
\DoxyCodeLine{8957             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8958                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8959         \}}
\DoxyCodeLine{8960 }
\DoxyCodeLine{8961         ResultValueBase( Type, T \textcolor{keyword}{const} \&value ) : ResultBase( Ok ) \{}
\DoxyCodeLine{8962             \textcolor{keyword}{new}( \&m\_value ) T( value );}
\DoxyCodeLine{8963         \}}
\DoxyCodeLine{8964 }
\DoxyCodeLine{8965         \textcolor{keyword}{auto} operator=( ResultValueBase \textcolor{keyword}{const} \&other ) -\/> ResultValueBase \& \{}
\DoxyCodeLine{8966             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8967                 m\_value.\string~T();}
\DoxyCodeLine{8968             ResultBase::operator=(other);}
\DoxyCodeLine{8969             \textcolor{keywordflow}{if}( m\_type == ResultBase::Ok )}
\DoxyCodeLine{8970                 \textcolor{keyword}{new}( \&m\_value ) T( other.m\_value );}
\DoxyCodeLine{8971             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{8972         \}}
\DoxyCodeLine{8973 }
\DoxyCodeLine{8974         \string~ResultValueBase()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{8975             \textcolor{keywordflow}{if}( m\_type == Ok )}
\DoxyCodeLine{8976                 m\_value.\string~T();}
\DoxyCodeLine{8977         \}}
\DoxyCodeLine{8978 }
\DoxyCodeLine{8979         \textcolor{keyword}{union }\{}
\DoxyCodeLine{8980             T m\_value;}
\DoxyCodeLine{8981         \};}
\DoxyCodeLine{8982     \};}
\DoxyCodeLine{8983 }
\DoxyCodeLine{8984     \textcolor{keyword}{template}<>}
\DoxyCodeLine{8985     \textcolor{keyword}{class }ResultValueBase<void> : \textcolor{keyword}{public} ResultBase \{}
\DoxyCodeLine{8986     \textcolor{keyword}{protected}:}
\DoxyCodeLine{8987         \textcolor{keyword}{using} ResultBase::ResultBase;}
\DoxyCodeLine{8988     \};}
\DoxyCodeLine{8989 }
\DoxyCodeLine{8990     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{8991     \textcolor{keyword}{class }BasicResult : \textcolor{keyword}{public} ResultValueBase<T> \{}
\DoxyCodeLine{8992     \textcolor{keyword}{public}:}
\DoxyCodeLine{8993         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{8994         \textcolor{keyword}{explicit} BasicResult( BasicResult<U> \textcolor{keyword}{const} \&other )}
\DoxyCodeLine{8995         :   ResultValueBase<T>( other.type() ),}
\DoxyCodeLine{8996             m\_errorMessage( other.errorMessage() )}
\DoxyCodeLine{8997         \{}
\DoxyCodeLine{8998             assert( type() != ResultBase::Ok );}
\DoxyCodeLine{8999         \}}
\DoxyCodeLine{9000 }
\DoxyCodeLine{9001         \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{9002         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok( U \textcolor{keyword}{const} \&value ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok, value \}; \}}
\DoxyCodeLine{9003         \textcolor{keyword}{static} \textcolor{keyword}{auto} ok() -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::Ok \}; \}}
\DoxyCodeLine{9004         \textcolor{keyword}{static} \textcolor{keyword}{auto} logicError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::LogicError, message \}; \}}
\DoxyCodeLine{9005         \textcolor{keyword}{static} \textcolor{keyword}{auto} runtimeError( std::string \textcolor{keyword}{const} \&message ) -\/> BasicResult \{ \textcolor{keywordflow}{return} \{ ResultBase::RuntimeError, message \}; \}}
\DoxyCodeLine{9006 }
\DoxyCodeLine{9007         \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_type == ResultBase::Ok; \}}
\DoxyCodeLine{9008         \textcolor{keyword}{auto} type() const -\/> ResultBase::Type \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9009         \textcolor{keyword}{auto} errorMessage() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_errorMessage; \}}
\DoxyCodeLine{9010 }
\DoxyCodeLine{9011     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9012         \textcolor{keywordtype}{void} enforceOk()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{9013 }
\DoxyCodeLine{9014             \textcolor{comment}{// Errors shouldn't reach this point, but if they do}}
\DoxyCodeLine{9015             \textcolor{comment}{// the actual error message will be in m\_errorMessage}}
\DoxyCodeLine{9016             assert( m\_type != ResultBase::LogicError );}
\DoxyCodeLine{9017             assert( m\_type != ResultBase::RuntimeError );}
\DoxyCodeLine{9018             \textcolor{keywordflow}{if}( m\_type != ResultBase::Ok )}
\DoxyCodeLine{9019                 std::abort();}
\DoxyCodeLine{9020         \}}
\DoxyCodeLine{9021 }
\DoxyCodeLine{9022         std::string m\_errorMessage; \textcolor{comment}{// Only populated if resultType is an error}}
\DoxyCodeLine{9023 }
\DoxyCodeLine{9024         BasicResult( ResultBase::Type type, std::string \textcolor{keyword}{const} \&message )}
\DoxyCodeLine{9025         :   ResultValueBase<T>(type),}
\DoxyCodeLine{9026             m\_errorMessage(message)}
\DoxyCodeLine{9027         \{}
\DoxyCodeLine{9028             assert( m\_type != ResultBase::Ok );}
\DoxyCodeLine{9029         \}}
\DoxyCodeLine{9030 }
\DoxyCodeLine{9031         \textcolor{keyword}{using} ResultValueBase<T>::ResultValueBase;}
\DoxyCodeLine{9032         \textcolor{keyword}{using} ResultBase::m\_type;}
\DoxyCodeLine{9033     \};}
\DoxyCodeLine{9034 }
\DoxyCodeLine{9035     \textcolor{keyword}{enum class} ParseResultType \{}
\DoxyCodeLine{9036         Matched, NoMatch, ShortCircuitAll, ShortCircuitSame}
\DoxyCodeLine{9037     \};}
\DoxyCodeLine{9038 }
\DoxyCodeLine{9039     \textcolor{keyword}{class }ParseState \{}
\DoxyCodeLine{9040     \textcolor{keyword}{public}:}
\DoxyCodeLine{9041 }
\DoxyCodeLine{9042         ParseState( ParseResultType type, TokenStream \textcolor{keyword}{const} \&remainingTokens )}
\DoxyCodeLine{9043         : m\_type(type),}
\DoxyCodeLine{9044           m\_remainingTokens( remainingTokens )}
\DoxyCodeLine{9045         \{\}}
\DoxyCodeLine{9046 }
\DoxyCodeLine{9047         \textcolor{keyword}{auto} type() const -\/> ParseResultType \{ \textcolor{keywordflow}{return} m\_type; \}}
\DoxyCodeLine{9048         \textcolor{keyword}{auto} remainingTokens() const -\/> TokenStream \{ \textcolor{keywordflow}{return} m\_remainingTokens; \}}
\DoxyCodeLine{9049 }
\DoxyCodeLine{9050     \textcolor{keyword}{private}:}
\DoxyCodeLine{9051         ParseResultType m\_type;}
\DoxyCodeLine{9052         TokenStream m\_remainingTokens;}
\DoxyCodeLine{9053     \};}
\DoxyCodeLine{9054 }
\DoxyCodeLine{9055     \textcolor{keyword}{using} Result = BasicResult<void>;}
\DoxyCodeLine{9056     \textcolor{keyword}{using} ParserResult = BasicResult<ParseResultType>;}
\DoxyCodeLine{9057     \textcolor{keyword}{using} InternalParseResult = BasicResult<ParseState>;}
\DoxyCodeLine{9058 }
\DoxyCodeLine{9059     \textcolor{keyword}{struct }HelpColumns \{}
\DoxyCodeLine{9060         std::string left;}
\DoxyCodeLine{9061         std::string right;}
\DoxyCodeLine{9062     \};}
\DoxyCodeLine{9063 }
\DoxyCodeLine{9064     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9065     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, T\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9066         std::stringstream ss;}
\DoxyCodeLine{9067         ss << source;}
\DoxyCodeLine{9068         ss >> target;}
\DoxyCodeLine{9069         \textcolor{keywordflow}{if}( ss.fail() )}
\DoxyCodeLine{9070             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to convert '"{}} + source + \textcolor{stringliteral}{"{}' to destination type"{}} );}
\DoxyCodeLine{9071         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9072             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9073     \}}
\DoxyCodeLine{9074     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, std::string\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9075         target = source;}
\DoxyCodeLine{9076         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9077     \}}
\DoxyCodeLine{9078     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, \textcolor{keywordtype}{bool} \&target ) -\/> ParserResult \{}
\DoxyCodeLine{9079         std::string srcLC = source;}
\DoxyCodeLine{9080         std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c ) \{ return static\_cast<char>( std::tolower(c) ); \} );}
\DoxyCodeLine{9081         \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}y"{}} || srcLC == \textcolor{stringliteral}{"{}1"{}} || srcLC == \textcolor{stringliteral}{"{}true"{}} || srcLC == \textcolor{stringliteral}{"{}yes"{}} || srcLC == \textcolor{stringliteral}{"{}on"{}})}
\DoxyCodeLine{9082             target = \textcolor{keyword}{true};}
\DoxyCodeLine{9083         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (srcLC == \textcolor{stringliteral}{"{}n"{}} || srcLC == \textcolor{stringliteral}{"{}0"{}} || srcLC == \textcolor{stringliteral}{"{}false"{}} || srcLC == \textcolor{stringliteral}{"{}no"{}} || srcLC == \textcolor{stringliteral}{"{}off"{}})}
\DoxyCodeLine{9084             target = \textcolor{keyword}{false};}
\DoxyCodeLine{9085         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9086             \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Expected a boolean value but did not recognise: '"{}} + source + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9087         \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9088     \}}
\DoxyCodeLine{9089 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9090     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9091     \textcolor{keyword}{inline} \textcolor{keyword}{auto} convertInto( std::string \textcolor{keyword}{const} \&source, CLARA\_CONFIG\_OPTIONAL\_TYPE<T>\& target ) -\/> ParserResult \{}
\DoxyCodeLine{9092         T temp;}
\DoxyCodeLine{9093         \textcolor{keyword}{auto} result = convertInto( source, temp );}
\DoxyCodeLine{9094         \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9095             target = std::move(temp);}
\DoxyCodeLine{9096         \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9097     \}}
\DoxyCodeLine{9098 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CLARA\_CONFIG\_OPTIONAL\_TYPE}}
\DoxyCodeLine{9099 }
\DoxyCodeLine{9100     \textcolor{keyword}{struct }NonCopyable \{}
\DoxyCodeLine{9101         NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9102         NonCopyable( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9103         NonCopyable( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9104         NonCopyable \&operator=( NonCopyable \textcolor{keyword}{const} \& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9105         NonCopyable \&operator=( NonCopyable \&\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{9106     \};}
\DoxyCodeLine{9107 }
\DoxyCodeLine{9108     \textcolor{keyword}{struct }BoundRef : NonCopyable \{}
\DoxyCodeLine{9109         \textcolor{keyword}{virtual} \string~BoundRef() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9110         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9111         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{9112     \};}
\DoxyCodeLine{9113     \textcolor{keyword}{struct }BoundValueRefBase : BoundRef \{}
\DoxyCodeLine{9114         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult = 0;}
\DoxyCodeLine{9115     \};}
\DoxyCodeLine{9116     \textcolor{keyword}{struct }BoundFlagRefBase : BoundRef \{}
\DoxyCodeLine{9117         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult = 0;}
\DoxyCodeLine{9118         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} isFlag() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9119     \};}
\DoxyCodeLine{9120 }
\DoxyCodeLine{9121     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9122     \textcolor{keyword}{struct }BoundValueRef : BoundValueRefBase \{}
\DoxyCodeLine{9123         T \&m\_ref;}
\DoxyCodeLine{9124 }
\DoxyCodeLine{9125         \textcolor{keyword}{explicit} BoundValueRef( T \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9126 }
\DoxyCodeLine{9127         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9128             \textcolor{keywordflow}{return} convertInto( arg, m\_ref );}
\DoxyCodeLine{9129         \}}
\DoxyCodeLine{9130     \};}
\DoxyCodeLine{9131 }
\DoxyCodeLine{9132     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9133     \textcolor{keyword}{struct }BoundValueRef<std::vector<T>> : BoundValueRefBase \{}
\DoxyCodeLine{9134         std::vector<T> \&m\_ref;}
\DoxyCodeLine{9135 }
\DoxyCodeLine{9136         \textcolor{keyword}{explicit} BoundValueRef( std::vector<T> \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9137 }
\DoxyCodeLine{9138         \textcolor{keyword}{auto} isContainer() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{9139 }
\DoxyCodeLine{9140         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9141             T temp;}
\DoxyCodeLine{9142             \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9143             \textcolor{keywordflow}{if}( result )}
\DoxyCodeLine{9144                 m\_ref.push\_back( temp );}
\DoxyCodeLine{9145             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9146         \}}
\DoxyCodeLine{9147     \};}
\DoxyCodeLine{9148 }
\DoxyCodeLine{9149     \textcolor{keyword}{struct }BoundFlagRef : BoundFlagRefBase \{}
\DoxyCodeLine{9150         \textcolor{keywordtype}{bool} \&m\_ref;}
\DoxyCodeLine{9151 }
\DoxyCodeLine{9152         \textcolor{keyword}{explicit} BoundFlagRef( \textcolor{keywordtype}{bool} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9153 }
\DoxyCodeLine{9154         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9155             m\_ref = flag;}
\DoxyCodeLine{9156             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9157         \}}
\DoxyCodeLine{9158     \};}
\DoxyCodeLine{9159 }
\DoxyCodeLine{9160     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ReturnType>}
\DoxyCodeLine{9161     \textcolor{keyword}{struct }LambdaInvoker \{}
\DoxyCodeLine{9162         \textcolor{keyword}{static\_assert}( std::is\_same<ReturnType, ParserResult>::value, \textcolor{stringliteral}{"{}Lambda must return void or clara::ParserResult"{}} );}
\DoxyCodeLine{9163 }
\DoxyCodeLine{9164         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9165         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9166             \textcolor{keywordflow}{return} lambda( arg );}
\DoxyCodeLine{9167         \}}
\DoxyCodeLine{9168     \};}
\DoxyCodeLine{9169 }
\DoxyCodeLine{9170     \textcolor{keyword}{template}<>}
\DoxyCodeLine{9171     \textcolor{keyword}{struct }LambdaInvoker<void> \{}
\DoxyCodeLine{9172         \textcolor{keyword}{template}<\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} ArgType>}
\DoxyCodeLine{9173         \textcolor{keyword}{static} \textcolor{keyword}{auto} invoke( L \textcolor{keyword}{const} \&lambda, ArgType \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9174             lambda( arg );}
\DoxyCodeLine{9175             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9176         \}}
\DoxyCodeLine{9177     \};}
\DoxyCodeLine{9178 }
\DoxyCodeLine{9179     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ArgType, \textcolor{keyword}{typename} L>}
\DoxyCodeLine{9180     \textcolor{keyword}{inline} \textcolor{keyword}{auto} invokeLambda( L \textcolor{keyword}{const} \&lambda, std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \{}
\DoxyCodeLine{9181         ArgType temp\{\};}
\DoxyCodeLine{9182         \textcolor{keyword}{auto} result = convertInto( arg, temp );}
\DoxyCodeLine{9183         \textcolor{keywordflow}{return} !result}
\DoxyCodeLine{9184            ? result}
\DoxyCodeLine{9185            : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );}
\DoxyCodeLine{9186     \}}
\DoxyCodeLine{9187 }
\DoxyCodeLine{9188     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9189     \textcolor{keyword}{struct }BoundLambda : BoundValueRefBase \{}
\DoxyCodeLine{9190         L m\_lambda;}
\DoxyCodeLine{9191 }
\DoxyCodeLine{9192         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9193         \textcolor{keyword}{explicit} BoundLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9194 }
\DoxyCodeLine{9195         \textcolor{keyword}{auto} setValue( std::string \textcolor{keyword}{const} \&arg ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9196             \textcolor{keywordflow}{return} invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m\_lambda, arg );}
\DoxyCodeLine{9197         \}}
\DoxyCodeLine{9198     \};}
\DoxyCodeLine{9199 }
\DoxyCodeLine{9200     \textcolor{keyword}{template}<\textcolor{keyword}{typename} L>}
\DoxyCodeLine{9201     \textcolor{keyword}{struct }BoundFlagLambda : BoundFlagRefBase \{}
\DoxyCodeLine{9202         L m\_lambda;}
\DoxyCodeLine{9203 }
\DoxyCodeLine{9204         \textcolor{keyword}{static\_assert}( UnaryLambdaTraits<L>::isValid, \textcolor{stringliteral}{"{}Supplied lambda must take exactly one argument"{}} );}
\DoxyCodeLine{9205         \textcolor{keyword}{static\_assert}( std::is\_same<typename UnaryLambdaTraits<L>::ArgType, \textcolor{keywordtype}{bool}>::value, \textcolor{stringliteral}{"{}flags must be boolean"{}} );}
\DoxyCodeLine{9206 }
\DoxyCodeLine{9207         \textcolor{keyword}{explicit} BoundFlagLambda( L \textcolor{keyword}{const} \&lambda ) : m\_lambda( lambda ) \{\}}
\DoxyCodeLine{9208 }
\DoxyCodeLine{9209         \textcolor{keyword}{auto} setFlag( \textcolor{keywordtype}{bool} flag ) -\/> ParserResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9210             \textcolor{keywordflow}{return} LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m\_lambda, flag );}
\DoxyCodeLine{9211         \}}
\DoxyCodeLine{9212     \};}
\DoxyCodeLine{9213 }
\DoxyCodeLine{9214     \textcolor{keyword}{enum class} Optionality \{ Optional, Required \};}
\DoxyCodeLine{9215 }
\DoxyCodeLine{9216     \textcolor{keyword}{struct }Parser;}
\DoxyCodeLine{9217 }
\DoxyCodeLine{9218     \textcolor{keyword}{class }ParserBase \{}
\DoxyCodeLine{9219     \textcolor{keyword}{public}:}
\DoxyCodeLine{9220         \textcolor{keyword}{virtual} \string~ParserBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9221         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} validate() const -\/> Result \{ \textcolor{keywordflow}{return} Result::ok(); \}}
\DoxyCodeLine{9222         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens) \textcolor{keyword}{const} -\/> InternalParseResult  = 0;}
\DoxyCodeLine{9223         \textcolor{keyword}{virtual} \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 1; \}}
\DoxyCodeLine{9224 }
\DoxyCodeLine{9225         \textcolor{keyword}{auto} parse( Args \textcolor{keyword}{const} \&args ) \textcolor{keyword}{const} -\/> InternalParseResult \{}
\DoxyCodeLine{9226             \textcolor{keywordflow}{return} parse( args.exeName(), TokenStream( args ) );}
\DoxyCodeLine{9227         \}}
\DoxyCodeLine{9228     \};}
\DoxyCodeLine{9229 }
\DoxyCodeLine{9230     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9231     \textcolor{keyword}{class }ComposableParserImpl : \textcolor{keyword}{public} ParserBase \{}
\DoxyCodeLine{9232     \textcolor{keyword}{public}:}
\DoxyCodeLine{9233         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9234         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9235 }
\DoxyCodeLine{9236         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9237         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser;}
\DoxyCodeLine{9238     \};}
\DoxyCodeLine{9239 }
\DoxyCodeLine{9240     \textcolor{comment}{// Common code and state for Args and Opts}}
\DoxyCodeLine{9241     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9242     \textcolor{keyword}{class }ParserRefImpl : \textcolor{keyword}{public} ComposableParserImpl<DerivedT> \{}
\DoxyCodeLine{9243     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9244         Optionality m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9245         std::shared\_ptr<BoundRef> m\_ref;}
\DoxyCodeLine{9246         std::string m\_hint;}
\DoxyCodeLine{9247         std::string m\_description;}
\DoxyCodeLine{9248 }
\DoxyCodeLine{9249         \textcolor{keyword}{explicit} ParserRefImpl( std::shared\_ptr<BoundRef> \textcolor{keyword}{const} \&ref ) : m\_ref( ref ) \{\}}
\DoxyCodeLine{9250 }
\DoxyCodeLine{9251     \textcolor{keyword}{public}:}
\DoxyCodeLine{9252         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9253         ParserRefImpl( T \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9254         :   m\_ref( std::make\_shared<BoundValueRef<T>>( ref ) ),}
\DoxyCodeLine{9255             m\_hint( hint )}
\DoxyCodeLine{9256         \{\}}
\DoxyCodeLine{9257 }
\DoxyCodeLine{9258         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9259         ParserRefImpl( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint )}
\DoxyCodeLine{9260         :   m\_ref( std::make\_shared<BoundLambda<LambdaT>>( ref ) ),}
\DoxyCodeLine{9261             m\_hint(hint)}
\DoxyCodeLine{9262         \{\}}
\DoxyCodeLine{9263 }
\DoxyCodeLine{9264         \textcolor{keyword}{auto} operator()( std::string \textcolor{keyword}{const} \&description ) -\/> DerivedT \& \{}
\DoxyCodeLine{9265             m\_description = description;}
\DoxyCodeLine{9266             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9267         \}}
\DoxyCodeLine{9268 }
\DoxyCodeLine{9269         \textcolor{keyword}{auto} optional() -\/> DerivedT \& \{}
\DoxyCodeLine{9270             m\_optionality = Optionality::Optional;}
\DoxyCodeLine{9271             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9272         \};}
\DoxyCodeLine{9273 }
\DoxyCodeLine{9274         \textcolor{keyword}{auto} required() -\/> DerivedT \& \{}
\DoxyCodeLine{9275             m\_optionality = Optionality::Required;}
\DoxyCodeLine{9276             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}DerivedT \&\textcolor{keyword}{>}( *this );}
\DoxyCodeLine{9277         \};}
\DoxyCodeLine{9278 }
\DoxyCodeLine{9279         \textcolor{keyword}{auto} isOptional() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9280             \textcolor{keywordflow}{return} m\_optionality == Optionality::Optional;}
\DoxyCodeLine{9281         \}}
\DoxyCodeLine{9282 }
\DoxyCodeLine{9283         \textcolor{keyword}{auto} cardinality() const -\/> \textcolor{keywordtype}{size\_t}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9284             \textcolor{keywordflow}{if}( m\_ref-\/>isContainer() )}
\DoxyCodeLine{9285                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{9286             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9287                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{9288         \}}
\DoxyCodeLine{9289 }
\DoxyCodeLine{9290         \textcolor{keyword}{auto} hint() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_hint; \}}
\DoxyCodeLine{9291     \};}
\DoxyCodeLine{9292 }
\DoxyCodeLine{9293     \textcolor{keyword}{class }ExeName : \textcolor{keyword}{public} ComposableParserImpl<ExeName> \{}
\DoxyCodeLine{9294         std::shared\_ptr<std::string> m\_name;}
\DoxyCodeLine{9295         std::shared\_ptr<BoundValueRefBase> m\_ref;}
\DoxyCodeLine{9296 }
\DoxyCodeLine{9297         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9298         \textcolor{keyword}{static} \textcolor{keyword}{auto} makeRef(LambdaT \textcolor{keyword}{const} \&lambda) -\/> std::shared\_ptr<BoundValueRefBase> \{}
\DoxyCodeLine{9299             \textcolor{keywordflow}{return} std::make\_shared<BoundLambda<LambdaT>>( lambda) ;}
\DoxyCodeLine{9300         \}}
\DoxyCodeLine{9301 }
\DoxyCodeLine{9302     \textcolor{keyword}{public}:}
\DoxyCodeLine{9303         ExeName() : m\_name( std::make\_shared<std::string>( \textcolor{stringliteral}{"{}<executable>"{}} ) ) \{\}}
\DoxyCodeLine{9304 }
\DoxyCodeLine{9305         \textcolor{keyword}{explicit} ExeName( std::string \&ref ) : ExeName() \{}
\DoxyCodeLine{9306             m\_ref = std::make\_shared<BoundValueRef<std::string>>( ref );}
\DoxyCodeLine{9307         \}}
\DoxyCodeLine{9308 }
\DoxyCodeLine{9309         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9310         \textcolor{keyword}{explicit} ExeName( LambdaT \textcolor{keyword}{const}\& lambda ) : ExeName() \{}
\DoxyCodeLine{9311             m\_ref = std::make\_shared<BoundLambda<LambdaT>>( lambda );}
\DoxyCodeLine{9312         \}}
\DoxyCodeLine{9313 }
\DoxyCodeLine{9314         \textcolor{comment}{// The exe name is not parsed out of the normal tokens, but is handled specially}}
\DoxyCodeLine{9315         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9316             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9317         \}}
\DoxyCodeLine{9318 }
\DoxyCodeLine{9319         \textcolor{keyword}{auto} name() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} *m\_name; \}}
\DoxyCodeLine{9320         \textcolor{keyword}{auto} set( std::string \textcolor{keyword}{const}\& newName ) -\/> ParserResult \{}
\DoxyCodeLine{9321 }
\DoxyCodeLine{9322             \textcolor{keyword}{auto} lastSlash = newName.find\_last\_of( \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}} );}
\DoxyCodeLine{9323             \textcolor{keyword}{auto} filename = ( lastSlash == std::string::npos )}
\DoxyCodeLine{9324                     ? newName}
\DoxyCodeLine{9325                     : newName.substr( lastSlash+1 );}
\DoxyCodeLine{9326 }
\DoxyCodeLine{9327             *m\_name = filename;}
\DoxyCodeLine{9328             \textcolor{keywordflow}{if}( m\_ref )}
\DoxyCodeLine{9329                 \textcolor{keywordflow}{return} m\_ref-\/>setValue( filename );}
\DoxyCodeLine{9330             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9331                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9332         \}}
\DoxyCodeLine{9333     \};}
\DoxyCodeLine{9334 }
\DoxyCodeLine{9335     \textcolor{keyword}{class }Arg : \textcolor{keyword}{public} ParserRefImpl<Arg> \{}
\DoxyCodeLine{9336     \textcolor{keyword}{public}:}
\DoxyCodeLine{9337         \textcolor{keyword}{using} ParserRefImpl::ParserRefImpl;}
\DoxyCodeLine{9338 }
\DoxyCodeLine{9339         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const} \&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9340             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9341             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9342                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9343 }
\DoxyCodeLine{9344             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9345             \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9346             \textcolor{keywordflow}{if}( token.type != TokenType::Argument )}
\DoxyCodeLine{9347                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9348 }
\DoxyCodeLine{9349             assert( !m\_ref-\/>isFlag() );}
\DoxyCodeLine{9350             \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9351 }
\DoxyCodeLine{9352             \textcolor{keyword}{auto} result = valueRef-\/>setValue( remainingTokens-\/>token );}
\DoxyCodeLine{9353             \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9354                 \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9355             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9356                 \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9357         \}}
\DoxyCodeLine{9358     \};}
\DoxyCodeLine{9359 }
\DoxyCodeLine{9360     \textcolor{keyword}{inline} \textcolor{keyword}{auto} normaliseOpt( std::string \textcolor{keyword}{const} \&optName ) -\/> std::string \{}
\DoxyCodeLine{9361 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9362         \textcolor{keywordflow}{if}( optName[0] == \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9363             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}-\/"{}} + optName.substr( 1 );}
\DoxyCodeLine{9364         \textcolor{keywordflow}{else}}
\DoxyCodeLine{9365 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9366             \textcolor{keywordflow}{return} optName;}
\DoxyCodeLine{9367     \}}
\DoxyCodeLine{9368 }
\DoxyCodeLine{9369     \textcolor{keyword}{class }Opt : \textcolor{keyword}{public} ParserRefImpl<Opt> \{}
\DoxyCodeLine{9370     \textcolor{keyword}{protected}:}
\DoxyCodeLine{9371         std::vector<std::string> m\_optNames;}
\DoxyCodeLine{9372 }
\DoxyCodeLine{9373     \textcolor{keyword}{public}:}
\DoxyCodeLine{9374         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9375         \textcolor{keyword}{explicit} Opt( LambdaT \textcolor{keyword}{const} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagLambda<LambdaT>>( ref ) ) \{\}}
\DoxyCodeLine{9376 }
\DoxyCodeLine{9377         \textcolor{keyword}{explicit} Opt( \textcolor{keywordtype}{bool} \&ref ) : ParserRefImpl( std::make\_shared<BoundFlagRef>( ref ) ) \{\}}
\DoxyCodeLine{9378 }
\DoxyCodeLine{9379         \textcolor{keyword}{template}<\textcolor{keyword}{typename} LambdaT>}
\DoxyCodeLine{9380         Opt( LambdaT \textcolor{keyword}{const} \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9381 }
\DoxyCodeLine{9382         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9383         Opt( T \&ref, std::string \textcolor{keyword}{const} \&hint ) : ParserRefImpl( ref, hint ) \{\}}
\DoxyCodeLine{9384 }
\DoxyCodeLine{9385         \textcolor{keyword}{auto} operator[]( std::string \textcolor{keyword}{const} \&optName ) -\/> Opt \& \{}
\DoxyCodeLine{9386             m\_optNames.push\_back( optName );}
\DoxyCodeLine{9387             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9388         \}}
\DoxyCodeLine{9389 }
\DoxyCodeLine{9390         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9391             std::ostringstream oss;}
\DoxyCodeLine{9392             \textcolor{keywordtype}{bool} first = \textcolor{keyword}{true};}
\DoxyCodeLine{9393             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_optNames ) \{}
\DoxyCodeLine{9394                 \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9395                     first = \textcolor{keyword}{false};}
\DoxyCodeLine{9396                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9397                     oss << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{9398                 oss << opt;}
\DoxyCodeLine{9399             \}}
\DoxyCodeLine{9400             \textcolor{keywordflow}{if}( !m\_hint.empty() )}
\DoxyCodeLine{9401                 oss << \textcolor{stringliteral}{"{} <"{}} << m\_hint << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9402             \textcolor{keywordflow}{return} \{ \{ oss.str(), m\_description \} \};}
\DoxyCodeLine{9403         \}}
\DoxyCodeLine{9404 }
\DoxyCodeLine{9405         \textcolor{keyword}{auto} isMatch( std::string \textcolor{keyword}{const} \&optToken ) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{9406             \textcolor{keyword}{auto} normalisedToken = normaliseOpt( optToken );}
\DoxyCodeLine{9407             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9408                 \textcolor{keywordflow}{if}( normaliseOpt( name ) == normalisedToken )}
\DoxyCodeLine{9409                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{9410             \}}
\DoxyCodeLine{9411             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{9412         \}}
\DoxyCodeLine{9413 }
\DoxyCodeLine{9414         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{9415 }
\DoxyCodeLine{9416         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\&, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9417             \textcolor{keyword}{auto} validationResult = validate();}
\DoxyCodeLine{9418             \textcolor{keywordflow}{if}( !validationResult )}
\DoxyCodeLine{9419                 \textcolor{keywordflow}{return} InternalParseResult( validationResult );}
\DoxyCodeLine{9420 }
\DoxyCodeLine{9421             \textcolor{keyword}{auto} remainingTokens = tokens;}
\DoxyCodeLine{9422             \textcolor{keywordflow}{if}( remainingTokens \&\& remainingTokens-\/>type == TokenType::Option ) \{}
\DoxyCodeLine{9423                 \textcolor{keyword}{auto} \textcolor{keyword}{const} \&token = *remainingTokens;}
\DoxyCodeLine{9424                 \textcolor{keywordflow}{if}( isMatch(token.token ) ) \{}
\DoxyCodeLine{9425                     \textcolor{keywordflow}{if}( m\_ref-\/>isFlag() ) \{}
\DoxyCodeLine{9426                         \textcolor{keyword}{auto} flagRef = \textcolor{keyword}{static\_cast<}detail::BoundFlagRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9427                         \textcolor{keyword}{auto} result = flagRef-\/>setFlag( \textcolor{keyword}{true} );}
\DoxyCodeLine{9428                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9429                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9430                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9431                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9432                     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{9433                         \textcolor{keyword}{auto} valueRef = \textcolor{keyword}{static\_cast<}detail::BoundValueRefBase*\textcolor{keyword}{>}( m\_ref.get() );}
\DoxyCodeLine{9434                         ++remainingTokens;}
\DoxyCodeLine{9435                         \textcolor{keywordflow}{if}( !remainingTokens )}
\DoxyCodeLine{9436                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9437                         \textcolor{keyword}{auto} \textcolor{keyword}{const} \&argToken = *remainingTokens;}
\DoxyCodeLine{9438                         \textcolor{keywordflow}{if}( argToken.type != TokenType::Argument )}
\DoxyCodeLine{9439                             \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Expected argument following "{}} + token.token );}
\DoxyCodeLine{9440                         \textcolor{keyword}{auto} result = valueRef-\/>setValue( argToken.token );}
\DoxyCodeLine{9441                         \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9442                             \textcolor{keywordflow}{return} InternalParseResult( result );}
\DoxyCodeLine{9443                         \textcolor{keywordflow}{if}( result.value() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9444                             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );}
\DoxyCodeLine{9445                     \}}
\DoxyCodeLine{9446                     \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );}
\DoxyCodeLine{9447                 \}}
\DoxyCodeLine{9448             \}}
\DoxyCodeLine{9449             \textcolor{keywordflow}{return} InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );}
\DoxyCodeLine{9450         \}}
\DoxyCodeLine{9451 }
\DoxyCodeLine{9452         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9453             \textcolor{keywordflow}{if}( m\_optNames.empty() )}
\DoxyCodeLine{9454                 \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}No options supplied to Opt"{}} );}
\DoxyCodeLine{9455             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&name : m\_optNames ) \{}
\DoxyCodeLine{9456                 \textcolor{keywordflow}{if}( name.empty() )}
\DoxyCodeLine{9457                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name cannot be empty"{}} );}
\DoxyCodeLine{9458 \textcolor{preprocessor}{\#ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{9459                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} \&\& name[0] != \textcolor{charliteral}{'/'} )}
\DoxyCodeLine{9460                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/' or '/'"{}} );}
\DoxyCodeLine{9461 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9462                 \textcolor{keywordflow}{if}( name[0] != \textcolor{charliteral}{'-\/'} )}
\DoxyCodeLine{9463                     \textcolor{keywordflow}{return} Result::logicError( \textcolor{stringliteral}{"{}Option name must begin with '-\/'"{}} );}
\DoxyCodeLine{9464 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9465             \}}
\DoxyCodeLine{9466             \textcolor{keywordflow}{return} ParserRefImpl::validate();}
\DoxyCodeLine{9467         \}}
\DoxyCodeLine{9468     \};}
\DoxyCodeLine{9469 }
\DoxyCodeLine{9470     \textcolor{keyword}{struct }Help : Opt \{}
\DoxyCodeLine{9471         Help( \textcolor{keywordtype}{bool} \&showHelpFlag )}
\DoxyCodeLine{9472         :   Opt([\&]( bool flag ) \{}
\DoxyCodeLine{9473                 showHelpFlag = flag;}
\DoxyCodeLine{9474                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::ShortCircuitAll );}
\DoxyCodeLine{9475             \})}
\DoxyCodeLine{9476         \{}
\DoxyCodeLine{9477             \textcolor{keyword}{static\_cast<}Opt \&\textcolor{keyword}{>}( *this )}
\DoxyCodeLine{9478                     (\textcolor{stringliteral}{"{}display usage information"{}})}
\DoxyCodeLine{9479                     [\textcolor{stringliteral}{"{}-\/?"{}}][\textcolor{stringliteral}{"{}-\/h"{}}][\textcolor{stringliteral}{"{}-\/-\/help"{}}]}
\DoxyCodeLine{9480                     .optional();}
\DoxyCodeLine{9481         \}}
\DoxyCodeLine{9482     \};}
\DoxyCodeLine{9483 }
\DoxyCodeLine{9484     \textcolor{keyword}{struct }Parser : ParserBase \{}
\DoxyCodeLine{9485 }
\DoxyCodeLine{9486         \textcolor{keyword}{mutable} ExeName m\_exeName;}
\DoxyCodeLine{9487         std::vector<Opt> m\_options;}
\DoxyCodeLine{9488         std::vector<Arg> m\_args;}
\DoxyCodeLine{9489 }
\DoxyCodeLine{9490         \textcolor{keyword}{auto} operator|=( ExeName \textcolor{keyword}{const} \&exeName ) -\/> Parser \& \{}
\DoxyCodeLine{9491             m\_exeName = exeName;}
\DoxyCodeLine{9492             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9493         \}}
\DoxyCodeLine{9494 }
\DoxyCodeLine{9495         \textcolor{keyword}{auto} operator|=( Arg \textcolor{keyword}{const} \&arg ) -\/> Parser \& \{}
\DoxyCodeLine{9496             m\_args.push\_back(arg);}
\DoxyCodeLine{9497             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9498         \}}
\DoxyCodeLine{9499 }
\DoxyCodeLine{9500         \textcolor{keyword}{auto} operator|=( Opt \textcolor{keyword}{const} \&opt ) -\/> Parser \& \{}
\DoxyCodeLine{9501             m\_options.push\_back(opt);}
\DoxyCodeLine{9502             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9503         \}}
\DoxyCodeLine{9504 }
\DoxyCodeLine{9505         \textcolor{keyword}{auto} operator|=( Parser \textcolor{keyword}{const} \&other ) -\/> Parser \& \{}
\DoxyCodeLine{9506             m\_options.insert(m\_options.end(), other.m\_options.begin(), other.m\_options.end());}
\DoxyCodeLine{9507             m\_args.insert(m\_args.end(), other.m\_args.begin(), other.m\_args.end());}
\DoxyCodeLine{9508             \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{9509         \}}
\DoxyCodeLine{9510 }
\DoxyCodeLine{9511         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9512         \textcolor{keyword}{auto} operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9513             \textcolor{keywordflow}{return} Parser( *\textcolor{keyword}{this} ) |= other;}
\DoxyCodeLine{9514         \}}
\DoxyCodeLine{9515 }
\DoxyCodeLine{9516         \textcolor{comment}{// Forward deprecated interface with '+' instead of '|'}}
\DoxyCodeLine{9517         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9518         \textcolor{keyword}{auto} operator+=( T \textcolor{keyword}{const} \&other ) -\/> Parser \& \{ \textcolor{keywordflow}{return} operator|=( other ); \}}
\DoxyCodeLine{9519         \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9520         \textcolor{keyword}{auto} operator+( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{ \textcolor{keywordflow}{return} operator|( other ); \}}
\DoxyCodeLine{9521 }
\DoxyCodeLine{9522         \textcolor{keyword}{auto} getHelpColumns() const -\/> std::vector<HelpColumns> \{}
\DoxyCodeLine{9523             std::vector<HelpColumns> cols;}
\DoxyCodeLine{9524             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&o : m\_options) \{}
\DoxyCodeLine{9525                 \textcolor{keyword}{auto} childCols = o.getHelpColumns();}
\DoxyCodeLine{9526                 cols.insert( cols.end(), childCols.begin(), childCols.end() );}
\DoxyCodeLine{9527             \}}
\DoxyCodeLine{9528             \textcolor{keywordflow}{return} cols;}
\DoxyCodeLine{9529         \}}
\DoxyCodeLine{9530 }
\DoxyCodeLine{9531         \textcolor{keywordtype}{void} writeToStream( std::ostream \&os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9532             \textcolor{keywordflow}{if} (!m\_exeName.name().empty()) \{}
\DoxyCodeLine{9533                 os << \textcolor{stringliteral}{"{}usage:\(\backslash\)n"{}} << \textcolor{stringliteral}{"{}  "{}} << m\_exeName.name() << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9534                 \textcolor{keywordtype}{bool} required = \textcolor{keyword}{true}, first = \textcolor{keyword}{true};}
\DoxyCodeLine{9535                 \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9536                     \textcolor{keywordflow}{if} (first)}
\DoxyCodeLine{9537                         first = \textcolor{keyword}{false};}
\DoxyCodeLine{9538                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9539                         os << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{9540                     \textcolor{keywordflow}{if}( arg.isOptional() \&\& required ) \{}
\DoxyCodeLine{9541                         os << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{9542                         required = \textcolor{keyword}{false};}
\DoxyCodeLine{9543                     \}}
\DoxyCodeLine{9544                     os << \textcolor{stringliteral}{"{}<"{}} << arg.hint() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{9545                     \textcolor{keywordflow}{if}( arg.cardinality() == 0 )}
\DoxyCodeLine{9546                         os << \textcolor{stringliteral}{"{} ... "{}};}
\DoxyCodeLine{9547                 \}}
\DoxyCodeLine{9548                 \textcolor{keywordflow}{if}( !required )}
\DoxyCodeLine{9549                     os << \textcolor{stringliteral}{"{}]"{}};}
\DoxyCodeLine{9550                 \textcolor{keywordflow}{if}( !m\_options.empty() )}
\DoxyCodeLine{9551                     os << \textcolor{stringliteral}{"{} options"{}};}
\DoxyCodeLine{9552                 os << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)nwhere options are:"{}} << std::endl;}
\DoxyCodeLine{9553             \}}
\DoxyCodeLine{9554 }
\DoxyCodeLine{9555             \textcolor{keyword}{auto} rows = getHelpColumns();}
\DoxyCodeLine{9556             \textcolor{keywordtype}{size\_t} consoleWidth = CATCH\_CLARA\_CONFIG\_CONSOLE\_WIDTH;}
\DoxyCodeLine{9557             \textcolor{keywordtype}{size\_t} optWidth = 0;}
\DoxyCodeLine{9558             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows )}
\DoxyCodeLine{9559                 optWidth = (std::max)(optWidth, cols.left.size() + 2);}
\DoxyCodeLine{9560 }
\DoxyCodeLine{9561             optWidth = (std::min)(optWidth, consoleWidth/2);}
\DoxyCodeLine{9562 }
\DoxyCodeLine{9563             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&cols : rows ) \{}
\DoxyCodeLine{9564                 \textcolor{keyword}{auto} row =}
\DoxyCodeLine{9565                         TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +}
\DoxyCodeLine{9566                         TextFlow::Spacer(4) +}
\DoxyCodeLine{9567                         TextFlow::Column( cols.right ).width( consoleWidth -\/ 7 -\/ optWidth );}
\DoxyCodeLine{9568                 os << row << std::endl;}
\DoxyCodeLine{9569             \}}
\DoxyCodeLine{9570         \}}
\DoxyCodeLine{9571 }
\DoxyCodeLine{9572         \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<<( std::ostream \&os, Parser \textcolor{keyword}{const} \&parser ) -\/> std::ostream\& \{}
\DoxyCodeLine{9573             parser.writeToStream( os );}
\DoxyCodeLine{9574             \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9575         \}}
\DoxyCodeLine{9576 }
\DoxyCodeLine{9577         \textcolor{keyword}{auto} validate() const -\/> Result\textcolor{keyword}{ override }\{}
\DoxyCodeLine{9578             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options ) \{}
\DoxyCodeLine{9579                 \textcolor{keyword}{auto} result = opt.validate();}
\DoxyCodeLine{9580                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9581                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9582             \}}
\DoxyCodeLine{9583             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args ) \{}
\DoxyCodeLine{9584                 \textcolor{keyword}{auto} result = arg.validate();}
\DoxyCodeLine{9585                 \textcolor{keywordflow}{if}( !result )}
\DoxyCodeLine{9586                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9587             \}}
\DoxyCodeLine{9588             \textcolor{keywordflow}{return} Result::ok();}
\DoxyCodeLine{9589         \}}
\DoxyCodeLine{9590 }
\DoxyCodeLine{9591         \textcolor{keyword}{using} ParserBase::parse;}
\DoxyCodeLine{9592 }
\DoxyCodeLine{9593         \textcolor{keyword}{auto} parse( std::string \textcolor{keyword}{const}\& exeName, TokenStream \textcolor{keyword}{const} \&tokens ) \textcolor{keyword}{const} -\/> InternalParseResult \textcolor{keyword}{override} \{}
\DoxyCodeLine{9594 }
\DoxyCodeLine{9595             \textcolor{keyword}{struct }ParserInfo \{}
\DoxyCodeLine{9596                 ParserBase \textcolor{keyword}{const}* parser = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{9597                 \textcolor{keywordtype}{size\_t} count = 0;}
\DoxyCodeLine{9598             \};}
\DoxyCodeLine{9599             \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} totalParsers = m\_options.size() + m\_args.size();}
\DoxyCodeLine{9600             assert( totalParsers < 512 );}
\DoxyCodeLine{9601             \textcolor{comment}{// ParserInfo parseInfos[totalParsers]; // <-\/-\/ this is what we really want to do}}
\DoxyCodeLine{9602             ParserInfo parseInfos[512];}
\DoxyCodeLine{9603 }
\DoxyCodeLine{9604             \{}
\DoxyCodeLine{9605                 \textcolor{keywordtype}{size\_t} i = 0;}
\DoxyCodeLine{9606                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&opt : m\_options) parseInfos[i++].parser = \&opt;}
\DoxyCodeLine{9607                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const} \&arg : m\_args) parseInfos[i++].parser = \&arg;}
\DoxyCodeLine{9608             \}}
\DoxyCodeLine{9609 }
\DoxyCodeLine{9610             m\_exeName.set( exeName );}
\DoxyCodeLine{9611 }
\DoxyCodeLine{9612             \textcolor{keyword}{auto} result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );}
\DoxyCodeLine{9613             \textcolor{keywordflow}{while}( result.value().remainingTokens() ) \{}
\DoxyCodeLine{9614                 \textcolor{keywordtype}{bool} tokenParsed = \textcolor{keyword}{false};}
\DoxyCodeLine{9615 }
\DoxyCodeLine{9616                 \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < totalParsers; ++i ) \{}
\DoxyCodeLine{9617                     \textcolor{keyword}{auto}\&  parseInfo = parseInfos[i];}
\DoxyCodeLine{9618                     \textcolor{keywordflow}{if}( parseInfo.parser-\/>cardinality() == 0 || parseInfo.count < parseInfo.parser-\/>cardinality() ) \{}
\DoxyCodeLine{9619                         result = parseInfo.parser-\/>parse(exeName, result.value().remainingTokens());}
\DoxyCodeLine{9620                         if (!result)}
\DoxyCodeLine{9621                             return result;}
\DoxyCodeLine{9622                         if (result.value().type() != ParseResultType::NoMatch) \{}
\DoxyCodeLine{9623                             tokenParsed = true;}
\DoxyCodeLine{9624                             ++parseInfo.count;}
\DoxyCodeLine{9625                             break;}
\DoxyCodeLine{9626                         \}}
\DoxyCodeLine{9627                     \}}
\DoxyCodeLine{9628                 \}}
\DoxyCodeLine{9629 }
\DoxyCodeLine{9630                 \textcolor{keywordflow}{if}( result.value().type() == ParseResultType::ShortCircuitAll )}
\DoxyCodeLine{9631                     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9632                 \textcolor{keywordflow}{if}( !tokenParsed )}
\DoxyCodeLine{9633                     \textcolor{keywordflow}{return} InternalParseResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised token: "{}} + result.value().remainingTokens()-\/>token );}
\DoxyCodeLine{9634             \}}
\DoxyCodeLine{9635             \textcolor{comment}{// !TBD Check missing required options}}
\DoxyCodeLine{9636             \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{9637         \}}
\DoxyCodeLine{9638     \};}
\DoxyCodeLine{9639 }
\DoxyCodeLine{9640     \textcolor{keyword}{template}<\textcolor{keyword}{typename} DerivedT>}
\DoxyCodeLine{9641     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{9642     \textcolor{keyword}{auto} ComposableParserImpl<DerivedT>::operator|( T \textcolor{keyword}{const} \&other ) \textcolor{keyword}{const} -\/> Parser \{}
\DoxyCodeLine{9643         \textcolor{keywordflow}{return} Parser() | \textcolor{keyword}{static\_cast<}DerivedT \textcolor{keyword}{const }\&\textcolor{keyword}{>}( *this ) | other;}
\DoxyCodeLine{9644     \}}
\DoxyCodeLine{9645 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{9646 }
\DoxyCodeLine{9647 \textcolor{comment}{// A Combined parser}}
\DoxyCodeLine{9648 \textcolor{keyword}{using} detail::Parser;}
\DoxyCodeLine{9649 }
\DoxyCodeLine{9650 \textcolor{comment}{// A parser for options}}
\DoxyCodeLine{9651 \textcolor{keyword}{using} detail::Opt;}
\DoxyCodeLine{9652 }
\DoxyCodeLine{9653 \textcolor{comment}{// A parser for arguments}}
\DoxyCodeLine{9654 \textcolor{keyword}{using} detail::Arg;}
\DoxyCodeLine{9655 }
\DoxyCodeLine{9656 \textcolor{comment}{// Wrapper for argc, argv from main()}}
\DoxyCodeLine{9657 \textcolor{keyword}{using} detail::Args;}
\DoxyCodeLine{9658 }
\DoxyCodeLine{9659 \textcolor{comment}{// Specifies the name of the executable}}
\DoxyCodeLine{9660 \textcolor{keyword}{using} detail::ExeName;}
\DoxyCodeLine{9661 }
\DoxyCodeLine{9662 \textcolor{comment}{// Convenience wrapper for option parser that specifies the help option}}
\DoxyCodeLine{9663 \textcolor{keyword}{using} detail::Help;}
\DoxyCodeLine{9664 }
\DoxyCodeLine{9665 \textcolor{comment}{// enum of result types from a parse}}
\DoxyCodeLine{9666 \textcolor{keyword}{using} detail::ParseResultType;}
\DoxyCodeLine{9667 }
\DoxyCodeLine{9668 \textcolor{comment}{// Result type for parser operation}}
\DoxyCodeLine{9669 \textcolor{keyword}{using} detail::ParserResult;}
\DoxyCodeLine{9670 }
\DoxyCodeLine{9671 \}\} \textcolor{comment}{// namespace Catch::clara}}
\DoxyCodeLine{9672 }
\DoxyCodeLine{9673 \textcolor{comment}{// end clara.hpp}}
\DoxyCodeLine{9674 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{9675 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{9676 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9677 }
\DoxyCodeLine{9678 \textcolor{comment}{// Restore Clara's value for console width, if present}}
\DoxyCodeLine{9679 \textcolor{preprocessor}{\#ifdef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9680 \textcolor{preprocessor}{\#define CATCH\_CLARA\_TEXTFLOW\_CONFIG\_CONSOLE\_WIDTH CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9681 \textcolor{preprocessor}{\#undef CATCH\_TEMP\_CLARA\_CONFIG\_CONSOLE\_WIDTH}}
\DoxyCodeLine{9682 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9683 }
\DoxyCodeLine{9684 \textcolor{comment}{// end catch\_clara.h}}
\DoxyCodeLine{9685 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9686 }
\DoxyCodeLine{9687     clara::Parser makeCommandLineParser( ConfigData\& config );}
\DoxyCodeLine{9688 }
\DoxyCodeLine{9689 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9690 }
\DoxyCodeLine{9691 \textcolor{comment}{// end catch\_commandline.h}}
\DoxyCodeLine{9692 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{9693 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{9694 }
\DoxyCodeLine{9695 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9696 }
\DoxyCodeLine{9697     clara::Parser makeCommandLineParser( ConfigData\& config ) \{}
\DoxyCodeLine{9698 }
\DoxyCodeLine{9699         \textcolor{keyword}{using namespace }clara;}
\DoxyCodeLine{9700 }
\DoxyCodeLine{9701         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWarning = [\&]( std::string \textcolor{keyword}{const}\& warning ) \{}
\DoxyCodeLine{9702                 \textcolor{keyword}{auto} warningSet = [\&]() \{}
\DoxyCodeLine{9703                     \textcolor{keywordflow}{if}( warning == \textcolor{stringliteral}{"{}NoAssertions"{}} )}
\DoxyCodeLine{9704                         \textcolor{keywordflow}{return} WarnAbout::NoAssertions;}
\DoxyCodeLine{9705 }
\DoxyCodeLine{9706                     \textcolor{keywordflow}{if} ( warning == \textcolor{stringliteral}{"{}NoTests"{}} )}
\DoxyCodeLine{9707                         \textcolor{keywordflow}{return} WarnAbout::NoTests;}
\DoxyCodeLine{9708 }
\DoxyCodeLine{9709                     \textcolor{keywordflow}{return} WarnAbout::Nothing;}
\DoxyCodeLine{9710                 \}();}
\DoxyCodeLine{9711 }
\DoxyCodeLine{9712                 \textcolor{keywordflow}{if} (warningSet == WarnAbout::Nothing)}
\DoxyCodeLine{9713                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised warning: '"{}} + warning + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9714                 config.warnings = \textcolor{keyword}{static\_cast<}WarnAbout::What\textcolor{keyword}{>}( config.warnings | warningSet );}
\DoxyCodeLine{9715                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9716             \};}
\DoxyCodeLine{9717         \textcolor{keyword}{auto} \textcolor{keyword}{const} loadTestNamesFromFile = [\&]( std::string \textcolor{keyword}{const}\& filename ) \{}
\DoxyCodeLine{9718                 std::ifstream f( filename.c\_str() );}
\DoxyCodeLine{9719                 \textcolor{keywordflow}{if}( !f.is\_open() )}
\DoxyCodeLine{9720                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unable to load input file: '"{}} + filename + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9721 }
\DoxyCodeLine{9722                 std::string line;}
\DoxyCodeLine{9723                 \textcolor{keywordflow}{while}( std::getline( f, line ) ) \{}
\DoxyCodeLine{9724                     line = trim(line);}
\DoxyCodeLine{9725                     \textcolor{keywordflow}{if}( !line.empty() \&\& !startsWith( line, \textcolor{charliteral}{'\#'} ) ) \{}
\DoxyCodeLine{9726                         \textcolor{keywordflow}{if}( !startsWith( line, \textcolor{charliteral}{'"{}'} ) )}
\DoxyCodeLine{9727                             line = \textcolor{charliteral}{'"{}'} + line + '"{}';}
\DoxyCodeLine{9728                         config.testsOrTags.push\_back( line );}
\DoxyCodeLine{9729                         config.testsOrTags.emplace\_back( \textcolor{stringliteral}{"{},"{}} );}
\DoxyCodeLine{9730                     \}}
\DoxyCodeLine{9731                 \}}
\DoxyCodeLine{9732                 \textcolor{comment}{//Remove comma in the end}}
\DoxyCodeLine{9733                 \textcolor{keywordflow}{if}(!config.testsOrTags.empty())}
\DoxyCodeLine{9734                     config.testsOrTags.erase( config.testsOrTags.end()-\/1 );}
\DoxyCodeLine{9735 }
\DoxyCodeLine{9736                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9737             \};}
\DoxyCodeLine{9738         \textcolor{keyword}{auto} \textcolor{keyword}{const} setTestOrder = [\&]( std::string \textcolor{keyword}{const}\& order ) \{}
\DoxyCodeLine{9739                 \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}declared"{}}, order ) )}
\DoxyCodeLine{9740                     config.runOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{9741                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}lexical"{}}, order ) )}
\DoxyCodeLine{9742                     config.runOrder = RunTests::InLexicographicalOrder;}
\DoxyCodeLine{9743                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( startsWith( \textcolor{stringliteral}{"{}random"{}}, order ) )}
\DoxyCodeLine{9744                     config.runOrder = RunTests::InRandomOrder;}
\DoxyCodeLine{9745                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9746                     \textcolor{keywordflow}{return} clara::ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised ordering: '"{}} + order + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9747                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9748             \};}
\DoxyCodeLine{9749         \textcolor{keyword}{auto} \textcolor{keyword}{const} setRngSeed = [\&]( std::string \textcolor{keyword}{const}\& seed ) \{}
\DoxyCodeLine{9750                 \textcolor{keywordflow}{if}( seed != \textcolor{stringliteral}{"{}time"{}} )}
\DoxyCodeLine{9751                     \textcolor{keywordflow}{return} clara::detail::convertInto( seed, config.rngSeed );}
\DoxyCodeLine{9752                 config.rngSeed = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}( std::time(\textcolor{keyword}{nullptr}) );}
\DoxyCodeLine{9753                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9754             \};}
\DoxyCodeLine{9755         \textcolor{keyword}{auto} \textcolor{keyword}{const} setColourUsage = [\&]( std::string \textcolor{keyword}{const}\& useColour ) \{}
\DoxyCodeLine{9756                     \textcolor{keyword}{auto} mode = toLower( useColour );}
\DoxyCodeLine{9757 }
\DoxyCodeLine{9758                     \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}yes"{}} )}
\DoxyCodeLine{9759                         config.useColour = UseColour::Yes;}
\DoxyCodeLine{9760                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}no"{}} )}
\DoxyCodeLine{9761                         config.useColour = UseColour::No;}
\DoxyCodeLine{9762                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( mode == \textcolor{stringliteral}{"{}auto"{}} )}
\DoxyCodeLine{9763                         config.useColour = UseColour::Auto;}
\DoxyCodeLine{9764                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{9765                         \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}colour mode must be one of: auto, yes or no. '"{}} + useColour + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9766                 \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9767             \};}
\DoxyCodeLine{9768         \textcolor{keyword}{auto} \textcolor{keyword}{const} setWaitForKeypress = [\&]( std::string \textcolor{keyword}{const}\& keypress ) \{}
\DoxyCodeLine{9769                 \textcolor{keyword}{auto} keypressLc = toLower( keypress );}
\DoxyCodeLine{9770                 \textcolor{keywordflow}{if} (keypressLc == \textcolor{stringliteral}{"{}never"{}})}
\DoxyCodeLine{9771                     config.waitForKeypress = WaitForKeypress::Never;}
\DoxyCodeLine{9772                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}start"{}} )}
\DoxyCodeLine{9773                     config.waitForKeypress = WaitForKeypress::BeforeStart;}
\DoxyCodeLine{9774                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}exit"{}} )}
\DoxyCodeLine{9775                     config.waitForKeypress = WaitForKeypress::BeforeExit;}
\DoxyCodeLine{9776                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( keypressLc == \textcolor{stringliteral}{"{}both"{}} )}
\DoxyCodeLine{9777                     config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;}
\DoxyCodeLine{9778                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{9779                     \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}keypress argument must be one of: never, start, exit or both. '"{}} + keypress + \textcolor{stringliteral}{"{}' not recognised"{}} );}
\DoxyCodeLine{9780             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9781             \};}
\DoxyCodeLine{9782         \textcolor{keyword}{auto} \textcolor{keyword}{const} setVerbosity = [\&]( std::string \textcolor{keyword}{const}\& verbosity ) \{}
\DoxyCodeLine{9783             \textcolor{keyword}{auto} lcVerbosity = toLower( verbosity );}
\DoxyCodeLine{9784             \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}quiet"{}} )}
\DoxyCodeLine{9785                 config.verbosity = Verbosity::Quiet;}
\DoxyCodeLine{9786             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}normal"{}} )}
\DoxyCodeLine{9787                 config.verbosity = Verbosity::Normal;}
\DoxyCodeLine{9788             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( lcVerbosity == \textcolor{stringliteral}{"{}high"{}} )}
\DoxyCodeLine{9789                 config.verbosity = Verbosity::High;}
\DoxyCodeLine{9790             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9791                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognised verbosity, '"{}} + verbosity + \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{9792             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9793         \};}
\DoxyCodeLine{9794         \textcolor{keyword}{auto} \textcolor{keyword}{const} setReporter = [\&]( std::string \textcolor{keyword}{const}\& reporter ) \{}
\DoxyCodeLine{9795             IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{9796 }
\DoxyCodeLine{9797             \textcolor{keyword}{auto} lcReporter = toLower( reporter );}
\DoxyCodeLine{9798             \textcolor{keyword}{auto} result = factories.find( lcReporter );}
\DoxyCodeLine{9799 }
\DoxyCodeLine{9800             \textcolor{keywordflow}{if}( factories.end() != result )}
\DoxyCodeLine{9801                 config.reporterName = lcReporter;}
\DoxyCodeLine{9802             \textcolor{keywordflow}{else}}
\DoxyCodeLine{9803                 \textcolor{keywordflow}{return} ParserResult::runtimeError( \textcolor{stringliteral}{"{}Unrecognized reporter, '"{}} + reporter + \textcolor{stringliteral}{"{}'. Check available with -\/-\/list-\/reporters"{}} );}
\DoxyCodeLine{9804             \textcolor{keywordflow}{return} ParserResult::ok( ParseResultType::Matched );}
\DoxyCodeLine{9805         \};}
\DoxyCodeLine{9806 }
\DoxyCodeLine{9807         \textcolor{keyword}{auto} cli}
\DoxyCodeLine{9808             = ExeName( config.processName )}
\DoxyCodeLine{9809             | Help( config.showHelp )}
\DoxyCodeLine{9810             | Opt( config.listTests )}
\DoxyCodeLine{9811                 ["{}-\/l"{}]["{}-\/-\/list-\/tests"{}]}
\DoxyCodeLine{9812                 ( \textcolor{stringliteral}{"{}list all/matching test cases"{}} )}
\DoxyCodeLine{9813             | Opt( config.listTags )}
\DoxyCodeLine{9814                 ["{}-\/t"{}]["{}-\/-\/list-\/tags"{}]}
\DoxyCodeLine{9815                 ( \textcolor{stringliteral}{"{}list all/matching tags"{}} )}
\DoxyCodeLine{9816             | Opt( config.showSuccessfulTests )}
\DoxyCodeLine{9817                 ["{}-\/s"{}]["{}-\/-\/success"{}]}
\DoxyCodeLine{9818                 ( \textcolor{stringliteral}{"{}include successful tests in output"{}} )}
\DoxyCodeLine{9819             | Opt( config.shouldDebugBreak )}
\DoxyCodeLine{9820                 ["{}-\/b"{}]["{}-\/-\/break"{}]}
\DoxyCodeLine{9821                 ( \textcolor{stringliteral}{"{}break into debugger on failure"{}} )}
\DoxyCodeLine{9822             | Opt( config.noThrow )}
\DoxyCodeLine{9823                 ["{}-\/e"{}]["{}-\/-\/nothrow"{}]}
\DoxyCodeLine{9824                 ( \textcolor{stringliteral}{"{}skip exception tests"{}} )}
\DoxyCodeLine{9825             | Opt( config.showInvisibles )}
\DoxyCodeLine{9826                 ["{}-\/i"{}]["{}-\/-\/invisibles"{}]}
\DoxyCodeLine{9827                 ( \textcolor{stringliteral}{"{}show invisibles (tabs, newlines)"{}} )}
\DoxyCodeLine{9828             | Opt( config.outputFilename, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9829                 ["{}-\/o"{}]["{}-\/-\/out"{}]}
\DoxyCodeLine{9830                 ( \textcolor{stringliteral}{"{}output filename"{}} )}
\DoxyCodeLine{9831             | Opt( setReporter, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9832                 ["{}-\/r"{}]["{}-\/-\/reporter"{}]}
\DoxyCodeLine{9833                 ( \textcolor{stringliteral}{"{}reporter to use (defaults to console)"{}} )}
\DoxyCodeLine{9834             | Opt( config.name, \textcolor{stringliteral}{"{}name"{}} )}
\DoxyCodeLine{9835                 ["{}-\/n"{}]["{}-\/-\/name"{}]}
\DoxyCodeLine{9836                 ( \textcolor{stringliteral}{"{}suite name"{}} )}
\DoxyCodeLine{9837             | Opt( [\&]( \textcolor{keywordtype}{bool} )\{ config.abortAfter = 1; \} )}
\DoxyCodeLine{9838                 [\textcolor{stringliteral}{"{}-\/a"{}}][\textcolor{stringliteral}{"{}-\/-\/abort"{}}]}
\DoxyCodeLine{9839                 ( \textcolor{stringliteral}{"{}abort at first failure"{}} )}
\DoxyCodeLine{9840             | Opt( [\&]( \textcolor{keywordtype}{int} x )\{ config.abortAfter = x; \}, \textcolor{stringliteral}{"{}no. failures"{}} )}
\DoxyCodeLine{9841                 [\textcolor{stringliteral}{"{}-\/x"{}}][\textcolor{stringliteral}{"{}-\/-\/abortx"{}}]}
\DoxyCodeLine{9842                 ( \textcolor{stringliteral}{"{}abort after x failures"{}} )}
\DoxyCodeLine{9843             | Opt( setWarning, \textcolor{stringliteral}{"{}warning name"{}} )}
\DoxyCodeLine{9844                 ["{}-\/w"{}]["{}-\/-\/warn"{}]}
\DoxyCodeLine{9845                 ( \textcolor{stringliteral}{"{}enable warnings"{}} )}
\DoxyCodeLine{9846             | Opt( [\&]( \textcolor{keywordtype}{bool} flag ) \{ config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; \}, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9847                 [\textcolor{stringliteral}{"{}-\/d"{}}][\textcolor{stringliteral}{"{}-\/-\/durations"{}}]}
\DoxyCodeLine{9848                 ( \textcolor{stringliteral}{"{}show test durations"{}} )}
\DoxyCodeLine{9849             | Opt( config.minDuration, \textcolor{stringliteral}{"{}seconds"{}} )}
\DoxyCodeLine{9850                 ["{}-\/D"{}]["{}-\/-\/min-\/duration"{}]}
\DoxyCodeLine{9851                 ( \textcolor{stringliteral}{"{}show test durations for tests taking at least the given number of seconds"{}} )}
\DoxyCodeLine{9852             | Opt( loadTestNamesFromFile, \textcolor{stringliteral}{"{}filename"{}} )}
\DoxyCodeLine{9853                 ["{}-\/f"{}]["{}-\/-\/input-\/file"{}]}
\DoxyCodeLine{9854                 ( \textcolor{stringliteral}{"{}load test names to run from a file"{}} )}
\DoxyCodeLine{9855             | Opt( config.filenamesAsTags )}
\DoxyCodeLine{9856                 ["{}-\/\#"{}]["{}-\/-\/filenames-\/as-\/tags"{}]}
\DoxyCodeLine{9857                 ( \textcolor{stringliteral}{"{}adds a tag for the filename"{}} )}
\DoxyCodeLine{9858             | Opt( config.sectionsToRun, \textcolor{stringliteral}{"{}section name"{}} )}
\DoxyCodeLine{9859                 ["{}-\/c"{}]["{}-\/-\/section"{}]}
\DoxyCodeLine{9860                 ( \textcolor{stringliteral}{"{}specify section to run"{}} )}
\DoxyCodeLine{9861             | Opt( setVerbosity, \textcolor{stringliteral}{"{}quiet|normal|high"{}} )}
\DoxyCodeLine{9862                 ["{}-\/v"{}]["{}-\/-\/verbosity"{}]}
\DoxyCodeLine{9863                 ( \textcolor{stringliteral}{"{}set output verbosity"{}} )}
\DoxyCodeLine{9864             | Opt( config.listTestNamesOnly )}
\DoxyCodeLine{9865                 ["{}-\/-\/list-\/test-\/names-\/only"{}]}
\DoxyCodeLine{9866                 ( \textcolor{stringliteral}{"{}list all/matching test cases names only"{}} )}
\DoxyCodeLine{9867             | Opt( config.listReporters )}
\DoxyCodeLine{9868                 ["{}-\/-\/list-\/reporters"{}]}
\DoxyCodeLine{9869                 ( \textcolor{stringliteral}{"{}list all reporters"{}} )}
\DoxyCodeLine{9870             | Opt( setTestOrder, \textcolor{stringliteral}{"{}decl|lex|rand"{}} )}
\DoxyCodeLine{9871                 ["{}-\/-\/order"{}]}
\DoxyCodeLine{9872                 ( \textcolor{stringliteral}{"{}test case order (defaults to decl)"{}} )}
\DoxyCodeLine{9873             | Opt( setRngSeed, \textcolor{stringliteral}{"{}'time'|number"{}} )}
\DoxyCodeLine{9874                 ["{}-\/-\/rng-\/seed"{}]}
\DoxyCodeLine{9875                 ( \textcolor{stringliteral}{"{}set a specific seed for random numbers"{}} )}
\DoxyCodeLine{9876             | Opt( setColourUsage, \textcolor{stringliteral}{"{}yes|no"{}} )}
\DoxyCodeLine{9877                 ["{}-\/-\/use-\/colour"{}]}
\DoxyCodeLine{9878                 ( \textcolor{stringliteral}{"{}should output be colourised"{}} )}
\DoxyCodeLine{9879             | Opt( config.libIdentify )}
\DoxyCodeLine{9880                 ["{}-\/-\/libidentify"{}]}
\DoxyCodeLine{9881                 ( \textcolor{stringliteral}{"{}report name and version according to libidentify standard"{}} )}
\DoxyCodeLine{9882             | Opt( setWaitForKeypress, \textcolor{stringliteral}{"{}never|start|exit|both"{}} )}
\DoxyCodeLine{9883                 ["{}-\/-\/wait-\/for-\/keypress"{}]}
\DoxyCodeLine{9884                 ( \textcolor{stringliteral}{"{}waits for a keypress before exiting"{}} )}
\DoxyCodeLine{9885             | Opt( config.benchmarkSamples, \textcolor{stringliteral}{"{}samples"{}} )}
\DoxyCodeLine{9886                 ["{}-\/-\/benchmark-\/samples"{}]}
\DoxyCodeLine{9887                 ( \textcolor{stringliteral}{"{}number of samples to collect (default: 100)"{}} )}
\DoxyCodeLine{9888             | Opt( config.benchmarkResamples, \textcolor{stringliteral}{"{}resamples"{}} )}
\DoxyCodeLine{9889                 ["{}-\/-\/benchmark-\/resamples"{}]}
\DoxyCodeLine{9890                 ( \textcolor{stringliteral}{"{}number of resamples for the bootstrap (default: 100000)"{}} )}
\DoxyCodeLine{9891             | Opt( config.benchmarkConfidenceInterval, \textcolor{stringliteral}{"{}confidence interval"{}} )}
\DoxyCodeLine{9892                 ["{}-\/-\/benchmark-\/confidence-\/interval"{}]}
\DoxyCodeLine{9893                 ( \textcolor{stringliteral}{"{}confidence interval for the bootstrap (between 0 and 1, default: 0.95)"{}} )}
\DoxyCodeLine{9894             | Opt( config.benchmarkNoAnalysis )}
\DoxyCodeLine{9895                 ["{}-\/-\/benchmark-\/no-\/analysis"{}]}
\DoxyCodeLine{9896                 ( \textcolor{stringliteral}{"{}perform only measurements; do not perform any analysis"{}} )}
\DoxyCodeLine{9897             | Opt( config.benchmarkWarmupTime, \textcolor{stringliteral}{"{}benchmarkWarmupTime"{}} )}
\DoxyCodeLine{9898                 ["{}-\/-\/benchmark-\/warmup-\/time"{}]}
\DoxyCodeLine{9899                 ( \textcolor{stringliteral}{"{}amount of time in milliseconds spent on warming up each test (default: 100)"{}} )}
\DoxyCodeLine{9900             | Arg( config.testsOrTags, \textcolor{stringliteral}{"{}test name|pattern|tags"{}} )}
\DoxyCodeLine{9901                 ( \textcolor{stringliteral}{"{}which test or tests to use"{}} );}
\DoxyCodeLine{9902 }
\DoxyCodeLine{9903         \textcolor{keywordflow}{return} cli;}
\DoxyCodeLine{9904     \}}
\DoxyCodeLine{9905 }
\DoxyCodeLine{9906 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{9907 \textcolor{comment}{// end catch\_commandline.cpp}}
\DoxyCodeLine{9908 \textcolor{comment}{// start catch\_common.cpp}}
\DoxyCodeLine{9909 }
\DoxyCodeLine{9910 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{9911 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{9912 }
\DoxyCodeLine{9913 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9914 }
\DoxyCodeLine{9915     \textcolor{keywordtype}{bool} SourceLineInfo::operator == ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9916         \textcolor{keywordflow}{return} line == other.line \&\& (file == other.file || std::strcmp(file, other.file) == 0);}
\DoxyCodeLine{9917     \}}
\DoxyCodeLine{9918     \textcolor{keywordtype}{bool} SourceLineInfo::operator < ( SourceLineInfo \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{9919         \textcolor{comment}{// We can assume that the same file will usually have the same pointer.}}
\DoxyCodeLine{9920         \textcolor{comment}{// Thus, if the pointers are the same, there is no point in calling the strcmp}}
\DoxyCodeLine{9921         \textcolor{keywordflow}{return} line < other.line || ( line == other.line \&\& file != other.file \&\& (std::strcmp(file, other.file) < 0));}
\DoxyCodeLine{9922     \}}
\DoxyCodeLine{9923 }
\DoxyCodeLine{9924     std::ostream\& operator << ( std::ostream\& os, SourceLineInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{9925 \textcolor{preprocessor}{\#ifndef \_\_GNUG\_\_}}
\DoxyCodeLine{9926         os << info.file << \textcolor{charliteral}{'('} << info.line << \textcolor{charliteral}{')'};}
\DoxyCodeLine{9927 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{9928         os << info.file << \textcolor{charliteral}{':'} << info.line;}
\DoxyCodeLine{9929 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{9930         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{9931     \}}
\DoxyCodeLine{9932 }
\DoxyCodeLine{9933     std::string StreamEndStop::operator+()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9934         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{9935     \}}
\DoxyCodeLine{9936 }
\DoxyCodeLine{9937     NonCopyable::NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9938     NonCopyable::\string~NonCopyable() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{9939 }
\DoxyCodeLine{9940 \}}
\DoxyCodeLine{9941 \textcolor{comment}{// end catch\_common.cpp}}
\DoxyCodeLine{9942 \textcolor{comment}{// start catch\_config.cpp}}
\DoxyCodeLine{9943 }
\DoxyCodeLine{9944 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{9945 }
\DoxyCodeLine{9946     Config::Config( ConfigData \textcolor{keyword}{const}\& data )}
\DoxyCodeLine{9947     :   m\_data( data ),}
\DoxyCodeLine{9948         m\_stream( openStream() )}
\DoxyCodeLine{9949     \{}
\DoxyCodeLine{9950         \textcolor{comment}{// We need to trim filter specs to avoid trouble with superfluous}}
\DoxyCodeLine{9951         \textcolor{comment}{// whitespace (esp. important for bdd macros, as those are manually}}
\DoxyCodeLine{9952         \textcolor{comment}{// aligned with whitespace).}}
\DoxyCodeLine{9953 }
\DoxyCodeLine{9954         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.testsOrTags) \{}
\DoxyCodeLine{9955             elem = trim(elem);}
\DoxyCodeLine{9956         \}}
\DoxyCodeLine{9957         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& elem : m\_data.sectionsToRun) \{}
\DoxyCodeLine{9958             elem = trim(elem);}
\DoxyCodeLine{9959         \}}
\DoxyCodeLine{9960 }
\DoxyCodeLine{9961         TestSpecParser parser(ITagAliasRegistry::get());}
\DoxyCodeLine{9962         \textcolor{keywordflow}{if} (!m\_data.testsOrTags.empty()) \{}
\DoxyCodeLine{9963             m\_hasTestFilters = \textcolor{keyword}{true};}
\DoxyCodeLine{9964             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testOrTags : m\_data.testsOrTags) \{}
\DoxyCodeLine{9965                 parser.parse(testOrTags);}
\DoxyCodeLine{9966             \}}
\DoxyCodeLine{9967         \}}
\DoxyCodeLine{9968         m\_testSpec = parser.testSpec();}
\DoxyCodeLine{9969     \}}
\DoxyCodeLine{9970 }
\DoxyCodeLine{9971     std::string \textcolor{keyword}{const}\& Config::getFilename()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{9972         \textcolor{keywordflow}{return} m\_data.outputFilename ;}
\DoxyCodeLine{9973     \}}
\DoxyCodeLine{9974 }
\DoxyCodeLine{9975     \textcolor{keywordtype}{bool} Config::listTests()\textcolor{keyword}{ const          }\{ \textcolor{keywordflow}{return} m\_data.listTests; \}}
\DoxyCodeLine{9976     \textcolor{keywordtype}{bool} Config::listTestNamesOnly()\textcolor{keyword}{ const  }\{ \textcolor{keywordflow}{return} m\_data.listTestNamesOnly; \}}
\DoxyCodeLine{9977     \textcolor{keywordtype}{bool} Config::listTags()\textcolor{keyword}{ const           }\{ \textcolor{keywordflow}{return} m\_data.listTags; \}}
\DoxyCodeLine{9978     \textcolor{keywordtype}{bool} Config::listReporters()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.listReporters; \}}
\DoxyCodeLine{9979 }
\DoxyCodeLine{9980     std::string Config::getProcessName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.processName; \}}
\DoxyCodeLine{9981     std::string \textcolor{keyword}{const}\& Config::getReporterName()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.reporterName; \}}
\DoxyCodeLine{9982 }
\DoxyCodeLine{9983     std::vector<std::string> \textcolor{keyword}{const}\& Config::getTestsOrTags()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.testsOrTags; \}}
\DoxyCodeLine{9984     std::vector<std::string> \textcolor{keyword}{const}\& Config::getSectionsToRun()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.sectionsToRun; \}}
\DoxyCodeLine{9985 }
\DoxyCodeLine{9986     TestSpec \textcolor{keyword}{const}\& Config::testSpec()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_testSpec; \}}
\DoxyCodeLine{9987     \textcolor{keywordtype}{bool} Config::hasTestFilters()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_hasTestFilters; \}}
\DoxyCodeLine{9988 }
\DoxyCodeLine{9989     \textcolor{keywordtype}{bool} Config::showHelp()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showHelp; \}}
\DoxyCodeLine{9990 }
\DoxyCodeLine{9991     \textcolor{comment}{// IConfig interface}}
\DoxyCodeLine{9992     \textcolor{keywordtype}{bool} Config::allowThrows()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} !m\_data.noThrow; \}}
\DoxyCodeLine{9993     std::ostream\& Config::stream()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_stream-\/>stream(); \}}
\DoxyCodeLine{9994     std::string Config::name()\textcolor{keyword}{ const                   }\{ \textcolor{keywordflow}{return} m\_data.name.empty() ? m\_data.processName : m\_data.name; \}}
\DoxyCodeLine{9995     \textcolor{keywordtype}{bool} Config::includeSuccessfulResults()\textcolor{keyword}{ const      }\{ \textcolor{keywordflow}{return} m\_data.showSuccessfulTests; \}}
\DoxyCodeLine{9996     \textcolor{keywordtype}{bool} Config::warnAboutMissingAssertions()\textcolor{keyword}{ const    }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoAssertions); \}}
\DoxyCodeLine{9997     \textcolor{keywordtype}{bool} Config::warnAboutNoTests()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} !!(m\_data.warnings \& WarnAbout::NoTests); \}}
\DoxyCodeLine{9998     ShowDurations::OrNot Config::showDurations()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_data.showDurations; \}}
\DoxyCodeLine{9999     \textcolor{keywordtype}{double} Config::minDuration()\textcolor{keyword}{ const                 }\{ \textcolor{keywordflow}{return} m\_data.minDuration; \}}
\DoxyCodeLine{10000     RunTests::InWhatOrder Config::runOrder()\textcolor{keyword}{ const     }\{ \textcolor{keywordflow}{return} m\_data.runOrder; \}}
\DoxyCodeLine{10001     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::rngSeed()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.rngSeed; \}}
\DoxyCodeLine{10002     UseColour::YesOrNo Config::useColour()\textcolor{keyword}{ const       }\{ \textcolor{keywordflow}{return} m\_data.useColour; \}}
\DoxyCodeLine{10003     \textcolor{keywordtype}{bool} Config::shouldDebugBreak()\textcolor{keyword}{ const              }\{ \textcolor{keywordflow}{return} m\_data.shouldDebugBreak; \}}
\DoxyCodeLine{10004     \textcolor{keywordtype}{int} Config::abortAfter()\textcolor{keyword}{ const                     }\{ \textcolor{keywordflow}{return} m\_data.abortAfter; \}}
\DoxyCodeLine{10005     \textcolor{keywordtype}{bool} Config::showInvisibles()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.showInvisibles; \}}
\DoxyCodeLine{10006     Verbosity Config::verbosity()\textcolor{keyword}{ const                }\{ \textcolor{keywordflow}{return} m\_data.verbosity; \}}
\DoxyCodeLine{10007 }
\DoxyCodeLine{10008     \textcolor{keywordtype}{bool} Config::benchmarkNoAnalysis()\textcolor{keyword}{ const                      }\{ \textcolor{keywordflow}{return} m\_data.benchmarkNoAnalysis; \}}
\DoxyCodeLine{10009     \textcolor{keywordtype}{int} Config::benchmarkSamples()\textcolor{keyword}{ const                          }\{ \textcolor{keywordflow}{return} m\_data.benchmarkSamples; \}}
\DoxyCodeLine{10010     \textcolor{keywordtype}{double} Config::benchmarkConfidenceInterval()\textcolor{keyword}{ const            }\{ \textcolor{keywordflow}{return} m\_data.benchmarkConfidenceInterval; \}}
\DoxyCodeLine{10011     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} Config::benchmarkResamples()\textcolor{keyword}{ const               }\{ \textcolor{keywordflow}{return} m\_data.benchmarkResamples; \}}
\DoxyCodeLine{10012     std::chrono::milliseconds Config::benchmarkWarmupTime()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::chrono::milliseconds(m\_data.benchmarkWarmupTime); \}}
\DoxyCodeLine{10013 }
\DoxyCodeLine{10014     IStream \textcolor{keyword}{const}* Config::openStream() \{}
\DoxyCodeLine{10015         \textcolor{keywordflow}{return} Catch::makeStream(m\_data.outputFilename);}
\DoxyCodeLine{10016     \}}
\DoxyCodeLine{10017 }
\DoxyCodeLine{10018 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10019 \textcolor{comment}{// end catch\_config.cpp}}
\DoxyCodeLine{10020 \textcolor{comment}{// start catch\_console\_colour.cpp}}
\DoxyCodeLine{10021 }
\DoxyCodeLine{10022 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10023 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{10024 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{10025 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10026 }
\DoxyCodeLine{10027 \textcolor{comment}{// start catch\_errno\_guard.h}}
\DoxyCodeLine{10028 }
\DoxyCodeLine{10029 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10030 }
\DoxyCodeLine{10031     \textcolor{keyword}{class }ErrnoGuard \{}
\DoxyCodeLine{10032     \textcolor{keyword}{public}:}
\DoxyCodeLine{10033         ErrnoGuard();}
\DoxyCodeLine{10034         \string~ErrnoGuard();}
\DoxyCodeLine{10035     \textcolor{keyword}{private}:}
\DoxyCodeLine{10036         \textcolor{keywordtype}{int} m\_oldErrno;}
\DoxyCodeLine{10037     \};}
\DoxyCodeLine{10038 }
\DoxyCodeLine{10039 \}}
\DoxyCodeLine{10040 }
\DoxyCodeLine{10041 \textcolor{comment}{// end catch\_errno\_guard.h}}
\DoxyCodeLine{10042 \textcolor{comment}{// start catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{10043 }
\DoxyCodeLine{10044 }
\DoxyCodeLine{10045 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10046 }
\DoxyCodeLine{10047 \textcolor{preprocessor}{\#if !defined(NOMINMAX) \&\& !defined(CATCH\_CONFIG\_NO\_NOMINMAX)}}
\DoxyCodeLine{10048 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{10049 \textcolor{preprocessor}{\#  define NOMINMAX}}
\DoxyCodeLine{10050 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10051 \textcolor{preprocessor}{\#if !defined(WIN32\_LEAN\_AND\_MEAN) \&\& !defined(CATCH\_CONFIG\_NO\_WIN32\_LEAN\_AND\_MEAN)}}
\DoxyCodeLine{10052 \textcolor{preprocessor}{\#  define CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10053 \textcolor{preprocessor}{\#  define WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10054 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10055 }
\DoxyCodeLine{10056 \textcolor{preprocessor}{\#ifdef \_\_AFXDLL}}
\DoxyCodeLine{10057 \textcolor{preprocessor}{\#include <AfxWin.h>}}
\DoxyCodeLine{10058 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10059 \textcolor{preprocessor}{\#include <windows.h>}}
\DoxyCodeLine{10060 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10061 }
\DoxyCodeLine{10062 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_NOMINMAX}}
\DoxyCodeLine{10063 \textcolor{preprocessor}{\#  undef NOMINMAX}}
\DoxyCodeLine{10064 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10065 \textcolor{preprocessor}{\#ifdef CATCH\_DEFINED\_WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10066 \textcolor{preprocessor}{\#  undef WIN32\_LEAN\_AND\_MEAN}}
\DoxyCodeLine{10067 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10068 }
\DoxyCodeLine{10069 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10070 }
\DoxyCodeLine{10071 \textcolor{comment}{// end catch\_windows\_h\_proxy.h}}
\DoxyCodeLine{10072 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{10073 }
\DoxyCodeLine{10074 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10075     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10076 }
\DoxyCodeLine{10077         \textcolor{keyword}{struct }IColourImpl \{}
\DoxyCodeLine{10078             \textcolor{keyword}{virtual} \string~IColourImpl() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10079             \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} use( Colour::Code \_colourCode ) = 0;}
\DoxyCodeLine{10080         \};}
\DoxyCodeLine{10081 }
\DoxyCodeLine{10082         \textcolor{keyword}{struct }NoColourImpl : IColourImpl \{}
\DoxyCodeLine{10083             \textcolor{keywordtype}{void} use( Colour::Code )\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{10084 }
\DoxyCodeLine{10085             \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10086                 \textcolor{keyword}{static} NoColourImpl s\_instance;}
\DoxyCodeLine{10087                 \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10088             \}}
\DoxyCodeLine{10089         \};}
\DoxyCodeLine{10090 }
\DoxyCodeLine{10091     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{10092 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10093 }
\DoxyCodeLine{10094 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_COLOUR\_NONE ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_WINDOWS ) \&\& !defined( CATCH\_CONFIG\_COLOUR\_ANSI )}}
\DoxyCodeLine{10095 \textcolor{preprocessor}{\#   ifdef CATCH\_PLATFORM\_WINDOWS}}
\DoxyCodeLine{10096 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_WINDOWS}}
\DoxyCodeLine{10097 \textcolor{preprocessor}{\#   else}}
\DoxyCodeLine{10098 \textcolor{preprocessor}{\#       define CATCH\_CONFIG\_COLOUR\_ANSI}}
\DoxyCodeLine{10099 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{10100 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10101 }
\DoxyCodeLine{10102 \textcolor{preprocessor}{\#if defined ( CATCH\_CONFIG\_COLOUR\_WINDOWS ) }}
\DoxyCodeLine{10103 }
\DoxyCodeLine{10104 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10105 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10106 }
\DoxyCodeLine{10107     \textcolor{keyword}{class }Win32ColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10108     \textcolor{keyword}{public}:}
\DoxyCodeLine{10109         Win32ColourImpl() : stdoutHandle( GetStdHandle(STD\_OUTPUT\_HANDLE) )}
\DoxyCodeLine{10110         \{}
\DoxyCodeLine{10111             CONSOLE\_SCREEN\_BUFFER\_INFO csbiInfo;}
\DoxyCodeLine{10112             GetConsoleScreenBufferInfo( stdoutHandle, \&csbiInfo );}
\DoxyCodeLine{10113             originalForegroundAttributes = csbiInfo.wAttributes \& \string~( BACKGROUND\_GREEN | BACKGROUND\_RED | BACKGROUND\_BLUE | BACKGROUND\_INTENSITY );}
\DoxyCodeLine{10114             originalBackgroundAttributes = csbiInfo.wAttributes \& \string~( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE | FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10115         \}}
\DoxyCodeLine{10116 }
\DoxyCodeLine{10117         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10118             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10119                 \textcolor{keywordflow}{case} Colour::None:      \textcolor{keywordflow}{return} setTextAttribute( originalForegroundAttributes );}
\DoxyCodeLine{10120                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10121                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED );}
\DoxyCodeLine{10122                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_GREEN );}
\DoxyCodeLine{10123                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE );}
\DoxyCodeLine{10124                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_BLUE | FOREGROUND\_GREEN );}
\DoxyCodeLine{10125                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10126                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setTextAttribute( 0 );}
\DoxyCodeLine{10127 }
\DoxyCodeLine{10128                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY );}
\DoxyCodeLine{10129                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED );}
\DoxyCodeLine{10130                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN );}
\DoxyCodeLine{10131                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_GREEN | FOREGROUND\_RED | FOREGROUND\_BLUE );}
\DoxyCodeLine{10132                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setTextAttribute( FOREGROUND\_INTENSITY | FOREGROUND\_RED | FOREGROUND\_GREEN );}
\DoxyCodeLine{10133 }
\DoxyCodeLine{10134                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10135 }
\DoxyCodeLine{10136                 \textcolor{keywordflow}{default}:}
\DoxyCodeLine{10137                     CATCH\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10138             \}}
\DoxyCodeLine{10139         \}}
\DoxyCodeLine{10140 }
\DoxyCodeLine{10141     \textcolor{keyword}{private}:}
\DoxyCodeLine{10142         \textcolor{keywordtype}{void} setTextAttribute( WORD \_textAttribute ) \{}
\DoxyCodeLine{10143             SetConsoleTextAttribute( stdoutHandle, \_textAttribute | originalBackgroundAttributes );}
\DoxyCodeLine{10144         \}}
\DoxyCodeLine{10145         HANDLE stdoutHandle;}
\DoxyCodeLine{10146         WORD originalForegroundAttributes;}
\DoxyCodeLine{10147         WORD originalBackgroundAttributes;}
\DoxyCodeLine{10148     \};}
\DoxyCodeLine{10149 }
\DoxyCodeLine{10150     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10151         \textcolor{keyword}{static} Win32ColourImpl s\_instance;}
\DoxyCodeLine{10152 }
\DoxyCodeLine{10153         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10154         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10155             ? config-\/>useColour()}
\DoxyCodeLine{10156             : UseColour::Auto;}
\DoxyCodeLine{10157         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10158             colourMode = UseColour::Yes;}
\DoxyCodeLine{10159         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10160             ? \&s\_instance}
\DoxyCodeLine{10161             : NoColourImpl::instance();}
\DoxyCodeLine{10162     \}}
\DoxyCodeLine{10163 }
\DoxyCodeLine{10164 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10165 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10166 }
\DoxyCodeLine{10167 \textcolor{preprocessor}{\#elif defined( CATCH\_CONFIG\_COLOUR\_ANSI ) }}
\DoxyCodeLine{10168 }
\DoxyCodeLine{10169 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{10170 }
\DoxyCodeLine{10171 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10172 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10173 }
\DoxyCodeLine{10174     \textcolor{comment}{// use POSIX/ ANSI console terminal codes}}
\DoxyCodeLine{10175     \textcolor{comment}{// Thanks to Adam Strzelecki for original contribution}}
\DoxyCodeLine{10176     \textcolor{comment}{// (http://github.com/nanoant)}}
\DoxyCodeLine{10177     \textcolor{comment}{// https://github.com/philsquared/Catch/pull/131}}
\DoxyCodeLine{10178     \textcolor{keyword}{class }PosixColourImpl : \textcolor{keyword}{public} IColourImpl \{}
\DoxyCodeLine{10179     \textcolor{keyword}{public}:}
\DoxyCodeLine{10180         \textcolor{keywordtype}{void} use( Colour::Code \_colourCode )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10181             \textcolor{keywordflow}{switch}( \_colourCode ) \{}
\DoxyCodeLine{10182                 \textcolor{keywordflow}{case} Colour::None:}
\DoxyCodeLine{10183                 \textcolor{keywordflow}{case} Colour::White:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0m"{}} );}
\DoxyCodeLine{10184                 \textcolor{keywordflow}{case} Colour::Red:       \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;31m"{}} );}
\DoxyCodeLine{10185                 \textcolor{keywordflow}{case} Colour::Green:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;32m"{}} );}
\DoxyCodeLine{10186                 \textcolor{keywordflow}{case} Colour::Blue:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;34m"{}} );}
\DoxyCodeLine{10187                 \textcolor{keywordflow}{case} Colour::Cyan:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;36m"{}} );}
\DoxyCodeLine{10188                 \textcolor{keywordflow}{case} Colour::Yellow:    \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;33m"{}} );}
\DoxyCodeLine{10189                 \textcolor{keywordflow}{case} Colour::Grey:      \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;30m"{}} );}
\DoxyCodeLine{10190 }
\DoxyCodeLine{10191                 \textcolor{keywordflow}{case} Colour::LightGrey:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[0;37m"{}} );}
\DoxyCodeLine{10192                 \textcolor{keywordflow}{case} Colour::BrightRed:     \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;31m"{}} );}
\DoxyCodeLine{10193                 \textcolor{keywordflow}{case} Colour::BrightGreen:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;32m"{}} );}
\DoxyCodeLine{10194                 \textcolor{keywordflow}{case} Colour::BrightWhite:   \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;37m"{}} );}
\DoxyCodeLine{10195                 \textcolor{keywordflow}{case} Colour::BrightYellow:  \textcolor{keywordflow}{return} setColour( \textcolor{stringliteral}{"{}[1;33m"{}} );}
\DoxyCodeLine{10196 }
\DoxyCodeLine{10197                 \textcolor{keywordflow}{case} Colour::Bright: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}not a colour"{}} );}
\DoxyCodeLine{10198                 \textcolor{keywordflow}{default}: CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown colour requested"{}} );}
\DoxyCodeLine{10199             \}}
\DoxyCodeLine{10200         \}}
\DoxyCodeLine{10201         \textcolor{keyword}{static} IColourImpl* instance() \{}
\DoxyCodeLine{10202             \textcolor{keyword}{static} PosixColourImpl s\_instance;}
\DoxyCodeLine{10203             \textcolor{keywordflow}{return} \&s\_instance;}
\DoxyCodeLine{10204         \}}
\DoxyCodeLine{10205 }
\DoxyCodeLine{10206     \textcolor{keyword}{private}:}
\DoxyCodeLine{10207         \textcolor{keywordtype}{void} setColour( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \_escapeCode ) \{}
\DoxyCodeLine{10208             getCurrentContext().getConfig()-\/>stream()}
\DoxyCodeLine{10209                 << \textcolor{charliteral}{'\(\backslash\)033'} << \_escapeCode;}
\DoxyCodeLine{10210         \}}
\DoxyCodeLine{10211     \};}
\DoxyCodeLine{10212 }
\DoxyCodeLine{10213     \textcolor{keywordtype}{bool} useColourOnPlatform() \{}
\DoxyCodeLine{10214         \textcolor{keywordflow}{return}}
\DoxyCodeLine{10215 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10216             !isDebuggerActive() \&\&}
\DoxyCodeLine{10217 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10218 \textcolor{preprocessor}{\#if !(defined(\_\_DJGPP\_\_) \&\& defined(\_\_STRICT\_ANSI\_\_))}}
\DoxyCodeLine{10219             isatty(STDOUT\_FILENO)}
\DoxyCodeLine{10220 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10221             \textcolor{keyword}{false}}
\DoxyCodeLine{10222 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10223             ;}
\DoxyCodeLine{10224     \}}
\DoxyCodeLine{10225     IColourImpl* platformColourInstance() \{}
\DoxyCodeLine{10226         ErrnoGuard guard;}
\DoxyCodeLine{10227         IConfigPtr config = getCurrentContext().getConfig();}
\DoxyCodeLine{10228         UseColour::YesOrNo colourMode = config}
\DoxyCodeLine{10229             ? config-\/>useColour()}
\DoxyCodeLine{10230             : UseColour::Auto;}
\DoxyCodeLine{10231         \textcolor{keywordflow}{if}( colourMode == UseColour::Auto )}
\DoxyCodeLine{10232             colourMode = useColourOnPlatform()}
\DoxyCodeLine{10233                 ? UseColour::Yes}
\DoxyCodeLine{10234                 : UseColour::No;}
\DoxyCodeLine{10235         \textcolor{keywordflow}{return} colourMode == UseColour::Yes}
\DoxyCodeLine{10236             ? PosixColourImpl::instance()}
\DoxyCodeLine{10237             : NoColourImpl::instance();}
\DoxyCodeLine{10238     \}}
\DoxyCodeLine{10239 }
\DoxyCodeLine{10240 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{10241 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10242 }
\DoxyCodeLine{10243 \textcolor{preprocessor}{\#else  }\textcolor{comment}{// not Windows or ANSI ///////////////////////////////////////////////}}
\DoxyCodeLine{10244 }
\DoxyCodeLine{10245 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10246 }
\DoxyCodeLine{10247     \textcolor{keyword}{static} IColourImpl* platformColourInstance() \{ \textcolor{keywordflow}{return} NoColourImpl::instance(); \}}
\DoxyCodeLine{10248 }
\DoxyCodeLine{10249 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10250 }
\DoxyCodeLine{10251 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Windows/ ANSI/ None}}
\DoxyCodeLine{10252 }
\DoxyCodeLine{10253 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10254 }
\DoxyCodeLine{10255     Colour::Colour( Code \_colourCode ) \{ use( \_colourCode ); \}}
\DoxyCodeLine{10256     Colour::Colour( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10257         m\_moved = other.m\_moved;}
\DoxyCodeLine{10258         other.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{10259     \}}
\DoxyCodeLine{10260     Colour\& Colour::operator=( Colour\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{10261         m\_moved = other.m\_moved;}
\DoxyCodeLine{10262         other.m\_moved  = \textcolor{keyword}{true};}
\DoxyCodeLine{10263         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{10264     \}}
\DoxyCodeLine{10265 }
\DoxyCodeLine{10266     Colour::\string~Colour()\{ \textcolor{keywordflow}{if}( !m\_moved ) use( None ); \}}
\DoxyCodeLine{10267 }
\DoxyCodeLine{10268     \textcolor{keywordtype}{void} Colour::use( Code \_colourCode ) \{}
\DoxyCodeLine{10269         \textcolor{keyword}{static} IColourImpl* impl = platformColourInstance();}
\DoxyCodeLine{10270         \textcolor{comment}{// Strictly speaking, this cannot possibly happen.}}
\DoxyCodeLine{10271         \textcolor{comment}{// However, under some conditions it does happen (see \#1626),}}
\DoxyCodeLine{10272         \textcolor{comment}{// and this change is small enough that we can let practicality}}
\DoxyCodeLine{10273         \textcolor{comment}{// triumph over purity in this case.}}
\DoxyCodeLine{10274         \textcolor{keywordflow}{if} (impl != \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10275             impl-\/>use( \_colourCode );}
\DoxyCodeLine{10276         \}}
\DoxyCodeLine{10277     \}}
\DoxyCodeLine{10278 }
\DoxyCodeLine{10279     std::ostream\& operator << ( std::ostream\& os, Colour \textcolor{keyword}{const}\& ) \{}
\DoxyCodeLine{10280         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{10281     \}}
\DoxyCodeLine{10282 }
\DoxyCodeLine{10283 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10284 }
\DoxyCodeLine{10285 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{10286 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{10287 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10288 }
\DoxyCodeLine{10289 \textcolor{comment}{// end catch\_console\_colour.cpp}}
\DoxyCodeLine{10290 \textcolor{comment}{// start catch\_context.cpp}}
\DoxyCodeLine{10291 }
\DoxyCodeLine{10292 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10293 }
\DoxyCodeLine{10294     \textcolor{keyword}{class }Context : \textcolor{keyword}{public} IMutableContext, NonCopyable \{}
\DoxyCodeLine{10295 }
\DoxyCodeLine{10296     \textcolor{keyword}{public}: \textcolor{comment}{// IContext}}
\DoxyCodeLine{10297         IResultCapture* getResultCapture()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10298             \textcolor{keywordflow}{return} m\_resultCapture;}
\DoxyCodeLine{10299         \}}
\DoxyCodeLine{10300         IRunner* getRunner()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10301             \textcolor{keywordflow}{return} m\_runner;}
\DoxyCodeLine{10302         \}}
\DoxyCodeLine{10303 }
\DoxyCodeLine{10304         IConfigPtr \textcolor{keyword}{const}\& getConfig()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{10305             \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{10306         \}}
\DoxyCodeLine{10307 }
\DoxyCodeLine{10308         \string~Context() \textcolor{keyword}{override};}
\DoxyCodeLine{10309 }
\DoxyCodeLine{10310     \textcolor{keyword}{public}: \textcolor{comment}{// IMutableContext}}
\DoxyCodeLine{10311         \textcolor{keywordtype}{void} setResultCapture( IResultCapture* resultCapture )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10312             m\_resultCapture = resultCapture;}
\DoxyCodeLine{10313         \}}
\DoxyCodeLine{10314         \textcolor{keywordtype}{void} setRunner( IRunner* runner )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10315             m\_runner = runner;}
\DoxyCodeLine{10316         \}}
\DoxyCodeLine{10317         \textcolor{keywordtype}{void} setConfig( IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{10318             m\_config = config;}
\DoxyCodeLine{10319         \}}
\DoxyCodeLine{10320 }
\DoxyCodeLine{10321         \textcolor{keyword}{friend} IMutableContext\& getCurrentMutableContext();}
\DoxyCodeLine{10322 }
\DoxyCodeLine{10323     \textcolor{keyword}{private}:}
\DoxyCodeLine{10324         IConfigPtr m\_config;}
\DoxyCodeLine{10325         IRunner* m\_runner = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10326         IResultCapture* m\_resultCapture = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10327     \};}
\DoxyCodeLine{10328 }
\DoxyCodeLine{10329     IMutableContext *IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10330 }
\DoxyCodeLine{10331     \textcolor{keywordtype}{void} IMutableContext::createContext()}
\DoxyCodeLine{10332     \{}
\DoxyCodeLine{10333         currentContext = \textcolor{keyword}{new} Context();}
\DoxyCodeLine{10334     \}}
\DoxyCodeLine{10335 }
\DoxyCodeLine{10336     \textcolor{keywordtype}{void} cleanUpContext() \{}
\DoxyCodeLine{10337         \textcolor{keyword}{delete} IMutableContext::currentContext;}
\DoxyCodeLine{10338         IMutableContext::currentContext = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10339     \}}
\DoxyCodeLine{10340     IContext::\string~IContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10341     IMutableContext::\string~IMutableContext() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10342     Context::\string~Context() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10343 }
\DoxyCodeLine{10344     SimplePcg32\& rng() \{}
\DoxyCodeLine{10345         \textcolor{keyword}{static} SimplePcg32 s\_rng;}
\DoxyCodeLine{10346         \textcolor{keywordflow}{return} s\_rng;}
\DoxyCodeLine{10347     \}}
\DoxyCodeLine{10348 }
\DoxyCodeLine{10349 \}}
\DoxyCodeLine{10350 \textcolor{comment}{// end catch\_context.cpp}}
\DoxyCodeLine{10351 \textcolor{comment}{// start catch\_debug\_console.cpp}}
\DoxyCodeLine{10352 }
\DoxyCodeLine{10353 \textcolor{comment}{// start catch\_debug\_console.h}}
\DoxyCodeLine{10354 }
\DoxyCodeLine{10355 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10356 }
\DoxyCodeLine{10357 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10358     \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text );}
\DoxyCodeLine{10359 \}}
\DoxyCodeLine{10360 }
\DoxyCodeLine{10361 \textcolor{comment}{// end catch\_debug\_console.h}}
\DoxyCodeLine{10362 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ANDROID\_LOGWRITE)}}
\DoxyCodeLine{10363 \textcolor{preprocessor}{\#include <android/log.h>}}
\DoxyCodeLine{10364 }
\DoxyCodeLine{10365     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10366         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10367             \_\_android\_log\_write( ANDROID\_LOG\_DEBUG, \textcolor{stringliteral}{"{}Catch"{}}, text.c\_str() );}
\DoxyCodeLine{10368         \}}
\DoxyCodeLine{10369     \}}
\DoxyCodeLine{10370 }
\DoxyCodeLine{10371 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_WINDOWS)}}
\DoxyCodeLine{10372 }
\DoxyCodeLine{10373     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10374         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10375             ::OutputDebugStringA( text.c\_str() );}
\DoxyCodeLine{10376         \}}
\DoxyCodeLine{10377     \}}
\DoxyCodeLine{10378 }
\DoxyCodeLine{10379 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10380 }
\DoxyCodeLine{10381     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10382         \textcolor{keywordtype}{void} writeToDebugConsole( std::string \textcolor{keyword}{const}\& text ) \{}
\DoxyCodeLine{10383             \textcolor{comment}{// !TBD: Need a version for Mac/ XCode and other IDEs}}
\DoxyCodeLine{10384             Catch::cout() << text;}
\DoxyCodeLine{10385         \}}
\DoxyCodeLine{10386     \}}
\DoxyCodeLine{10387 }
\DoxyCodeLine{10388 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10389 \textcolor{comment}{// end catch\_debug\_console.cpp}}
\DoxyCodeLine{10390 \textcolor{comment}{// start catch\_debugger.cpp}}
\DoxyCodeLine{10391 }
\DoxyCodeLine{10392 \textcolor{preprocessor}{\#if defined(CATCH\_PLATFORM\_MAC) || defined(CATCH\_PLATFORM\_IPHONE)}}
\DoxyCodeLine{10393 }
\DoxyCodeLine{10394 \textcolor{preprocessor}{\#  include <cassert>}}
\DoxyCodeLine{10395 \textcolor{preprocessor}{\#  include <sys/types.h>}}
\DoxyCodeLine{10396 \textcolor{preprocessor}{\#  include <unistd.h>}}
\DoxyCodeLine{10397 \textcolor{preprocessor}{\#  include <cstddef>}}
\DoxyCodeLine{10398 \textcolor{preprocessor}{\#  include <ostream>}}
\DoxyCodeLine{10399 }
\DoxyCodeLine{10400 \textcolor{preprocessor}{\#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10401     \textcolor{comment}{// These headers will only compile with AppleClang (XCode)}}
\DoxyCodeLine{10402     \textcolor{comment}{// For other compilers (Clang, GCC, ... ) we need to exclude them}}
\DoxyCodeLine{10403 \textcolor{preprocessor}{\#  include <sys/sysctl.h>}}
\DoxyCodeLine{10404 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10405 }
\DoxyCodeLine{10406     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10407 \textcolor{preprocessor}{        \#ifdef \_\_apple\_build\_version\_\_}}
\DoxyCodeLine{10408         \textcolor{comment}{// The following function is taken directly from the following technical note:}}
\DoxyCodeLine{10409         \textcolor{comment}{// https://developer.apple.com/library/archive/qa/qa1361/\_index.html}}
\DoxyCodeLine{10410 }
\DoxyCodeLine{10411         \textcolor{comment}{// Returns true if the current process is being debugged (either}}
\DoxyCodeLine{10412         \textcolor{comment}{// running under the debugger or has a debugger attached post facto).}}
\DoxyCodeLine{10413         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10414             \textcolor{keywordtype}{int}                 mib[4];}
\DoxyCodeLine{10415             \textcolor{keyword}{struct }kinfo\_proc   info;}
\DoxyCodeLine{10416             std::size\_t         size;}
\DoxyCodeLine{10417 }
\DoxyCodeLine{10418             \textcolor{comment}{// Initialize the flags so that, if sysctl fails for some bizarre}}
\DoxyCodeLine{10419             \textcolor{comment}{// reason, we get a predictable result.}}
\DoxyCodeLine{10420 }
\DoxyCodeLine{10421             info.kp\_proc.p\_flag = 0;}
\DoxyCodeLine{10422 }
\DoxyCodeLine{10423             \textcolor{comment}{// Initialize mib, which tells sysctl the info we want, in this case}}
\DoxyCodeLine{10424             \textcolor{comment}{// we're looking for information about a specific process ID.}}
\DoxyCodeLine{10425 }
\DoxyCodeLine{10426             mib[0] = CTL\_KERN;}
\DoxyCodeLine{10427             mib[1] = KERN\_PROC;}
\DoxyCodeLine{10428             mib[2] = KERN\_PROC\_PID;}
\DoxyCodeLine{10429             mib[3] = getpid();}
\DoxyCodeLine{10430 }
\DoxyCodeLine{10431             \textcolor{comment}{// Call sysctl.}}
\DoxyCodeLine{10432 }
\DoxyCodeLine{10433             size = \textcolor{keyword}{sizeof}(info);}
\DoxyCodeLine{10434             \textcolor{keywordflow}{if}( sysctl(mib, \textcolor{keyword}{sizeof}(mib) / \textcolor{keyword}{sizeof}(*mib), \&info, \&size, \textcolor{keyword}{nullptr}, 0) != 0 ) \{}
\DoxyCodeLine{10435                 Catch::cerr() << \textcolor{stringliteral}{"{}\(\backslash\)n** Call to sysctl failed -\/ unable to determine if debugger is active **\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{10436                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10437             \}}
\DoxyCodeLine{10438 }
\DoxyCodeLine{10439             \textcolor{comment}{// We're being debugged if the P\_TRACED flag is set.}}
\DoxyCodeLine{10440 }
\DoxyCodeLine{10441             \textcolor{keywordflow}{return} ( (info.kp\_proc.p\_flag \& P\_TRACED) != 0 );}
\DoxyCodeLine{10442         \}}
\DoxyCodeLine{10443 \textcolor{preprocessor}{        \#else}}
\DoxyCodeLine{10444         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10445             \textcolor{comment}{// We need to find another way to determine this for non-\/appleclang compilers on macOS}}
\DoxyCodeLine{10446             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10447         \}}
\DoxyCodeLine{10448 \textcolor{preprocessor}{        \#endif}}
\DoxyCodeLine{10449     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10450 }
\DoxyCodeLine{10451 \textcolor{preprocessor}{\#elif defined(CATCH\_PLATFORM\_LINUX)}}
\DoxyCodeLine{10452 \textcolor{preprocessor}{    \#include <fstream>}}
\DoxyCodeLine{10453 \textcolor{preprocessor}{    \#include <string>}}
\DoxyCodeLine{10454 }
\DoxyCodeLine{10455     \textcolor{keyword}{namespace }Catch\{}
\DoxyCodeLine{10456         \textcolor{comment}{// The standard POSIX way of detecting a debugger is to attempt to}}
\DoxyCodeLine{10457         \textcolor{comment}{// ptrace() the process, but this needs to be done from a child and not}}
\DoxyCodeLine{10458         \textcolor{comment}{// this process itself to still allow attaching to this process later}}
\DoxyCodeLine{10459         \textcolor{comment}{// if wanted, so is rather heavy. Under Linux we have the PID of the}}
\DoxyCodeLine{10460         \textcolor{comment}{// "{}debugger"{} (which doesn't need to be gdb, of course, it could also}}
\DoxyCodeLine{10461         \textcolor{comment}{// be strace, for example) in /proc/\$PID/status, so just get it from}}
\DoxyCodeLine{10462         \textcolor{comment}{// there instead.}}
\DoxyCodeLine{10463         \textcolor{keywordtype}{bool} isDebuggerActive()\{}
\DoxyCodeLine{10464             \textcolor{comment}{// Libstdc++ has a bug, where std::ifstream sets errno to 0}}
\DoxyCodeLine{10465             \textcolor{comment}{// This way our users can properly assert over errno values}}
\DoxyCodeLine{10466             ErrnoGuard guard;}
\DoxyCodeLine{10467             std::ifstream in(\textcolor{stringliteral}{"{}/proc/self/status"{}});}
\DoxyCodeLine{10468             \textcolor{keywordflow}{for}( std::string line; std::getline(in, line); ) \{}
\DoxyCodeLine{10469                 \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} PREFIX\_LEN = 11;}
\DoxyCodeLine{10470                 \textcolor{keywordflow}{if}( line.compare(0, PREFIX\_LEN, \textcolor{stringliteral}{"{}TracerPid:\(\backslash\)t"{}}) == 0 ) \{}
\DoxyCodeLine{10471                     \textcolor{comment}{// We're traced if the PID is not 0 and no other PID starts}}
\DoxyCodeLine{10472                     \textcolor{comment}{// with 0 digit, so it's enough to check for just a single}}
\DoxyCodeLine{10473                     \textcolor{comment}{// character.}}
\DoxyCodeLine{10474                     \textcolor{keywordflow}{return} line.length() > PREFIX\_LEN \&\& line[PREFIX\_LEN] != \textcolor{charliteral}{'0'};}
\DoxyCodeLine{10475                 \}}
\DoxyCodeLine{10476             \}}
\DoxyCodeLine{10477 }
\DoxyCodeLine{10478             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{10479         \}}
\DoxyCodeLine{10480     \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10481 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER)}}
\DoxyCodeLine{10482     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10483     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10484         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10485             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10486         \}}
\DoxyCodeLine{10487     \}}
\DoxyCodeLine{10488 \textcolor{preprocessor}{\#elif defined(\_\_MINGW32\_\_)}}
\DoxyCodeLine{10489     \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \_\_declspec(dllimport) \textcolor{keywordtype}{int} \_\_stdcall IsDebuggerPresent();}
\DoxyCodeLine{10490     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10491         \textcolor{keywordtype}{bool} isDebuggerActive() \{}
\DoxyCodeLine{10492             \textcolor{keywordflow}{return} IsDebuggerPresent() != 0;}
\DoxyCodeLine{10493         \}}
\DoxyCodeLine{10494     \}}
\DoxyCodeLine{10495 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10496     \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10497        \textcolor{keywordtype}{bool} isDebuggerActive() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{10498     \}}
\DoxyCodeLine{10499 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// Platform}}
\DoxyCodeLine{10500 \textcolor{comment}{// end catch\_debugger.cpp}}
\DoxyCodeLine{10501 \textcolor{comment}{// start catch\_decomposer.cpp}}
\DoxyCodeLine{10502 }
\DoxyCodeLine{10503 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10504 }
\DoxyCodeLine{10505     ITransientExpression::\string~ITransientExpression() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10506 }
\DoxyCodeLine{10507     \textcolor{keywordtype}{void} formatReconstructedExpression( std::ostream \&os, std::string \textcolor{keyword}{const}\& lhs, StringRef op, std::string \textcolor{keyword}{const}\& rhs ) \{}
\DoxyCodeLine{10508         \textcolor{keywordflow}{if}( lhs.size() + rhs.size() < 40 \&\&}
\DoxyCodeLine{10509                 lhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos \&\&}
\DoxyCodeLine{10510                 rhs.find(\textcolor{charliteral}{'\(\backslash\)n'}) == std::string::npos )}
\DoxyCodeLine{10511             os << lhs << \textcolor{stringliteral}{"{} "{}} << op << \textcolor{stringliteral}{"{} "{}} << rhs;}
\DoxyCodeLine{10512         \textcolor{keywordflow}{else}}
\DoxyCodeLine{10513             os << lhs << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << op << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << rhs;}
\DoxyCodeLine{10514     \}}
\DoxyCodeLine{10515 \}}
\DoxyCodeLine{10516 \textcolor{comment}{// end catch\_decomposer.cpp}}
\DoxyCodeLine{10517 \textcolor{comment}{// start catch\_enforce.cpp}}
\DoxyCodeLine{10518 }
\DoxyCodeLine{10519 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{10520 }
\DoxyCodeLine{10521 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10522 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS) \&\& !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS\_CUSTOM\_HANDLER)}}
\DoxyCodeLine{10523     [[noreturn]]}
\DoxyCodeLine{10524     \textcolor{keywordtype}{void} throw\_exception(std::exception \textcolor{keyword}{const}\& e) \{}
\DoxyCodeLine{10525         Catch::cerr() << \textcolor{stringliteral}{"{}Catch will terminate because it needed to throw an exception.\(\backslash\)n"{}}}
\DoxyCodeLine{10526                       << \textcolor{stringliteral}{"{}The message was: "{}} << e.what() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{10527         std::terminate();}
\DoxyCodeLine{10528     \}}
\DoxyCodeLine{10529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10530 }
\DoxyCodeLine{10531     [[noreturn]]}
\DoxyCodeLine{10532     \textcolor{keywordtype}{void} throw\_logic\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10533         throw\_exception(std::logic\_error(msg));}
\DoxyCodeLine{10534     \}}
\DoxyCodeLine{10535 }
\DoxyCodeLine{10536     [[noreturn]]}
\DoxyCodeLine{10537     \textcolor{keywordtype}{void} throw\_domain\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10538         throw\_exception(std::domain\_error(msg));}
\DoxyCodeLine{10539     \}}
\DoxyCodeLine{10540 }
\DoxyCodeLine{10541     [[noreturn]]}
\DoxyCodeLine{10542     \textcolor{keywordtype}{void} throw\_runtime\_error(std::string \textcolor{keyword}{const}\& msg) \{}
\DoxyCodeLine{10543         throw\_exception(std::runtime\_error(msg));}
\DoxyCodeLine{10544     \}}
\DoxyCodeLine{10545 }
\DoxyCodeLine{10546 \} \textcolor{comment}{// namespace Catch;}}
\DoxyCodeLine{10547 \textcolor{comment}{// end catch\_enforce.cpp}}
\DoxyCodeLine{10548 \textcolor{comment}{// start catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10549 \textcolor{comment}{// start catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10550 }
\DoxyCodeLine{10551 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10552 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10553 }
\DoxyCodeLine{10554 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10555 }
\DoxyCodeLine{10556     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10557 }
\DoxyCodeLine{10558         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values );}
\DoxyCodeLine{10559 }
\DoxyCodeLine{10560         \textcolor{keyword}{class }EnumValuesRegistry : \textcolor{keyword}{public} IMutableEnumValuesRegistry \{}
\DoxyCodeLine{10561 }
\DoxyCodeLine{10562             std::vector<std::unique\_ptr<EnumInfo>> m\_enumInfos;}
\DoxyCodeLine{10563 }
\DoxyCodeLine{10564             EnumInfo \textcolor{keyword}{const}\& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> \textcolor{keyword}{const}\& values) \textcolor{keyword}{override};}
\DoxyCodeLine{10565         \};}
\DoxyCodeLine{10566 }
\DoxyCodeLine{10567         std::vector<StringRef> parseEnums( StringRef enums );}
\DoxyCodeLine{10568 }
\DoxyCodeLine{10569     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10570 }
\DoxyCodeLine{10571 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10572 }
\DoxyCodeLine{10573 \textcolor{comment}{// end catch\_enum\_values\_registry.h}}
\DoxyCodeLine{10574 }
\DoxyCodeLine{10575 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{10576 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{10577 }
\DoxyCodeLine{10578 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10579 }
\DoxyCodeLine{10580     IMutableEnumValuesRegistry::\string~IMutableEnumValuesRegistry() \{\}}
\DoxyCodeLine{10581 }
\DoxyCodeLine{10582     \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{10583 }
\DoxyCodeLine{10584         \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10585             \textcolor{comment}{// Extracts the actual name part of an enum instance}}
\DoxyCodeLine{10586             \textcolor{comment}{// In other words, it returns the Blue part of Bikeshed::Colour::Blue}}
\DoxyCodeLine{10587             StringRef extractInstanceName(StringRef enumInstance) \{}
\DoxyCodeLine{10588                 \textcolor{comment}{// Find last occurrence of "{}:"{}}}
\DoxyCodeLine{10589                 \textcolor{keywordtype}{size\_t} name\_start = enumInstance.size();}
\DoxyCodeLine{10590                 \textcolor{keywordflow}{while} (name\_start > 0 \&\& enumInstance[name\_start -\/ 1] != \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{10591                     -\/-\/name\_start;}
\DoxyCodeLine{10592                 \}}
\DoxyCodeLine{10593                 \textcolor{keywordflow}{return} enumInstance.substr(name\_start, enumInstance.size() -\/ name\_start);}
\DoxyCodeLine{10594             \}}
\DoxyCodeLine{10595         \}}
\DoxyCodeLine{10596 }
\DoxyCodeLine{10597         std::vector<StringRef> parseEnums( StringRef enums ) \{}
\DoxyCodeLine{10598             \textcolor{keyword}{auto} enumValues = splitStringRef( enums, \textcolor{charliteral}{','} );}
\DoxyCodeLine{10599             std::vector<StringRef> parsed;}
\DoxyCodeLine{10600             parsed.reserve( enumValues.size() );}
\DoxyCodeLine{10601             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& enumValue : enumValues ) \{}
\DoxyCodeLine{10602                 parsed.push\_back(trim(extractInstanceName(enumValue)));}
\DoxyCodeLine{10603             \}}
\DoxyCodeLine{10604             \textcolor{keywordflow}{return} parsed;}
\DoxyCodeLine{10605         \}}
\DoxyCodeLine{10606 }
\DoxyCodeLine{10607         EnumInfo::\string~EnumInfo() \{\}}
\DoxyCodeLine{10608 }
\DoxyCodeLine{10609         StringRef EnumInfo::lookup( \textcolor{keywordtype}{int} value )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10610             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& valueToName : m\_values ) \{}
\DoxyCodeLine{10611                 \textcolor{keywordflow}{if}( valueToName.first == value )}
\DoxyCodeLine{10612                     \textcolor{keywordflow}{return} valueToName.second;}
\DoxyCodeLine{10613             \}}
\DoxyCodeLine{10614             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}\{** unexpected enum value **\}"{}}\_sr;}
\DoxyCodeLine{10615         \}}
\DoxyCodeLine{10616 }
\DoxyCodeLine{10617         std::unique\_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10618             std::unique\_ptr<EnumInfo> enumInfo( \textcolor{keyword}{new} EnumInfo );}
\DoxyCodeLine{10619             enumInfo-\/>m\_name = enumName;}
\DoxyCodeLine{10620             enumInfo-\/>m\_values.reserve( values.size() );}
\DoxyCodeLine{10621 }
\DoxyCodeLine{10622             \textcolor{keyword}{const} \textcolor{keyword}{auto} valueNames = Catch::Detail::parseEnums( allValueNames );}
\DoxyCodeLine{10623             assert( valueNames.size() == values.size() );}
\DoxyCodeLine{10624             std::size\_t i = 0;}
\DoxyCodeLine{10625             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} value : values )}
\DoxyCodeLine{10626                 enumInfo-\/>m\_values.emplace\_back(value, valueNames[i++]);}
\DoxyCodeLine{10627 }
\DoxyCodeLine{10628             \textcolor{keywordflow}{return} enumInfo;}
\DoxyCodeLine{10629         \}}
\DoxyCodeLine{10630 }
\DoxyCodeLine{10631         EnumInfo \textcolor{keyword}{const}\& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> \textcolor{keyword}{const}\& values ) \{}
\DoxyCodeLine{10632             m\_enumInfos.push\_back(makeEnumInfo(enumName, allValueNames, values));}
\DoxyCodeLine{10633             \textcolor{keywordflow}{return} *m\_enumInfos.back();}
\DoxyCodeLine{10634         \}}
\DoxyCodeLine{10635 }
\DoxyCodeLine{10636     \} \textcolor{comment}{// Detail}}
\DoxyCodeLine{10637 \} \textcolor{comment}{// Catch}}
\DoxyCodeLine{10638 }
\DoxyCodeLine{10639 \textcolor{comment}{// end catch\_enum\_values\_registry.cpp}}
\DoxyCodeLine{10640 \textcolor{comment}{// start catch\_errno\_guard.cpp}}
\DoxyCodeLine{10641 }
\DoxyCodeLine{10642 \textcolor{preprocessor}{\#include <cerrno>}}
\DoxyCodeLine{10643 }
\DoxyCodeLine{10644 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10645         ErrnoGuard::ErrnoGuard():m\_oldErrno(errno)\{\}}
\DoxyCodeLine{10646         ErrnoGuard::\string~ErrnoGuard() \{ errno = m\_oldErrno; \}}
\DoxyCodeLine{10647 \}}
\DoxyCodeLine{10648 \textcolor{comment}{// end catch\_errno\_guard.cpp}}
\DoxyCodeLine{10649 \textcolor{comment}{// start catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10650 }
\DoxyCodeLine{10651 \textcolor{comment}{// start catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10652 }
\DoxyCodeLine{10653 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{10654 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{10655 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{10656 }
\DoxyCodeLine{10657 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10658 }
\DoxyCodeLine{10659     \textcolor{keyword}{class }ExceptionTranslatorRegistry : \textcolor{keyword}{public} IExceptionTranslatorRegistry \{}
\DoxyCodeLine{10660     \textcolor{keyword}{public}:}
\DoxyCodeLine{10661         \string~ExceptionTranslatorRegistry();}
\DoxyCodeLine{10662         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator );}
\DoxyCodeLine{10663         std::string translateActiveException() \textcolor{keyword}{const override};}
\DoxyCodeLine{10664         std::string tryTranslators() \textcolor{keyword}{const};}
\DoxyCodeLine{10665 }
\DoxyCodeLine{10666     \textcolor{keyword}{private}:}
\DoxyCodeLine{10667         std::vector<std::unique\_ptr<IExceptionTranslator const>> m\_translators;}
\DoxyCodeLine{10668     \};}
\DoxyCodeLine{10669 \}}
\DoxyCodeLine{10670 }
\DoxyCodeLine{10671 \textcolor{comment}{// end catch\_exception\_translator\_registry.h}}
\DoxyCodeLine{10672 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10673 \textcolor{preprocessor}{\#import "{}Foundation/Foundation.h"{}}}
\DoxyCodeLine{10674 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10675 }
\DoxyCodeLine{10676 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10677 }
\DoxyCodeLine{10678     ExceptionTranslatorRegistry::\string~ExceptionTranslatorRegistry() \{}
\DoxyCodeLine{10679     \}}
\DoxyCodeLine{10680 }
\DoxyCodeLine{10681     \textcolor{keywordtype}{void} ExceptionTranslatorRegistry::registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator ) \{}
\DoxyCodeLine{10682         m\_translators.push\_back( std::unique\_ptr<const IExceptionTranslator>( translator ) );}
\DoxyCodeLine{10683     \}}
\DoxyCodeLine{10684 }
\DoxyCodeLine{10685 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{10686     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10687         \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{10688 \textcolor{preprocessor}{\#ifdef \_\_OBJC\_\_}}
\DoxyCodeLine{10689             \textcolor{comment}{// In Objective-\/C try objective-\/c exceptions first}}
\DoxyCodeLine{10690             \textcolor{keywordflow}{@try} \{}
\DoxyCodeLine{10691                 \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10692             \}}
\DoxyCodeLine{10693             \textcolor{keywordflow}{@catch} (NSException *exception) \{}
\DoxyCodeLine{10694                 \textcolor{keywordflow}{return} Catch::Detail::stringify( [exception description] );}
\DoxyCodeLine{10695             \}}
\DoxyCodeLine{10696 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{10697             \textcolor{comment}{// Compiling a mixed mode project with MSVC means that CLR}}
\DoxyCodeLine{10698             \textcolor{comment}{// exceptions will be caught in (...) as well. However, these}}
\DoxyCodeLine{10699             \textcolor{comment}{// do not fill-\/in std::current\_exception and thus lead to crash}}
\DoxyCodeLine{10700             \textcolor{comment}{// when attempting rethrow.}}
\DoxyCodeLine{10701             \textcolor{comment}{// /EHa switch also causes structured exceptions to be caught}}
\DoxyCodeLine{10702             \textcolor{comment}{// here, but they fill-\/in current\_exception properly, so}}
\DoxyCodeLine{10703             \textcolor{comment}{// at worst the output should be a little weird, instead of}}
\DoxyCodeLine{10704             \textcolor{comment}{// causing a crash.}}
\DoxyCodeLine{10705             \textcolor{keywordflow}{if} (std::current\_exception() == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{10706                 \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Non C++ exception. Possibly a CLR exception."{}};}
\DoxyCodeLine{10707             \}}
\DoxyCodeLine{10708             \textcolor{keywordflow}{return} tryTranslators();}
\DoxyCodeLine{10709 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10710         \}}
\DoxyCodeLine{10711         \textcolor{keywordflow}{catch}( TestFailureException\& ) \{}
\DoxyCodeLine{10712             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10713         \}}
\DoxyCodeLine{10714         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{10715             \textcolor{keywordflow}{return} ex.what();}
\DoxyCodeLine{10716         \}}
\DoxyCodeLine{10717         \textcolor{keywordflow}{catch}( std::string\& msg ) \{}
\DoxyCodeLine{10718             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10719         \}}
\DoxyCodeLine{10720         \textcolor{keywordflow}{catch}( \textcolor{keyword}{const} \textcolor{keywordtype}{char}* msg ) \{}
\DoxyCodeLine{10721             \textcolor{keywordflow}{return} msg;}
\DoxyCodeLine{10722         \}}
\DoxyCodeLine{10723         \textcolor{keywordflow}{catch}(...) \{}
\DoxyCodeLine{10724             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Unknown exception"{}};}
\DoxyCodeLine{10725         \}}
\DoxyCodeLine{10726     \}}
\DoxyCodeLine{10727 }
\DoxyCodeLine{10728     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10729         \textcolor{keywordflow}{if} (m\_translators.empty()) \{}
\DoxyCodeLine{10730             std::rethrow\_exception(std::current\_exception());}
\DoxyCodeLine{10731         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{10732             \textcolor{keywordflow}{return} m\_translators[0]-\/>translate(m\_translators.begin() + 1, m\_translators.end());}
\DoxyCodeLine{10733         \}}
\DoxyCodeLine{10734     \}}
\DoxyCodeLine{10735 }
\DoxyCodeLine{10736 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \string^\string^ Exceptions are enabled // Exceptions are disabled vv}}
\DoxyCodeLine{10737     std::string ExceptionTranslatorRegistry::translateActiveException()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10738         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to translate active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10739     \}}
\DoxyCodeLine{10740 }
\DoxyCodeLine{10741     std::string ExceptionTranslatorRegistry::tryTranslators()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{10742         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to use exception translators under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{10743     \}}
\DoxyCodeLine{10744 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10745 }
\DoxyCodeLine{10746 \}}
\DoxyCodeLine{10747 \textcolor{comment}{// end catch\_exception\_translator\_registry.cpp}}
\DoxyCodeLine{10748 \textcolor{comment}{// start catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10749 }
\DoxyCodeLine{10750 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{10751 }
\DoxyCodeLine{10752 \textcolor{preprocessor}{\#if !defined( CATCH\_CONFIG\_WINDOWS\_SEH ) \&\& !defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10753 }
\DoxyCodeLine{10754 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10755 }
\DoxyCodeLine{10756     \textcolor{comment}{// If neither SEH nor signal handling is required, the handler impls}}
\DoxyCodeLine{10757     \textcolor{comment}{// do not have to do anything, and can be empty.}}
\DoxyCodeLine{10758     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{\}}
\DoxyCodeLine{10759     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{\}}
\DoxyCodeLine{10760     FatalConditionHandler::FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10761     FatalConditionHandler::\string~FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10762 }
\DoxyCodeLine{10763 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10764 }
\DoxyCodeLine{10765 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// !CATCH\_CONFIG\_WINDOWS\_SEH \&\& !CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10766 }
\DoxyCodeLine{10767 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) \&\& defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10768 \textcolor{preprocessor}{\#error "{}Inconsistent configuration: Windows' SEH handling and POSIX signals cannot be enabled at the same time"{}}}
\DoxyCodeLine{10769 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH \&\& CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10770 }
\DoxyCodeLine{10771 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH ) || defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10772 }
\DoxyCodeLine{10773 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{10775     \textcolor{keywordtype}{void} reportFatal( \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} message ) \{}
\DoxyCodeLine{10776         Catch::getCurrentContext().getResultCapture()-\/>handleFatalErrorCondition( message );}
\DoxyCodeLine{10777     \}}
\DoxyCodeLine{10778 }
\DoxyCodeLine{10782     \textcolor{keyword}{constexpr} std::size\_t minStackSizeForErrors = 32 * 1024;}
\DoxyCodeLine{10783 \} \textcolor{comment}{// end unnamed namespace}}
\DoxyCodeLine{10784 }
\DoxyCodeLine{10785 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH || CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10786 }
\DoxyCodeLine{10787 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_WINDOWS\_SEH )}}
\DoxyCodeLine{10788 }
\DoxyCodeLine{10789 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10790 }
\DoxyCodeLine{10791     \textcolor{keyword}{struct }SignalDefs \{ DWORD id; \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name; \};}
\DoxyCodeLine{10792 }
\DoxyCodeLine{10793     \textcolor{comment}{// There is no 1-\/1 mapping between signals and windows exceptions.}}
\DoxyCodeLine{10794     \textcolor{comment}{// Windows can easily distinguish between SO and SigSegV,}}
\DoxyCodeLine{10795     \textcolor{comment}{// but SigInt, SigTerm, etc are handled differently.}}
\DoxyCodeLine{10796     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10797         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ILLEGAL\_INSTRUCTION),  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10798         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_STACK\_OVERFLOW), \textcolor{stringliteral}{"{}SIGSEGV -\/ Stack overflow"{}} \},}
\DoxyCodeLine{10799         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_ACCESS\_VIOLATION), \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10800         \{ \textcolor{keyword}{static\_cast<}DWORD\textcolor{keyword}{>}(EXCEPTION\_INT\_DIVIDE\_BY\_ZERO), \textcolor{stringliteral}{"{}Divide by zero error"{}} \},}
\DoxyCodeLine{10801     \};}
\DoxyCodeLine{10802 }
\DoxyCodeLine{10803     \textcolor{keyword}{static} LONG CALLBACK handleVectoredException(PEXCEPTION\_POINTERS ExceptionInfo) \{}
\DoxyCodeLine{10804         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10805             \textcolor{keywordflow}{if} (ExceptionInfo-\/>ExceptionRecord-\/>ExceptionCode == def.id) \{}
\DoxyCodeLine{10806                 reportFatal(def.name);}
\DoxyCodeLine{10807             \}}
\DoxyCodeLine{10808         \}}
\DoxyCodeLine{10809         \textcolor{comment}{// If its not an exception we care about, pass it along.}}
\DoxyCodeLine{10810         \textcolor{comment}{// This stops us from eating debugger breaks etc.}}
\DoxyCodeLine{10811         \textcolor{keywordflow}{return} EXCEPTION\_CONTINUE\_SEARCH;}
\DoxyCodeLine{10812     \}}
\DoxyCodeLine{10813 }
\DoxyCodeLine{10814     \textcolor{comment}{// Since we do not support multiple instantiations, we put these}}
\DoxyCodeLine{10815     \textcolor{comment}{// into global variables and rely on cleaning them up in outlined}}
\DoxyCodeLine{10816     \textcolor{comment}{// constructors/destructors}}
\DoxyCodeLine{10817     \textcolor{keyword}{static} PVOID exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10818 }
\DoxyCodeLine{10819     \textcolor{comment}{// For MSVC, we reserve part of the stack memory for handling}}
\DoxyCodeLine{10820     \textcolor{comment}{// memory overflow structured exception.}}
\DoxyCodeLine{10821     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10822         ULONG guaranteeSize = \textcolor{keyword}{static\_cast<}ULONG\textcolor{keyword}{>}(minStackSizeForErrors);}
\DoxyCodeLine{10823         \textcolor{keywordflow}{if} (!SetThreadStackGuarantee(\&guaranteeSize)) \{}
\DoxyCodeLine{10824             \textcolor{comment}{// We do not want to fully error out, because needing}}
\DoxyCodeLine{10825             \textcolor{comment}{// the stack reserve should be rare enough anyway.}}
\DoxyCodeLine{10826             Catch::cerr()}
\DoxyCodeLine{10827                 << \textcolor{stringliteral}{"{}Failed to reserve piece of stack."{}}}
\DoxyCodeLine{10828                 << \textcolor{stringliteral}{"{} Stack overflows will not be reported successfully."{}};}
\DoxyCodeLine{10829         \}}
\DoxyCodeLine{10830     \}}
\DoxyCodeLine{10831 }
\DoxyCodeLine{10832     \textcolor{comment}{// We do not attempt to unset the stack guarantee, because}}
\DoxyCodeLine{10833     \textcolor{comment}{// Windows does not support lowering the stack size guarantee.}}
\DoxyCodeLine{10834     FatalConditionHandler::\string~FatalConditionHandler() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10835 }
\DoxyCodeLine{10836     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{}
\DoxyCodeLine{10837         \textcolor{comment}{// Register as first handler in current chain}}
\DoxyCodeLine{10838         exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);}
\DoxyCodeLine{10839         \textcolor{keywordflow}{if} (!exceptionHandlerHandle) \{}
\DoxyCodeLine{10840             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not register vectored exception handler"{}});}
\DoxyCodeLine{10841         \}}
\DoxyCodeLine{10842     \}}
\DoxyCodeLine{10843 }
\DoxyCodeLine{10844     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{}
\DoxyCodeLine{10845         \textcolor{keywordflow}{if} (!RemoveVectoredExceptionHandler(exceptionHandlerHandle)) \{}
\DoxyCodeLine{10846             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not unregister vectored exception handler"{}});}
\DoxyCodeLine{10847         \}}
\DoxyCodeLine{10848         exceptionHandlerHandle = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10849     \}}
\DoxyCodeLine{10850 }
\DoxyCodeLine{10851 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10852 }
\DoxyCodeLine{10853 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_WINDOWS\_SEH}}
\DoxyCodeLine{10854 }
\DoxyCodeLine{10855 \textcolor{preprocessor}{\#if defined( CATCH\_CONFIG\_POSIX\_SIGNALS )}}
\DoxyCodeLine{10856 }
\DoxyCodeLine{10857 \textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{10858 }
\DoxyCodeLine{10859 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10860 }
\DoxyCodeLine{10861     \textcolor{keyword}{struct }SignalDefs \{}
\DoxyCodeLine{10862         \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{10863         \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name;}
\DoxyCodeLine{10864     \};}
\DoxyCodeLine{10865 }
\DoxyCodeLine{10866     \textcolor{keyword}{static} SignalDefs signalDefs[] = \{}
\DoxyCodeLine{10867         \{ SIGINT,  \textcolor{stringliteral}{"{}SIGINT -\/ Terminal interrupt signal"{}} \},}
\DoxyCodeLine{10868         \{ SIGILL,  \textcolor{stringliteral}{"{}SIGILL -\/ Illegal instruction signal"{}} \},}
\DoxyCodeLine{10869         \{ SIGFPE,  \textcolor{stringliteral}{"{}SIGFPE -\/ Floating point error signal"{}} \},}
\DoxyCodeLine{10870         \{ SIGSEGV, \textcolor{stringliteral}{"{}SIGSEGV -\/ Segmentation violation signal"{}} \},}
\DoxyCodeLine{10871         \{ SIGTERM, \textcolor{stringliteral}{"{}SIGTERM -\/ Termination request signal"{}} \},}
\DoxyCodeLine{10872         \{ SIGABRT, \textcolor{stringliteral}{"{}SIGABRT -\/ Abort (abnormal termination) signal"{}} \}}
\DoxyCodeLine{10873     \};}
\DoxyCodeLine{10874 }
\DoxyCodeLine{10875 \textcolor{comment}{// Older GCCs trigger -\/Wmissing-\/field-\/initializers for T foo = \{\}}}
\DoxyCodeLine{10876 \textcolor{comment}{// which is zero initialization, but not explicit. We want to avoid}}
\DoxyCodeLine{10877 \textcolor{comment}{// that.}}
\DoxyCodeLine{10878 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10879 \textcolor{preprocessor}{\#    pragma GCC diagnostic push}}
\DoxyCodeLine{10880 \textcolor{preprocessor}{\#    pragma GCC diagnostic ignored "{}-\/Wmissing-\/field-\/initializers"{}}}
\DoxyCodeLine{10881 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10882 }
\DoxyCodeLine{10883     \textcolor{keyword}{static} \textcolor{keywordtype}{char}* altStackMem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10884     \textcolor{keyword}{static} std::size\_t altStackSize = 0;}
\DoxyCodeLine{10885     \textcolor{keyword}{static} stack\_t oldSigStack\{\};}
\DoxyCodeLine{10886     \textcolor{keyword}{static} \textcolor{keyword}{struct }sigaction oldSigActions[sizeof(signalDefs) / sizeof(SignalDefs)]\{\};}
\DoxyCodeLine{10887 }
\DoxyCodeLine{10888     \textcolor{keyword}{static} \textcolor{keywordtype}{void} restorePreviousSignalHandlers() \{}
\DoxyCodeLine{10889         \textcolor{comment}{// We set signal handlers back to the previous ones. Hopefully}}
\DoxyCodeLine{10890         \textcolor{comment}{// nobody overwrote them in the meantime, and doesn't expect}}
\DoxyCodeLine{10891         \textcolor{comment}{// their signal handlers to live past ours given that they}}
\DoxyCodeLine{10892         \textcolor{comment}{// installed them after ours..}}
\DoxyCodeLine{10893         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs) / \textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{10894             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&oldSigActions[i], \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10895         \}}
\DoxyCodeLine{10896         \textcolor{comment}{// Return the old stack}}
\DoxyCodeLine{10897         sigaltstack(\&oldSigStack, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{10898     \}}
\DoxyCodeLine{10899 }
\DoxyCodeLine{10900     \textcolor{keyword}{static} \textcolor{keywordtype}{void} handleSignal( \textcolor{keywordtype}{int} sig ) \{}
\DoxyCodeLine{10901         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * name = \textcolor{stringliteral}{"{}<unknown signal>"{}};}
\DoxyCodeLine{10902         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& def : signalDefs) \{}
\DoxyCodeLine{10903             \textcolor{keywordflow}{if} (sig == def.id) \{}
\DoxyCodeLine{10904                 name = def.name;}
\DoxyCodeLine{10905                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{10906             \}}
\DoxyCodeLine{10907         \}}
\DoxyCodeLine{10908         \textcolor{comment}{// We need to restore previous signal handlers and let them do}}
\DoxyCodeLine{10909         \textcolor{comment}{// their thing, so that the users can have the debugger break}}
\DoxyCodeLine{10910         \textcolor{comment}{// when a signal is raised, and so on.}}
\DoxyCodeLine{10911         restorePreviousSignalHandlers();}
\DoxyCodeLine{10912         reportFatal( name );}
\DoxyCodeLine{10913         \textcolor{keyword}{raise}( sig );}
\DoxyCodeLine{10914     \}}
\DoxyCodeLine{10915 }
\DoxyCodeLine{10916     FatalConditionHandler::FatalConditionHandler() \{}
\DoxyCodeLine{10917         assert(!altStackMem \&\& \textcolor{stringliteral}{"{}Cannot initialize POSIX signal handler when one already exists"{}});}
\DoxyCodeLine{10918         \textcolor{keywordflow}{if} (altStackSize == 0) \{}
\DoxyCodeLine{10919             altStackSize = std::max(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(SIGSTKSZ), minStackSizeForErrors);}
\DoxyCodeLine{10920         \}}
\DoxyCodeLine{10921         altStackMem = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[altStackSize]();}
\DoxyCodeLine{10922     \}}
\DoxyCodeLine{10923 }
\DoxyCodeLine{10924     FatalConditionHandler::\string~FatalConditionHandler() \{}
\DoxyCodeLine{10925         \textcolor{keyword}{delete}[] altStackMem;}
\DoxyCodeLine{10926         \textcolor{comment}{// We signal that another instance can be constructed by zeroing}}
\DoxyCodeLine{10927         \textcolor{comment}{// out the pointer.}}
\DoxyCodeLine{10928         altStackMem = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{10929     \}}
\DoxyCodeLine{10930 }
\DoxyCodeLine{10931     \textcolor{keywordtype}{void} FatalConditionHandler::engage\_platform() \{}
\DoxyCodeLine{10932         stack\_t sigStack;}
\DoxyCodeLine{10933         sigStack.ss\_sp = altStackMem;}
\DoxyCodeLine{10934         sigStack.ss\_size = altStackSize;}
\DoxyCodeLine{10935         sigStack.ss\_flags = 0;}
\DoxyCodeLine{10936         sigaltstack(\&sigStack, \&oldSigStack);}
\DoxyCodeLine{10937         \textcolor{keyword}{struct }sigaction sa = \{ \};}
\DoxyCodeLine{10938 }
\DoxyCodeLine{10939         sa.sa\_handler = handleSignal;}
\DoxyCodeLine{10940         sa.sa\_flags = SA\_ONSTACK;}
\DoxyCodeLine{10941         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < \textcolor{keyword}{sizeof}(signalDefs)/\textcolor{keyword}{sizeof}(SignalDefs); ++i) \{}
\DoxyCodeLine{10942             sigaction(signalDefs[i].\textcolor{keywordtype}{id}, \&sa, \&oldSigActions[i]);}
\DoxyCodeLine{10943         \}}
\DoxyCodeLine{10944     \}}
\DoxyCodeLine{10945 }
\DoxyCodeLine{10946 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{10947 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{10948 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{10949 }
\DoxyCodeLine{10950     \textcolor{keywordtype}{void} FatalConditionHandler::disengage\_platform() \{}
\DoxyCodeLine{10951         restorePreviousSignalHandlers();}
\DoxyCodeLine{10952     \}}
\DoxyCodeLine{10953 }
\DoxyCodeLine{10954 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{10955 }
\DoxyCodeLine{10956 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_POSIX\_SIGNALS}}
\DoxyCodeLine{10957 \textcolor{comment}{// end catch\_fatal\_condition.cpp}}
\DoxyCodeLine{10958 \textcolor{comment}{// start catch\_generators.cpp}}
\DoxyCodeLine{10959 }
\DoxyCodeLine{10960 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{10961 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{10962 }
\DoxyCodeLine{10963 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10964 }
\DoxyCodeLine{10965 IGeneratorTracker::\string~IGeneratorTracker() \{\}}
\DoxyCodeLine{10966 }
\DoxyCodeLine{10967 \textcolor{keyword}{const} \textcolor{keywordtype}{char}* GeneratorException::what() const noexcept \{}
\DoxyCodeLine{10968     \textcolor{keywordflow}{return} m\_msg;}
\DoxyCodeLine{10969 \}}
\DoxyCodeLine{10970 }
\DoxyCodeLine{10971 \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{10972 }
\DoxyCodeLine{10973     GeneratorUntypedBase::\string~GeneratorUntypedBase() \{\}}
\DoxyCodeLine{10974 }
\DoxyCodeLine{10975     \textcolor{keyword}{auto} acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{10976         \textcolor{keywordflow}{return} getResultCapture().acquireGeneratorTracker( generatorName, lineInfo );}
\DoxyCodeLine{10977     \}}
\DoxyCodeLine{10978 }
\DoxyCodeLine{10979 \} \textcolor{comment}{// namespace Generators}}
\DoxyCodeLine{10980 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{10981 \textcolor{comment}{// end catch\_generators.cpp}}
\DoxyCodeLine{10982 \textcolor{comment}{// start catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10983 }
\DoxyCodeLine{10984 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10985     IResultCapture::\string~IResultCapture() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10986 \}}
\DoxyCodeLine{10987 \textcolor{comment}{// end catch\_interfaces\_capture.cpp}}
\DoxyCodeLine{10988 \textcolor{comment}{// start catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10989 }
\DoxyCodeLine{10990 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10991     IConfig::\string~IConfig() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10992 \}}
\DoxyCodeLine{10993 \textcolor{comment}{// end catch\_interfaces\_config.cpp}}
\DoxyCodeLine{10994 \textcolor{comment}{// start catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{10995 }
\DoxyCodeLine{10996 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{10997     IExceptionTranslator::\string~IExceptionTranslator() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10998     IExceptionTranslatorRegistry::\string~IExceptionTranslatorRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{10999 \}}
\DoxyCodeLine{11000 \textcolor{comment}{// end catch\_interfaces\_exception.cpp}}
\DoxyCodeLine{11001 \textcolor{comment}{// start catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{11002 }
\DoxyCodeLine{11003 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11004     IRegistryHub::\string~IRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11005     IMutableRegistryHub::\string~IMutableRegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11006 \}}
\DoxyCodeLine{11007 \textcolor{comment}{// end catch\_interfaces\_registry\_hub.cpp}}
\DoxyCodeLine{11008 \textcolor{comment}{// start catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{11009 }
\DoxyCodeLine{11010 \textcolor{comment}{// start catch\_reporter\_listening.h}}
\DoxyCodeLine{11011 }
\DoxyCodeLine{11012 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11013 }
\DoxyCodeLine{11014     \textcolor{keyword}{class }ListeningReporter : \textcolor{keyword}{public} IStreamingReporter \{}
\DoxyCodeLine{11015         \textcolor{keyword}{using} Reporters = std::vector<IStreamingReporterPtr>;}
\DoxyCodeLine{11016         Reporters m\_listeners;}
\DoxyCodeLine{11017         IStreamingReporterPtr m\_reporter = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{11018         ReporterPreferences m\_preferences;}
\DoxyCodeLine{11019 }
\DoxyCodeLine{11020     \textcolor{keyword}{public}:}
\DoxyCodeLine{11021         ListeningReporter();}
\DoxyCodeLine{11022 }
\DoxyCodeLine{11023         \textcolor{keywordtype}{void} addListener( IStreamingReporterPtr\&\& listener );}
\DoxyCodeLine{11024         \textcolor{keywordtype}{void} addReporter( IStreamingReporterPtr\&\& reporter );}
\DoxyCodeLine{11025 }
\DoxyCodeLine{11026     \textcolor{keyword}{public}: \textcolor{comment}{// IStreamingReporter}}
\DoxyCodeLine{11027 }
\DoxyCodeLine{11028         ReporterPreferences getPreferences() \textcolor{keyword}{const override};}
\DoxyCodeLine{11029 }
\DoxyCodeLine{11030         \textcolor{keywordtype}{void} noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \textcolor{keyword}{override};}
\DoxyCodeLine{11031 }
\DoxyCodeLine{11032         \textcolor{keywordtype}{void} reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg) \textcolor{keyword}{override};}
\DoxyCodeLine{11033 }
\DoxyCodeLine{11034         \textcolor{keyword}{static} std::set<Verbosity> getSupportedVerbosities();}
\DoxyCodeLine{11035 }
\DoxyCodeLine{11036 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{11037         \textcolor{keywordtype}{void} benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \textcolor{keyword}{override};}
\DoxyCodeLine{11038         \textcolor{keywordtype}{void} benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11039         \textcolor{keywordtype}{void} benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11040         \textcolor{keywordtype}{void} benchmarkFailed(std::string \textcolor{keyword}{const}\&) \textcolor{keyword}{override};}
\DoxyCodeLine{11041 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{11042 }
\DoxyCodeLine{11043         \textcolor{keywordtype}{void} testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11044         \textcolor{keywordtype}{void} testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11045         \textcolor{keywordtype}{void} testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11046         \textcolor{keywordtype}{void} sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11047         \textcolor{keywordtype}{void} assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11048 }
\DoxyCodeLine{11049         \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{11050         \textcolor{keywordtype}{bool} assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11051         \textcolor{keywordtype}{void} sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11052         \textcolor{keywordtype}{void} testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11053         \textcolor{keywordtype}{void} testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11054         \textcolor{keywordtype}{void} testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \textcolor{keyword}{override};}
\DoxyCodeLine{11055 }
\DoxyCodeLine{11056         \textcolor{keywordtype}{void} skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \textcolor{keyword}{override};}
\DoxyCodeLine{11057         \textcolor{keywordtype}{bool} isMulti() \textcolor{keyword}{const override};}
\DoxyCodeLine{11058 }
\DoxyCodeLine{11059     \};}
\DoxyCodeLine{11060 }
\DoxyCodeLine{11061 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11062 }
\DoxyCodeLine{11063 \textcolor{comment}{// end catch\_reporter\_listening.h}}
\DoxyCodeLine{11064 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11065 }
\DoxyCodeLine{11066     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig )}
\DoxyCodeLine{11067     :   m\_stream( \&\_fullConfig-\/>stream() ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11068 }
\DoxyCodeLine{11069     ReporterConfig::ReporterConfig( IConfigPtr \textcolor{keyword}{const}\& \_fullConfig, std::ostream\& \_stream )}
\DoxyCodeLine{11070     :   m\_stream( \&\_stream ), m\_fullConfig( \_fullConfig ) \{\}}
\DoxyCodeLine{11071 }
\DoxyCodeLine{11072     std::ostream\& ReporterConfig::stream()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} *m\_stream; \}}
\DoxyCodeLine{11073     IConfigPtr ReporterConfig::fullConfig()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_fullConfig; \}}
\DoxyCodeLine{11074 }
\DoxyCodeLine{11075     TestRunInfo::TestRunInfo( std::string \textcolor{keyword}{const}\& \_name ) : name( \_name ) \{\}}
\DoxyCodeLine{11076 }
\DoxyCodeLine{11077     GroupInfo::GroupInfo(  std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{11078                            std::size\_t \_groupIndex,}
\DoxyCodeLine{11079                            std::size\_t \_groupsCount )}
\DoxyCodeLine{11080     :   name( \_name ),}
\DoxyCodeLine{11081         groupIndex( \_groupIndex ),}
\DoxyCodeLine{11082         groupsCounts( \_groupsCount )}
\DoxyCodeLine{11083     \{\}}
\DoxyCodeLine{11084 }
\DoxyCodeLine{11085      AssertionStats::AssertionStats( AssertionResult \textcolor{keyword}{const}\& \_assertionResult,}
\DoxyCodeLine{11086                                      std::vector<MessageInfo> \textcolor{keyword}{const}\& \_infoMessages,}
\DoxyCodeLine{11087                                      Totals \textcolor{keyword}{const}\& \_totals )}
\DoxyCodeLine{11088     :   assertionResult( \_assertionResult ),}
\DoxyCodeLine{11089         infoMessages( \_infoMessages ),}
\DoxyCodeLine{11090         totals( \_totals )}
\DoxyCodeLine{11091     \{}
\DoxyCodeLine{11092         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = \_assertionResult.m\_resultData.lazyExpression.m\_transientExpression;}
\DoxyCodeLine{11093 }
\DoxyCodeLine{11094         \textcolor{keywordflow}{if}( assertionResult.hasMessage() ) \{}
\DoxyCodeLine{11095             \textcolor{comment}{// Copy message into messages list.}}
\DoxyCodeLine{11096             \textcolor{comment}{// !TBD This should have been done earlier, somewhere}}
\DoxyCodeLine{11097             MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );}
\DoxyCodeLine{11098             builder << assertionResult.getMessage();}
\DoxyCodeLine{11099             builder.m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11100 }
\DoxyCodeLine{11101             infoMessages.push\_back( builder.m\_info );}
\DoxyCodeLine{11102         \}}
\DoxyCodeLine{11103     \}}
\DoxyCodeLine{11104 }
\DoxyCodeLine{11105      AssertionStats::\string~AssertionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11106 }
\DoxyCodeLine{11107     SectionStats::SectionStats(  SectionInfo \textcolor{keyword}{const}\& \_sectionInfo,}
\DoxyCodeLine{11108                                  Counts \textcolor{keyword}{const}\& \_assertions,}
\DoxyCodeLine{11109                                  \textcolor{keywordtype}{double} \_durationInSeconds,}
\DoxyCodeLine{11110                                  \textcolor{keywordtype}{bool} \_missingAssertions )}
\DoxyCodeLine{11111     :   sectionInfo( \_sectionInfo ),}
\DoxyCodeLine{11112         assertions( \_assertions ),}
\DoxyCodeLine{11113         durationInSeconds( \_durationInSeconds ),}
\DoxyCodeLine{11114         missingAssertions( \_missingAssertions )}
\DoxyCodeLine{11115     \{\}}
\DoxyCodeLine{11116 }
\DoxyCodeLine{11117     SectionStats::\string~SectionStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11118 }
\DoxyCodeLine{11119     TestCaseStats::TestCaseStats(  TestCaseInfo \textcolor{keyword}{const}\& \_testInfo,}
\DoxyCodeLine{11120                                    Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11121                                    std::string \textcolor{keyword}{const}\& \_stdOut,}
\DoxyCodeLine{11122                                    std::string \textcolor{keyword}{const}\& \_stdErr,}
\DoxyCodeLine{11123                                    \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11124     : testInfo( \_testInfo ),}
\DoxyCodeLine{11125         totals( \_totals ),}
\DoxyCodeLine{11126         stdOut( \_stdOut ),}
\DoxyCodeLine{11127         stdErr( \_stdErr ),}
\DoxyCodeLine{11128         aborting( \_aborting )}
\DoxyCodeLine{11129     \{\}}
\DoxyCodeLine{11130 }
\DoxyCodeLine{11131     TestCaseStats::\string~TestCaseStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11132 }
\DoxyCodeLine{11133     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo,}
\DoxyCodeLine{11134                                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11135                                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11136     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11137         totals( \_totals ),}
\DoxyCodeLine{11138         aborting( \_aborting )}
\DoxyCodeLine{11139     \{\}}
\DoxyCodeLine{11140 }
\DoxyCodeLine{11141     TestGroupStats::TestGroupStats( GroupInfo \textcolor{keyword}{const}\& \_groupInfo )}
\DoxyCodeLine{11142     :   groupInfo( \_groupInfo ),}
\DoxyCodeLine{11143         aborting( false )}
\DoxyCodeLine{11144     \{\}}
\DoxyCodeLine{11145 }
\DoxyCodeLine{11146     TestGroupStats::\string~TestGroupStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11147 }
\DoxyCodeLine{11148     TestRunStats::TestRunStats(   TestRunInfo \textcolor{keyword}{const}\& \_runInfo,}
\DoxyCodeLine{11149                     Totals \textcolor{keyword}{const}\& \_totals,}
\DoxyCodeLine{11150                     \textcolor{keywordtype}{bool} \_aborting )}
\DoxyCodeLine{11151     :   runInfo( \_runInfo ),}
\DoxyCodeLine{11152         totals( \_totals ),}
\DoxyCodeLine{11153         aborting( \_aborting )}
\DoxyCodeLine{11154     \{\}}
\DoxyCodeLine{11155 }
\DoxyCodeLine{11156     TestRunStats::\string~TestRunStats() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11157 }
\DoxyCodeLine{11158     \textcolor{keywordtype}{void} IStreamingReporter::fatalErrorEncountered( StringRef ) \{\}}
\DoxyCodeLine{11159     \textcolor{keywordtype}{bool} IStreamingReporter::isMulti()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{11160 }
\DoxyCodeLine{11161     IReporterFactory::\string~IReporterFactory() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11162     IReporterRegistry::\string~IReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11163 }
\DoxyCodeLine{11164 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11165 \textcolor{comment}{// end catch\_interfaces\_reporter.cpp}}
\DoxyCodeLine{11166 \textcolor{comment}{// start catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11167 }
\DoxyCodeLine{11168 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11169     IRunner::\string~IRunner() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11170 \}}
\DoxyCodeLine{11171 \textcolor{comment}{// end catch\_interfaces\_runner.cpp}}
\DoxyCodeLine{11172 \textcolor{comment}{// start catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11173 }
\DoxyCodeLine{11174 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11175     ITestInvoker::\string~ITestInvoker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11176     ITestCaseRegistry::\string~ITestCaseRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11177 \}}
\DoxyCodeLine{11178 \textcolor{comment}{// end catch\_interfaces\_testcase.cpp}}
\DoxyCodeLine{11179 \textcolor{comment}{// start catch\_leak\_detector.cpp}}
\DoxyCodeLine{11180 }
\DoxyCodeLine{11181 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WINDOWS\_CRTDBG}}
\DoxyCodeLine{11182 \textcolor{preprocessor}{\#include <crtdbg.h>}}
\DoxyCodeLine{11183 }
\DoxyCodeLine{11184 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11185 }
\DoxyCodeLine{11186     LeakDetector::LeakDetector() \{}
\DoxyCodeLine{11187         \textcolor{keywordtype}{int} flag = \_CrtSetDbgFlag(\_CRTDBG\_REPORT\_FLAG);}
\DoxyCodeLine{11188         flag |= \_CRTDBG\_LEAK\_CHECK\_DF;}
\DoxyCodeLine{11189         flag |= \_CRTDBG\_ALLOC\_MEM\_DF;}
\DoxyCodeLine{11190         \_CrtSetDbgFlag(flag);}
\DoxyCodeLine{11191         \_CrtSetReportMode(\_CRT\_WARN, \_CRTDBG\_MODE\_FILE | \_CRTDBG\_MODE\_DEBUG);}
\DoxyCodeLine{11192         \_CrtSetReportFile(\_CRT\_WARN, \_CRTDBG\_FILE\_STDERR);}
\DoxyCodeLine{11193         \textcolor{comment}{// Change this to leaking allocation's number to break there}}
\DoxyCodeLine{11194         \_CrtSetBreakAlloc(-\/1);}
\DoxyCodeLine{11195     \}}
\DoxyCodeLine{11196 \}}
\DoxyCodeLine{11197 }
\DoxyCodeLine{11198 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11199 }
\DoxyCodeLine{11200     Catch::LeakDetector::LeakDetector() \{\}}
\DoxyCodeLine{11201 }
\DoxyCodeLine{11202 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11203 }
\DoxyCodeLine{11204 Catch::LeakDetector::\string~LeakDetector() \{}
\DoxyCodeLine{11205     Catch::cleanUp();}
\DoxyCodeLine{11206 \}}
\DoxyCodeLine{11207 \textcolor{comment}{// end catch\_leak\_detector.cpp}}
\DoxyCodeLine{11208 \textcolor{comment}{// start catch\_list.cpp}}
\DoxyCodeLine{11209 }
\DoxyCodeLine{11210 \textcolor{comment}{// start catch\_list.h}}
\DoxyCodeLine{11211 }
\DoxyCodeLine{11212 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{11213 }
\DoxyCodeLine{11214 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11215 }
\DoxyCodeLine{11216     std::size\_t listTests( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11217 }
\DoxyCodeLine{11218     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11219 }
\DoxyCodeLine{11220     \textcolor{keyword}{struct }TagInfo \{}
\DoxyCodeLine{11221         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& spelling );}
\DoxyCodeLine{11222         std::string all() \textcolor{keyword}{const};}
\DoxyCodeLine{11223 }
\DoxyCodeLine{11224         std::set<std::string> spellings;}
\DoxyCodeLine{11225         std::size\_t count = 0;}
\DoxyCodeLine{11226     \};}
\DoxyCodeLine{11227 }
\DoxyCodeLine{11228     std::size\_t listTags( Config \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11229 }
\DoxyCodeLine{11230     std::size\_t listReporters();}
\DoxyCodeLine{11231 }
\DoxyCodeLine{11232     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{11233 }
\DoxyCodeLine{11234 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11235 }
\DoxyCodeLine{11236 \textcolor{comment}{// end catch\_list.h}}
\DoxyCodeLine{11237 \textcolor{comment}{// start catch\_text.h}}
\DoxyCodeLine{11238 }
\DoxyCodeLine{11239 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11240     \textcolor{keyword}{using namespace }clara::TextFlow;}
\DoxyCodeLine{11241 \}}
\DoxyCodeLine{11242 }
\DoxyCodeLine{11243 \textcolor{comment}{// end catch\_text.h}}
\DoxyCodeLine{11244 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11245 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11246 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11247 }
\DoxyCodeLine{11248 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11249 }
\DoxyCodeLine{11250     std::size\_t listTests( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11251         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11252         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11253             Catch::cout() << \textcolor{stringliteral}{"{}Matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11254         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11255             Catch::cout() << \textcolor{stringliteral}{"{}All available test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11256         \}}
\DoxyCodeLine{11257 }
\DoxyCodeLine{11258         \textcolor{keyword}{auto} matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11259         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11260             Colour::Code colour = testCaseInfo.isHidden()}
\DoxyCodeLine{11261                 ? Colour::SecondaryText}
\DoxyCodeLine{11262                 : Colour::None;}
\DoxyCodeLine{11263             Colour colourGuard( colour );}
\DoxyCodeLine{11264 }
\DoxyCodeLine{11265             Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11266             \textcolor{keywordflow}{if}( config.verbosity() >= Verbosity::High ) \{}
\DoxyCodeLine{11267                 Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;}
\DoxyCodeLine{11268                 std::string description = testCaseInfo.description;}
\DoxyCodeLine{11269                 \textcolor{keywordflow}{if}( description.empty() )}
\DoxyCodeLine{11270                     description = \textcolor{stringliteral}{"{}(NO DESCRIPTION)"{}};}
\DoxyCodeLine{11271                 Catch::cout() << Column( description ).indent(4) << std::endl;}
\DoxyCodeLine{11272             \}}
\DoxyCodeLine{11273             \textcolor{keywordflow}{if}( !testCaseInfo.tags.empty() )}
\DoxyCodeLine{11274                 Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{11275         \}}
\DoxyCodeLine{11276 }
\DoxyCodeLine{11277         \textcolor{keywordflow}{if}( !config.hasTestFilters() )}
\DoxyCodeLine{11278             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11279         \textcolor{keywordflow}{else}}
\DoxyCodeLine{11280             Catch::cout() << pluralise( matchedTestCases.size(), \textcolor{stringliteral}{"{}matching test case"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11281         \textcolor{keywordflow}{return} matchedTestCases.size();}
\DoxyCodeLine{11282     \}}
\DoxyCodeLine{11283 }
\DoxyCodeLine{11284     std::size\_t listTestsNamesOnly( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11285         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11286         std::size\_t matchedTests = 0;}
\DoxyCodeLine{11287         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11288         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo : matchedTestCases ) \{}
\DoxyCodeLine{11289             matchedTests++;}
\DoxyCodeLine{11290             \textcolor{keywordflow}{if}( startsWith( testCaseInfo.name, \textcolor{charliteral}{'\#'} ) )}
\DoxyCodeLine{11291                Catch::cout() << \textcolor{charliteral}{'"{}'} << testCaseInfo.name << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11292             \textcolor{keywordflow}{else}}
\DoxyCodeLine{11293                Catch::cout() << testCaseInfo.name;}
\DoxyCodeLine{11294             \textcolor{keywordflow}{if} ( config.verbosity() >= Verbosity::High )}
\DoxyCodeLine{11295                 Catch::cout() << \textcolor{stringliteral}{"{}\(\backslash\)t@"{}} << testCaseInfo.lineInfo;}
\DoxyCodeLine{11296             Catch::cout() << std::endl;}
\DoxyCodeLine{11297         \}}
\DoxyCodeLine{11298         \textcolor{keywordflow}{return} matchedTests;}
\DoxyCodeLine{11299     \}}
\DoxyCodeLine{11300 }
\DoxyCodeLine{11301     \textcolor{keywordtype}{void} TagInfo::add( std::string \textcolor{keyword}{const}\& spelling ) \{}
\DoxyCodeLine{11302         ++count;}
\DoxyCodeLine{11303         spellings.insert( spelling );}
\DoxyCodeLine{11304     \}}
\DoxyCodeLine{11305 }
\DoxyCodeLine{11306     std::string TagInfo::all()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11307         \textcolor{keywordtype}{size\_t} size = 0;}
\DoxyCodeLine{11308         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11309             \textcolor{comment}{// Add 2 for the brackes}}
\DoxyCodeLine{11310             size += spelling.size() + 2;}
\DoxyCodeLine{11311         \}}
\DoxyCodeLine{11312 }
\DoxyCodeLine{11313         std::string out; out.reserve(size);}
\DoxyCodeLine{11314         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& spelling : spellings) \{}
\DoxyCodeLine{11315             out += '[';}
\DoxyCodeLine{11316             out += spelling;}
\DoxyCodeLine{11317             out += ']';}
\DoxyCodeLine{11318         \}}
\DoxyCodeLine{11319         \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{11320     \}}
\DoxyCodeLine{11321 }
\DoxyCodeLine{11322     std::size\_t listTags( Config \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11323         TestSpec \textcolor{keyword}{const}\& testSpec = config.testSpec();}
\DoxyCodeLine{11324         \textcolor{keywordflow}{if}( config.hasTestFilters() )}
\DoxyCodeLine{11325             Catch::cout() << \textcolor{stringliteral}{"{}Tags for matching test cases:\(\backslash\)n"{}};}
\DoxyCodeLine{11326         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11327             Catch::cout() << \textcolor{stringliteral}{"{}All available tags:\(\backslash\)n"{}};}
\DoxyCodeLine{11328         \}}
\DoxyCodeLine{11329 }
\DoxyCodeLine{11330         std::map<std::string, TagInfo> tagCounts;}
\DoxyCodeLine{11331 }
\DoxyCodeLine{11332         std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );}
\DoxyCodeLine{11333         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : matchedTestCases ) \{}
\DoxyCodeLine{11334             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagName : testCase.getTestCaseInfo().tags ) \{}
\DoxyCodeLine{11335                 std::string lcaseTagName = toLower( tagName );}
\DoxyCodeLine{11336                 \textcolor{keyword}{auto} countIt = tagCounts.find( lcaseTagName );}
\DoxyCodeLine{11337                 \textcolor{keywordflow}{if}( countIt == tagCounts.end() )}
\DoxyCodeLine{11338                     countIt = tagCounts.insert( std::make\_pair( lcaseTagName, TagInfo() ) ).first;}
\DoxyCodeLine{11339                 countIt-\/>second.add( tagName );}
\DoxyCodeLine{11340             \}}
\DoxyCodeLine{11341         \}}
\DoxyCodeLine{11342 }
\DoxyCodeLine{11343         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tagCount : tagCounts ) \{}
\DoxyCodeLine{11344             ReusableStringStream rss;}
\DoxyCodeLine{11345             rss << \textcolor{stringliteral}{"{}  "{}} << std::setw(2) << tagCount.second.count << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{11346             \textcolor{keyword}{auto} str = rss.str();}
\DoxyCodeLine{11347             \textcolor{keyword}{auto} wrapper = Column( tagCount.second.all() )}
\DoxyCodeLine{11348                                                     .initialIndent( 0 )}
\DoxyCodeLine{11349                                                     .indent( str.size() )}
\DoxyCodeLine{11350                                                     .width( CATCH\_CONFIG\_CONSOLE\_WIDTH-\/10 );}
\DoxyCodeLine{11351             Catch::cout() << str << wrapper << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{11352         \}}
\DoxyCodeLine{11353         Catch::cout() << pluralise( tagCounts.size(), \textcolor{stringliteral}{"{}tag"{}} ) << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{11354         \textcolor{keywordflow}{return} tagCounts.size();}
\DoxyCodeLine{11355     \}}
\DoxyCodeLine{11356 }
\DoxyCodeLine{11357     std::size\_t listReporters() \{}
\DoxyCodeLine{11358         Catch::cout() << \textcolor{stringliteral}{"{}Available reporters:\(\backslash\)n"{}};}
\DoxyCodeLine{11359         IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& factories = getRegistryHub().getReporterRegistry().getFactories();}
\DoxyCodeLine{11360         std::size\_t maxNameLen = 0;}
\DoxyCodeLine{11361         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories )}
\DoxyCodeLine{11362             maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );}
\DoxyCodeLine{11363 }
\DoxyCodeLine{11364         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& factoryKvp : factories ) \{}
\DoxyCodeLine{11365             Catch::cout()}
\DoxyCodeLine{11366                     << Column( factoryKvp.first + \textcolor{stringliteral}{"{}:"{}} )}
\DoxyCodeLine{11367                             .indent(2)}
\DoxyCodeLine{11368                             .width( 5+maxNameLen )}
\DoxyCodeLine{11369                     +  Column( factoryKvp.second-\/>getDescription() )}
\DoxyCodeLine{11370                             .initialIndent(0)}
\DoxyCodeLine{11371                             .indent(2)}
\DoxyCodeLine{11372                             .width( CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ maxNameLen-\/8 )}
\DoxyCodeLine{11373                     << "{}\(\backslash\)n"{};}
\DoxyCodeLine{11374         \}}
\DoxyCodeLine{11375         Catch::cout() << std::endl;}
\DoxyCodeLine{11376         \textcolor{keywordflow}{return} factories.size();}
\DoxyCodeLine{11377     \}}
\DoxyCodeLine{11378 }
\DoxyCodeLine{11379     Option<std::size\_t> list( std::shared\_ptr<Config> \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{11380         Option<std::size\_t> listedCount;}
\DoxyCodeLine{11381         getCurrentMutableContext().setConfig( config );}
\DoxyCodeLine{11382         \textcolor{keywordflow}{if}( config-\/>listTests() )}
\DoxyCodeLine{11383             listedCount = listedCount.valueOr(0) + listTests( *config );}
\DoxyCodeLine{11384         \textcolor{keywordflow}{if}( config-\/>listTestNamesOnly() )}
\DoxyCodeLine{11385             listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );}
\DoxyCodeLine{11386         \textcolor{keywordflow}{if}( config-\/>listTags() )}
\DoxyCodeLine{11387             listedCount = listedCount.valueOr(0) + listTags( *config );}
\DoxyCodeLine{11388         \textcolor{keywordflow}{if}( config-\/>listReporters() )}
\DoxyCodeLine{11389             listedCount = listedCount.valueOr(0) + listReporters();}
\DoxyCodeLine{11390         \textcolor{keywordflow}{return} listedCount;}
\DoxyCodeLine{11391     \}}
\DoxyCodeLine{11392 }
\DoxyCodeLine{11393 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11394 \textcolor{comment}{// end catch\_list.cpp}}
\DoxyCodeLine{11395 \textcolor{comment}{// start catch\_matchers.cpp}}
\DoxyCodeLine{11396 }
\DoxyCodeLine{11397 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11398 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11399     \textcolor{keyword}{namespace }Impl \{}
\DoxyCodeLine{11400 }
\DoxyCodeLine{11401         std::string MatcherUntypedBase::toString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11402             \textcolor{keywordflow}{if}( m\_cachedToString.empty() )}
\DoxyCodeLine{11403                 m\_cachedToString = describe();}
\DoxyCodeLine{11404             \textcolor{keywordflow}{return} m\_cachedToString;}
\DoxyCodeLine{11405         \}}
\DoxyCodeLine{11406 }
\DoxyCodeLine{11407         MatcherUntypedBase::\string~MatcherUntypedBase() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{11408 }
\DoxyCodeLine{11409     \} \textcolor{comment}{// namespace Impl}}
\DoxyCodeLine{11410 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11411 }
\DoxyCodeLine{11412 \textcolor{keyword}{using namespace }Matchers;}
\DoxyCodeLine{11413 \textcolor{keyword}{using} Matchers::Impl::MatcherBase;}
\DoxyCodeLine{11414 }
\DoxyCodeLine{11415 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11416 \textcolor{comment}{// end catch\_matchers.cpp}}
\DoxyCodeLine{11417 \textcolor{comment}{// start catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11418 }
\DoxyCodeLine{11419 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11420 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11421 \textcolor{keyword}{namespace }Exception \{}
\DoxyCodeLine{11422 }
\DoxyCodeLine{11423 \textcolor{keywordtype}{bool} ExceptionMessageMatcher::match(std::exception \textcolor{keyword}{const}\& ex)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11424     \textcolor{keywordflow}{return} ex.what() == m\_message;}
\DoxyCodeLine{11425 \}}
\DoxyCodeLine{11426 }
\DoxyCodeLine{11427 std::string ExceptionMessageMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11428     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}exception message matches \(\backslash\)"{}"{}} + m\_message + "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11429 \}}
\DoxyCodeLine{11430 }
\DoxyCodeLine{11431 \}}
\DoxyCodeLine{11432 Exception::ExceptionMessageMatcher Message(std::string \textcolor{keyword}{const}\& message) \{}
\DoxyCodeLine{11433     \textcolor{keywordflow}{return} Exception::ExceptionMessageMatcher(message);}
\DoxyCodeLine{11434 \}}
\DoxyCodeLine{11435 }
\DoxyCodeLine{11436 \textcolor{comment}{// namespace Exception}}
\DoxyCodeLine{11437 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11438 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11439 \textcolor{comment}{// end catch\_matchers\_exception.cpp}}
\DoxyCodeLine{11440 \textcolor{comment}{// start catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11441 }
\DoxyCodeLine{11442 \textcolor{comment}{// start catch\_polyfills.hpp}}
\DoxyCodeLine{11443 }
\DoxyCodeLine{11444 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11445     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f);}
\DoxyCodeLine{11446     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d);}
\DoxyCodeLine{11447 \}}
\DoxyCodeLine{11448 }
\DoxyCodeLine{11449 \textcolor{comment}{// end catch\_polyfills.hpp}}
\DoxyCodeLine{11450 \textcolor{comment}{// start catch\_to\_string.hpp}}
\DoxyCodeLine{11451 }
\DoxyCodeLine{11452 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11453 }
\DoxyCodeLine{11454 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11455     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{11456     std::string to\_string(T \textcolor{keyword}{const}\& t) \{}
\DoxyCodeLine{11457 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP11\_TO\_STRING)}}
\DoxyCodeLine{11458         \textcolor{keywordflow}{return} std::to\_string(t);}
\DoxyCodeLine{11459 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11460         ReusableStringStream rss;}
\DoxyCodeLine{11461         rss << t;}
\DoxyCodeLine{11462         \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{11463 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11464     \}}
\DoxyCodeLine{11465 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11466 }
\DoxyCodeLine{11467 \textcolor{comment}{// end catch\_to\_string.hpp}}
\DoxyCodeLine{11468 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{11469 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{11470 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{11471 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{11472 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{11473 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{11474 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{11475 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{11476 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{11477 }
\DoxyCodeLine{11478 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11479 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{11480 }
\DoxyCodeLine{11481     int32\_t convert(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{11482         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(float) == \textcolor{keyword}{sizeof}(int32\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11483         int32\_t i;}
\DoxyCodeLine{11484         std::memcpy(\&i, \&f, \textcolor{keyword}{sizeof}(f));}
\DoxyCodeLine{11485         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11486     \}}
\DoxyCodeLine{11487 }
\DoxyCodeLine{11488     int64\_t convert(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{11489         \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(double) == \textcolor{keyword}{sizeof}(int64\_t), \textcolor{stringliteral}{"{}Important ULP matcher assumption violated"{}});}
\DoxyCodeLine{11490         int64\_t i;}
\DoxyCodeLine{11491         std::memcpy(\&i, \&d, \textcolor{keyword}{sizeof}(d));}
\DoxyCodeLine{11492         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11493     \}}
\DoxyCodeLine{11494 }
\DoxyCodeLine{11495     \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11496     \textcolor{keywordtype}{bool} almostEqualUlps(FP lhs, FP rhs, uint64\_t maxUlpDiff) \{}
\DoxyCodeLine{11497         \textcolor{comment}{// Comparison with NaN should always be false.}}
\DoxyCodeLine{11498         \textcolor{comment}{// This way we can rule it out before getting into the ugly details}}
\DoxyCodeLine{11499         \textcolor{keywordflow}{if} (Catch::isnan(lhs) || Catch::isnan(rhs)) \{}
\DoxyCodeLine{11500             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{11501         \}}
\DoxyCodeLine{11502 }
\DoxyCodeLine{11503         \textcolor{keyword}{auto} lc = convert(lhs);}
\DoxyCodeLine{11504         \textcolor{keyword}{auto} rc = convert(rhs);}
\DoxyCodeLine{11505 }
\DoxyCodeLine{11506         \textcolor{keywordflow}{if} ((lc < 0) != (rc < 0)) \{}
\DoxyCodeLine{11507             \textcolor{comment}{// Potentially we can have +0 and -\/0}}
\DoxyCodeLine{11508             \textcolor{keywordflow}{return} lhs == rhs;}
\DoxyCodeLine{11509         \}}
\DoxyCodeLine{11510 }
\DoxyCodeLine{11511         \textcolor{comment}{// static cast as a workaround for IBM XLC}}
\DoxyCodeLine{11512         \textcolor{keyword}{auto} ulpDiff = std::abs(\textcolor{keyword}{static\_cast<}FP\textcolor{keyword}{>}(lc -\/ rc));}
\DoxyCodeLine{11513         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(ulpDiff) <= maxUlpDiff;}
\DoxyCodeLine{11514     \}}
\DoxyCodeLine{11515 }
\DoxyCodeLine{11516 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11517 }
\DoxyCodeLine{11518     \textcolor{keywordtype}{float} nextafter(\textcolor{keywordtype}{float} x, \textcolor{keywordtype}{float} y) \{}
\DoxyCodeLine{11519         return ::nextafterf(x, y);}
\DoxyCodeLine{11520     \}}
\DoxyCodeLine{11521 }
\DoxyCodeLine{11522     \textcolor{keywordtype}{double} nextafter(\textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y) \{}
\DoxyCodeLine{11523         return ::nextafter(x, y);}
\DoxyCodeLine{11524     \}}
\DoxyCodeLine{11525 }
\DoxyCodeLine{11526 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \string^\string^\string^ CATCH\_CONFIG\_GLOBAL\_NEXTAFTER \string^\string^\string^}}
\DoxyCodeLine{11527 }
\DoxyCodeLine{11528 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FP>}
\DoxyCodeLine{11529 FP step(FP start, FP direction, uint64\_t steps) \{}
\DoxyCodeLine{11530     \textcolor{keywordflow}{for} (uint64\_t i = 0; i < steps; ++i) \{}
\DoxyCodeLine{11531 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_GLOBAL\_NEXTAFTER)}}
\DoxyCodeLine{11532         start = Catch::nextafter(start, direction);}
\DoxyCodeLine{11533 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{11534         start = std::nextafter(start, direction);}
\DoxyCodeLine{11535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11536     \}}
\DoxyCodeLine{11537     \textcolor{keywordflow}{return} start;}
\DoxyCodeLine{11538 \}}
\DoxyCodeLine{11539 }
\DoxyCodeLine{11540 \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11541 \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11542 \textcolor{keywordtype}{bool} marginComparison(\textcolor{keywordtype}{double} lhs, \textcolor{keywordtype}{double} rhs, \textcolor{keywordtype}{double} margin) \{}
\DoxyCodeLine{11543     \textcolor{keywordflow}{return} (lhs + margin >= rhs) \&\& (rhs + margin >= lhs);}
\DoxyCodeLine{11544 \}}
\DoxyCodeLine{11545 }
\DoxyCodeLine{11546 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FloatingPo\textcolor{keywordtype}{int}>}
\DoxyCodeLine{11547 \textcolor{keywordtype}{void} write(std::ostream\& out, FloatingPoint num) \{}
\DoxyCodeLine{11548     out << std::scientific}
\DoxyCodeLine{11549         << std::setprecision(std::numeric\_limits<FloatingPoint>::max\_digits10 -\/ 1)}
\DoxyCodeLine{11550         << num;}
\DoxyCodeLine{11551 \}}
\DoxyCodeLine{11552 }
\DoxyCodeLine{11553 \} \textcolor{comment}{// end anonymous namespace}}
\DoxyCodeLine{11554 }
\DoxyCodeLine{11555 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11556 \textcolor{keyword}{namespace }Floating \{}
\DoxyCodeLine{11557 }
\DoxyCodeLine{11558     \textcolor{keyword}{enum class} FloatingPointKind : uint8\_t \{}
\DoxyCodeLine{11559         Float,}
\DoxyCodeLine{11560         Double}
\DoxyCodeLine{11561     \};}
\DoxyCodeLine{11562 }
\DoxyCodeLine{11563     WithinAbsMatcher::WithinAbsMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} margin)}
\DoxyCodeLine{11564         :m\_target\{ target \}, m\_margin\{ margin \} \{}
\DoxyCodeLine{11565         CATCH\_ENFORCE(margin >= 0, \textcolor{stringliteral}{"{}Invalid margin: "{}} << margin << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{11566             << \textcolor{stringliteral}{"{} Margin has to be non-\/negative."{}});}
\DoxyCodeLine{11567     \}}
\DoxyCodeLine{11568 }
\DoxyCodeLine{11569     \textcolor{comment}{// Performs equivalent check of std::fabs(lhs -\/ rhs) <= margin}}
\DoxyCodeLine{11570     \textcolor{comment}{// But without the subtraction to allow for INFINITY in comparison}}
\DoxyCodeLine{11571     \textcolor{keywordtype}{bool} WithinAbsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11572         \textcolor{keywordflow}{return} (matchee + m\_margin >= m\_target) \&\& (m\_target + m\_margin >= matchee);}
\DoxyCodeLine{11573     \}}
\DoxyCodeLine{11574 }
\DoxyCodeLine{11575     std::string WithinAbsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11576         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}is within "{}} + ::Catch::Detail::stringify(m\_margin) + "{} of "{} + ::Catch::Detail::stringify(m\_target);}
\DoxyCodeLine{11577     \}}
\DoxyCodeLine{11578 }
\DoxyCodeLine{11579     WithinUlpsMatcher::WithinUlpsMatcher(\textcolor{keywordtype}{double} target, uint64\_t ulps, FloatingPointKind baseType)}
\DoxyCodeLine{11580         :m\_target\{ target \}, m\_ulps\{ ulps \}, m\_type\{ baseType \} \{}
\DoxyCodeLine{11581         CATCH\_ENFORCE(m\_type == FloatingPointKind::Double}
\DoxyCodeLine{11582                    || m\_ulps < (std::numeric\_limits<uint32\_t>::max)(),}
\DoxyCodeLine{11583             \textcolor{stringliteral}{"{}Provided ULP is impossibly large for a float comparison."{}});}
\DoxyCodeLine{11584     \}}
\DoxyCodeLine{11585 }
\DoxyCodeLine{11586 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11587 \textcolor{preprocessor}{\#pragma clang diagnostic push}}
\DoxyCodeLine{11588 \textcolor{comment}{// Clang <3.5 reports on the default branch in the switch below}}
\DoxyCodeLine{11589 \textcolor{preprocessor}{\#pragma clang diagnostic ignored "{}-\/Wunreachable-\/code"{}}}
\DoxyCodeLine{11590 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11591 }
\DoxyCodeLine{11592     \textcolor{keywordtype}{bool} WithinUlpsMatcher::match(\textcolor{keywordtype}{double} \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11593         \textcolor{keywordflow}{switch} (m\_type) \{}
\DoxyCodeLine{11594         \textcolor{keywordflow}{case} FloatingPointKind::Float:}
\DoxyCodeLine{11595             \textcolor{keywordflow}{return} almostEqualUlps<float>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(matchee), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), m\_ulps);}
\DoxyCodeLine{11596         \textcolor{keywordflow}{case} FloatingPointKind::Double:}
\DoxyCodeLine{11597             \textcolor{keywordflow}{return} almostEqualUlps<double>(matchee, m\_target, m\_ulps);}
\DoxyCodeLine{11598         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{11599             CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown FloatingPointKind value"{}} );}
\DoxyCodeLine{11600         \}}
\DoxyCodeLine{11601     \}}
\DoxyCodeLine{11602 }
\DoxyCodeLine{11603 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{11604 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{11605 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{11606 }
\DoxyCodeLine{11607     std::string WithinUlpsMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11608         std::stringstream ret;}
\DoxyCodeLine{11609 }
\DoxyCodeLine{11610         ret << \textcolor{stringliteral}{"{}is within "{}} << m\_ulps << \textcolor{stringliteral}{"{} ULPs of "{}};}
\DoxyCodeLine{11611 }
\DoxyCodeLine{11612         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Float) \{}
\DoxyCodeLine{11613             write(ret, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target));}
\DoxyCodeLine{11614             ret << \textcolor{charliteral}{'f'};}
\DoxyCodeLine{11615         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11616             write(ret, m\_target);}
\DoxyCodeLine{11617         \}}
\DoxyCodeLine{11618 }
\DoxyCodeLine{11619         ret << \textcolor{stringliteral}{"{} (["{}};}
\DoxyCodeLine{11620         \textcolor{keywordflow}{if} (m\_type == FloatingPointKind::Double) \{}
\DoxyCodeLine{11621             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11622             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11623             write(ret, step(m\_target, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11624         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{11625             \textcolor{comment}{// We have to cast INFINITY to float because of MinGW, see \#1782}}
\DoxyCodeLine{11626             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(-\/INFINITY), m\_ulps));}
\DoxyCodeLine{11627             ret << \textcolor{stringliteral}{"{}, "{}};}
\DoxyCodeLine{11628             write(ret, step(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(m\_target), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}( INFINITY), m\_ulps));}
\DoxyCodeLine{11629         \}}
\DoxyCodeLine{11630         ret << \textcolor{stringliteral}{"{}])"{}};}
\DoxyCodeLine{11631 }
\DoxyCodeLine{11632         \textcolor{keywordflow}{return} ret.str();}
\DoxyCodeLine{11633     \}}
\DoxyCodeLine{11634 }
\DoxyCodeLine{11635     WithinRelMatcher::WithinRelMatcher(\textcolor{keywordtype}{double} target, \textcolor{keywordtype}{double} epsilon):}
\DoxyCodeLine{11636         m\_target(target),}
\DoxyCodeLine{11637         m\_epsilon(epsilon)\{}
\DoxyCodeLine{11638         CATCH\_ENFORCE(m\_epsilon >= 0., \textcolor{stringliteral}{"{}Relative comparison with epsilon <  0 does not make sense."{}});}
\DoxyCodeLine{11639         CATCH\_ENFORCE(m\_epsilon  < 1., "{}Relative comparison with epsilon >= 1 does not make sense.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{11640 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11641 \textcolor{stringliteral}{}}
\DoxyCodeLine{11642 \textcolor{stringliteral}{    bool WithinRelMatcher::match(double const\& matchee) const \{}}
\DoxyCodeLine{11643 \textcolor{stringliteral}{        const auto relMargin = m\_epsilon * (std::max)(std::fabs(matchee), std::fabs(m\_target));}}
\DoxyCodeLine{11644 \textcolor{stringliteral}{        return marginComparison(matchee, m\_target,}}
\DoxyCodeLine{11645 \textcolor{stringliteral}{                                std::isinf(relMargin)? 0 : relMargin);}}
\DoxyCodeLine{11646 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11647 \textcolor{stringliteral}{}}
\DoxyCodeLine{11648 \textcolor{stringliteral}{    std::string WithinRelMatcher::describe() const \{}}
\DoxyCodeLine{11649 \textcolor{stringliteral}{        Catch::ReusableStringStream sstr;}}
\DoxyCodeLine{11650 \textcolor{stringliteral}{        sstr << "{}}and \textcolor{stringliteral}{"{} << m\_target << "{}} are within \textcolor{stringliteral}{"{} << m\_epsilon * 100. << "{}}\% of each other\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11651 \textcolor{stringliteral}{        return sstr.str();}}
\DoxyCodeLine{11652 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{11653 \textcolor{stringliteral}{}}
\DoxyCodeLine{11654 \textcolor{stringliteral}{\}// namespace Floating}}
\DoxyCodeLine{11655 \textcolor{stringliteral}{}}
\DoxyCodeLine{11656 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(double target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11657 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);}}
\DoxyCodeLine{11658 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11659 \textcolor{stringliteral}{}}
\DoxyCodeLine{11660 \textcolor{stringliteral}{Floating::WithinUlpsMatcher WithinULP(float target, uint64\_t maxUlpDiff) \{}}
\DoxyCodeLine{11661 \textcolor{stringliteral}{    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);}}
\DoxyCodeLine{11662 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11663 \textcolor{stringliteral}{}}
\DoxyCodeLine{11664 \textcolor{stringliteral}{Floating::WithinAbsMatcher WithinAbs(double target, double margin) \{}}
\DoxyCodeLine{11665 \textcolor{stringliteral}{    return Floating::WithinAbsMatcher(target, margin);}}
\DoxyCodeLine{11666 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11667 \textcolor{stringliteral}{}}
\DoxyCodeLine{11668 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target, double eps) \{}}
\DoxyCodeLine{11669 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11670 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11671 \textcolor{stringliteral}{}}
\DoxyCodeLine{11672 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(double target) \{}}
\DoxyCodeLine{11673 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<double>::epsilon() * 100);}}
\DoxyCodeLine{11674 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11675 \textcolor{stringliteral}{}}
\DoxyCodeLine{11676 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target, float eps) \{}}
\DoxyCodeLine{11677 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, eps);}}
\DoxyCodeLine{11678 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11679 \textcolor{stringliteral}{}}
\DoxyCodeLine{11680 \textcolor{stringliteral}{Floating::WithinRelMatcher WithinRel(float target) \{}}
\DoxyCodeLine{11681 \textcolor{stringliteral}{    return Floating::WithinRelMatcher(target, std::numeric\_limits<float>::epsilon() * 100);}}
\DoxyCodeLine{11682 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{11683 \textcolor{stringliteral}{}}
\DoxyCodeLine{11684 \textcolor{stringliteral}{\} // namespace Matchers}}
\DoxyCodeLine{11685 \textcolor{stringliteral}{\} // namespace Catch}}
\DoxyCodeLine{11686 \textcolor{stringliteral}{// end catch\_matchers\_floating.cpp}}
\DoxyCodeLine{11687 \textcolor{stringliteral}{// start catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11688 \textcolor{stringliteral}{}}
\DoxyCodeLine{11689 \textcolor{stringliteral}{std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string\& desc) \{}}
\DoxyCodeLine{11690 \textcolor{stringliteral}{    if (desc.empty()) \{}}
\DoxyCodeLine{11691 \textcolor{stringliteral}{        return "{}}matches undescribed predicate\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{11692 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{11693 \textcolor{stringliteral}{        return "{}}matches predicate: \(\backslash\)\textcolor{stringliteral}{"{}"{}} + desc + \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{11694     \}}
\DoxyCodeLine{11695 \}}
\DoxyCodeLine{11696 \textcolor{comment}{// end catch\_matchers\_generic.cpp}}
\DoxyCodeLine{11697 \textcolor{comment}{// start catch\_matchers\_string.cpp}}
\DoxyCodeLine{11698 }
\DoxyCodeLine{11699 \textcolor{preprocessor}{\#include <regex>}}
\DoxyCodeLine{11700 }
\DoxyCodeLine{11701 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11702 \textcolor{keyword}{namespace }Matchers \{}
\DoxyCodeLine{11703 }
\DoxyCodeLine{11704     \textcolor{keyword}{namespace }StdString \{}
\DoxyCodeLine{11705 }
\DoxyCodeLine{11706         CasedString::CasedString( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{11707         :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{11708             m\_str( adjustString( str ) )}
\DoxyCodeLine{11709         \{\}}
\DoxyCodeLine{11710         std::string CasedString::adjustString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11711             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11712                    ? toLower( str )}
\DoxyCodeLine{11713                    : str;}
\DoxyCodeLine{11714         \}}
\DoxyCodeLine{11715         std::string CasedString::caseSensitivitySuffix()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11716             \textcolor{keywordflow}{return} m\_caseSensitivity == CaseSensitive::No}
\DoxyCodeLine{11717                    ? \textcolor{stringliteral}{"{} (case insensitive)"{}}}
\DoxyCodeLine{11718                    : std::string();}
\DoxyCodeLine{11719         \}}
\DoxyCodeLine{11720 }
\DoxyCodeLine{11721         StringMatcherBase::StringMatcherBase( std::string \textcolor{keyword}{const}\& operation, CasedString \textcolor{keyword}{const}\& comparator )}
\DoxyCodeLine{11722         : m\_comparator( comparator ),}
\DoxyCodeLine{11723           m\_operation( operation ) \{}
\DoxyCodeLine{11724         \}}
\DoxyCodeLine{11725 }
\DoxyCodeLine{11726         std::string StringMatcherBase::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11727             std::string description;}
\DoxyCodeLine{11728             description.reserve(5 + m\_operation.size() + m\_comparator.m\_str.size() +}
\DoxyCodeLine{11729                                         m\_comparator.caseSensitivitySuffix().size());}
\DoxyCodeLine{11730             description += m\_operation;}
\DoxyCodeLine{11731             description += "{}: \(\backslash\)"{}"{};}
\DoxyCodeLine{11732             description += m\_comparator.m\_str;}
\DoxyCodeLine{11733             description += "{}\(\backslash\)"{}"{};}
\DoxyCodeLine{11734             description += m\_comparator.caseSensitivitySuffix();}
\DoxyCodeLine{11735             \textcolor{keywordflow}{return} description;}
\DoxyCodeLine{11736         \}}
\DoxyCodeLine{11737 }
\DoxyCodeLine{11738         EqualsMatcher::EqualsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}equals"{}}, comparator ) \{\}}
\DoxyCodeLine{11739 }
\DoxyCodeLine{11740         \textcolor{keywordtype}{bool} EqualsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11741             \textcolor{keywordflow}{return} m\_comparator.adjustString( source ) == m\_comparator.m\_str;}
\DoxyCodeLine{11742         \}}
\DoxyCodeLine{11743 }
\DoxyCodeLine{11744         ContainsMatcher::ContainsMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}contains"{}}, comparator ) \{\}}
\DoxyCodeLine{11745 }
\DoxyCodeLine{11746         \textcolor{keywordtype}{bool} ContainsMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11747             \textcolor{keywordflow}{return} contains( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11748         \}}
\DoxyCodeLine{11749 }
\DoxyCodeLine{11750         StartsWithMatcher::StartsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}starts with"{}}, comparator ) \{\}}
\DoxyCodeLine{11751 }
\DoxyCodeLine{11752         \textcolor{keywordtype}{bool} StartsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11753             \textcolor{keywordflow}{return} startsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11754         \}}
\DoxyCodeLine{11755 }
\DoxyCodeLine{11756         EndsWithMatcher::EndsWithMatcher( CasedString \textcolor{keyword}{const}\& comparator ) : StringMatcherBase( \textcolor{stringliteral}{"{}ends with"{}}, comparator ) \{\}}
\DoxyCodeLine{11757 }
\DoxyCodeLine{11758         \textcolor{keywordtype}{bool} EndsWithMatcher::match( std::string \textcolor{keyword}{const}\& source )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11759             \textcolor{keywordflow}{return} endsWith( m\_comparator.adjustString( source ), m\_comparator.m\_str );}
\DoxyCodeLine{11760         \}}
\DoxyCodeLine{11761 }
\DoxyCodeLine{11762         RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m\_regex(std::move(regex)), m\_caseSensitivity(caseSensitivity) \{\}}
\DoxyCodeLine{11763 }
\DoxyCodeLine{11764         \textcolor{keywordtype}{bool} RegexMatcher::match(std::string \textcolor{keyword}{const}\& matchee)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11765             \textcolor{keyword}{auto} flags = std::regex::ECMAScript; \textcolor{comment}{// ECMAScript is the default syntax option anyway}}
\DoxyCodeLine{11766             \textcolor{keywordflow}{if} (m\_caseSensitivity == CaseSensitive::Choice::No) \{}
\DoxyCodeLine{11767                 flags |= std::regex::icase;}
\DoxyCodeLine{11768             \}}
\DoxyCodeLine{11769             \textcolor{keyword}{auto} reg = std::regex(m\_regex, flags);}
\DoxyCodeLine{11770             \textcolor{keywordflow}{return} std::regex\_match(matchee, reg);}
\DoxyCodeLine{11771         \}}
\DoxyCodeLine{11772 }
\DoxyCodeLine{11773         std::string RegexMatcher::describe()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11774             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}matches "{}} + ::Catch::Detail::stringify(m\_regex) + ((m\_caseSensitivity == CaseSensitive::Choice::Yes)? "{} case sensitively"{} : "{} case insensitively"{});}
\DoxyCodeLine{11775         \}}
\DoxyCodeLine{11776 }
\DoxyCodeLine{11777     \} \textcolor{comment}{// namespace StdString}}
\DoxyCodeLine{11778 }
\DoxyCodeLine{11779     StdString::EqualsMatcher Equals( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11780         \textcolor{keywordflow}{return} StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11781     \}}
\DoxyCodeLine{11782     StdString::ContainsMatcher Contains( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11783         \textcolor{keywordflow}{return} StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11784     \}}
\DoxyCodeLine{11785     StdString::EndsWithMatcher EndsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11786         \textcolor{keywordflow}{return} StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11787     \}}
\DoxyCodeLine{11788     StdString::StartsWithMatcher StartsWith( std::string \textcolor{keyword}{const}\& str, CaseSensitive::Choice caseSensitivity ) \{}
\DoxyCodeLine{11789         \textcolor{keywordflow}{return} StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );}
\DoxyCodeLine{11790     \}}
\DoxyCodeLine{11791 }
\DoxyCodeLine{11792     StdString::RegexMatcher Matches(std::string \textcolor{keyword}{const}\& regex, CaseSensitive::Choice caseSensitivity) \{}
\DoxyCodeLine{11793         \textcolor{keywordflow}{return} StdString::RegexMatcher(regex, caseSensitivity);}
\DoxyCodeLine{11794     \}}
\DoxyCodeLine{11795 }
\DoxyCodeLine{11796 \} \textcolor{comment}{// namespace Matchers}}
\DoxyCodeLine{11797 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{11798 \textcolor{comment}{// end catch\_matchers\_string.cpp}}
\DoxyCodeLine{11799 \textcolor{comment}{// start catch\_message.cpp}}
\DoxyCodeLine{11800 }
\DoxyCodeLine{11801 \textcolor{comment}{// start catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11802 }
\DoxyCodeLine{11803 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11804     \textcolor{keywordtype}{bool} uncaught\_exceptions();}
\DoxyCodeLine{11805 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11806 }
\DoxyCodeLine{11807 \textcolor{comment}{// end catch\_uncaught\_exceptions.h}}
\DoxyCodeLine{11808 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{11809 \textcolor{preprocessor}{\#include <stack>}}
\DoxyCodeLine{11810 }
\DoxyCodeLine{11811 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11812 }
\DoxyCodeLine{11813     MessageInfo::MessageInfo(   StringRef \textcolor{keyword}{const}\& \_macroName,}
\DoxyCodeLine{11814                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{11815                                 ResultWas::OfType \_type )}
\DoxyCodeLine{11816     :   macroName( \_macroName ),}
\DoxyCodeLine{11817         lineInfo( \_lineInfo ),}
\DoxyCodeLine{11818         type( \_type ),}
\DoxyCodeLine{11819         sequence( ++globalCount )}
\DoxyCodeLine{11820     \{\}}
\DoxyCodeLine{11821 }
\DoxyCodeLine{11822     \textcolor{keywordtype}{bool} MessageInfo::operator==( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11823         \textcolor{keywordflow}{return} sequence == other.sequence;}
\DoxyCodeLine{11824     \}}
\DoxyCodeLine{11825 }
\DoxyCodeLine{11826     \textcolor{keywordtype}{bool} MessageInfo::operator<( MessageInfo \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{11827         \textcolor{keywordflow}{return} sequence < other.sequence;}
\DoxyCodeLine{11828     \}}
\DoxyCodeLine{11829 }
\DoxyCodeLine{11830     \textcolor{comment}{// This may need protecting if threading support is added}}
\DoxyCodeLine{11831     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} MessageInfo::globalCount = 0;}
\DoxyCodeLine{11832 }
\DoxyCodeLine{11834 }
\DoxyCodeLine{11835     Catch::MessageBuilder::MessageBuilder( StringRef \textcolor{keyword}{const}\& macroName,}
\DoxyCodeLine{11836                                            SourceLineInfo \textcolor{keyword}{const}\& lineInfo,}
\DoxyCodeLine{11837                                            ResultWas::OfType type )}
\DoxyCodeLine{11838         :m\_info(macroName, lineInfo, type) \{\}}
\DoxyCodeLine{11839 }
\DoxyCodeLine{11841 }
\DoxyCodeLine{11842     ScopedMessage::ScopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder )}
\DoxyCodeLine{11843     : m\_info( builder.m\_info ), m\_moved()}
\DoxyCodeLine{11844     \{}
\DoxyCodeLine{11845         m\_info.message = builder.m\_stream.str();}
\DoxyCodeLine{11846         getResultCapture().pushScopedMessage( m\_info );}
\DoxyCodeLine{11847     \}}
\DoxyCodeLine{11848 }
\DoxyCodeLine{11849     ScopedMessage::ScopedMessage( ScopedMessage\&\& old )}
\DoxyCodeLine{11850     : m\_info( old.m\_info ), m\_moved()}
\DoxyCodeLine{11851     \{}
\DoxyCodeLine{11852         old.m\_moved = \textcolor{keyword}{true};}
\DoxyCodeLine{11853     \}}
\DoxyCodeLine{11854 }
\DoxyCodeLine{11855     ScopedMessage::\string~ScopedMessage() \{}
\DoxyCodeLine{11856         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() \&\& !m\_moved )\{}
\DoxyCodeLine{11857             getResultCapture().popScopedMessage(m\_info);}
\DoxyCodeLine{11858         \}}
\DoxyCodeLine{11859     \}}
\DoxyCodeLine{11860 }
\DoxyCodeLine{11861     Capturer::Capturer( StringRef macroName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, ResultWas::OfType resultType, StringRef names ) \{}
\DoxyCodeLine{11862         \textcolor{keyword}{auto} trimmed = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{size\_t} end) \{}
\DoxyCodeLine{11863             \textcolor{keywordflow}{while} (names[start] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[start]))) \{}
\DoxyCodeLine{11864                 ++start;}
\DoxyCodeLine{11865             \}}
\DoxyCodeLine{11866             \textcolor{keywordflow}{while} (names[end] == \textcolor{charliteral}{','} || isspace(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(names[end]))) \{}
\DoxyCodeLine{11867                 -\/-\/end;}
\DoxyCodeLine{11868             \}}
\DoxyCodeLine{11869             \textcolor{keywordflow}{return} names.substr(start, end -\/ start + 1);}
\DoxyCodeLine{11870         \};}
\DoxyCodeLine{11871         \textcolor{keyword}{auto} skipq = [\&] (\textcolor{keywordtype}{size\_t} start, \textcolor{keywordtype}{char} quote) \{}
\DoxyCodeLine{11872             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = start + 1; i < names.size() ; ++i) \{}
\DoxyCodeLine{11873                 \textcolor{keywordflow}{if} (names[i] == quote)}
\DoxyCodeLine{11874                     \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{11875                 \textcolor{keywordflow}{if} (names[i] == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})}
\DoxyCodeLine{11876                     ++i;}
\DoxyCodeLine{11877             \}}
\DoxyCodeLine{11878             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}CAPTURE parsing encountered unmatched quote"{}});}
\DoxyCodeLine{11879         \};}
\DoxyCodeLine{11880 }
\DoxyCodeLine{11881         \textcolor{keywordtype}{size\_t} start = 0;}
\DoxyCodeLine{11882         std::stack<char> openings;}
\DoxyCodeLine{11883         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} pos = 0; pos < names.size(); ++pos) \{}
\DoxyCodeLine{11884             \textcolor{keywordtype}{char} c = names[pos];}
\DoxyCodeLine{11885             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{11886             \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{11887             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{11888             \textcolor{keywordflow}{case} \textcolor{charliteral}{'('}:}
\DoxyCodeLine{11889             \textcolor{comment}{// It is basically impossible to disambiguate between}}
\DoxyCodeLine{11890             \textcolor{comment}{// comparison and start of template args in this context}}
\DoxyCodeLine{11891 \textcolor{comment}{//            case '<':}}
\DoxyCodeLine{11892                 openings.push(c);}
\DoxyCodeLine{11893                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11894             \textcolor{keywordflow}{case} \textcolor{charliteral}{']'}:}
\DoxyCodeLine{11895             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{11896             \textcolor{keywordflow}{case} \textcolor{charliteral}{')'}:}
\DoxyCodeLine{11897 \textcolor{comment}{//           case '>':}}
\DoxyCodeLine{11898                 openings.pop();}
\DoxyCodeLine{11899                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11900             \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{11901             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}:}
\DoxyCodeLine{11902                 pos = skipq(pos, c);}
\DoxyCodeLine{11903                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{11904             \textcolor{keywordflow}{case} \textcolor{charliteral}{','}:}
\DoxyCodeLine{11905                 \textcolor{keywordflow}{if} (start != pos \&\& openings.empty()) \{}
\DoxyCodeLine{11906                     m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11907                     m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, pos));}
\DoxyCodeLine{11908                     m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11909                     start = pos;}
\DoxyCodeLine{11910                 \}}
\DoxyCodeLine{11911             \}}
\DoxyCodeLine{11912         \}}
\DoxyCodeLine{11913         assert(openings.empty() \&\& \textcolor{stringliteral}{"{}Mismatched openings"{}});}
\DoxyCodeLine{11914         m\_messages.emplace\_back(macroName, lineInfo, resultType);}
\DoxyCodeLine{11915         m\_messages.back().message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(trimmed(start, names.size() -\/ 1));}
\DoxyCodeLine{11916         m\_messages.back().message += "{} := "{};}
\DoxyCodeLine{11917     \}}
\DoxyCodeLine{11918     Capturer::\string~Capturer() \{}
\DoxyCodeLine{11919         \textcolor{keywordflow}{if} ( !uncaught\_exceptions() )\{}
\DoxyCodeLine{11920             assert( m\_captured == m\_messages.size() );}
\DoxyCodeLine{11921             \textcolor{keywordflow}{for}( \textcolor{keywordtype}{size\_t} i = 0; i < m\_captured; ++i  )}
\DoxyCodeLine{11922                 m\_resultCapture.popScopedMessage( m\_messages[i] );}
\DoxyCodeLine{11923         \}}
\DoxyCodeLine{11924     \}}
\DoxyCodeLine{11925 }
\DoxyCodeLine{11926     \textcolor{keywordtype}{void} Capturer::captureValue( \textcolor{keywordtype}{size\_t} index, std::string \textcolor{keyword}{const}\& value ) \{}
\DoxyCodeLine{11927         assert( index < m\_messages.size() );}
\DoxyCodeLine{11928         m\_messages[index].message += value;}
\DoxyCodeLine{11929         m\_resultCapture.pushScopedMessage( m\_messages[index] );}
\DoxyCodeLine{11930         m\_captured++;}
\DoxyCodeLine{11931     \}}
\DoxyCodeLine{11932 }
\DoxyCodeLine{11933 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{11934 \textcolor{comment}{// end catch\_message.cpp}}
\DoxyCodeLine{11935 \textcolor{comment}{// start catch\_output\_redirect.cpp}}
\DoxyCodeLine{11936 }
\DoxyCodeLine{11937 \textcolor{comment}{// start catch\_output\_redirect.h}}
\DoxyCodeLine{11938 \textcolor{preprocessor}{\#ifndef TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11939 \textcolor{preprocessor}{\#define TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{11940 }
\DoxyCodeLine{11941 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{11942 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{11943 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{11944 }
\DoxyCodeLine{11945 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{11946 }
\DoxyCodeLine{11947     \textcolor{keyword}{class }RedirectedStream \{}
\DoxyCodeLine{11948         std::ostream\& m\_originalStream;}
\DoxyCodeLine{11949         std::ostream\& m\_redirectionStream;}
\DoxyCodeLine{11950         std::streambuf* m\_prevBuf;}
\DoxyCodeLine{11951 }
\DoxyCodeLine{11952     \textcolor{keyword}{public}:}
\DoxyCodeLine{11953         RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream );}
\DoxyCodeLine{11954         \string~RedirectedStream();}
\DoxyCodeLine{11955     \};}
\DoxyCodeLine{11956 }
\DoxyCodeLine{11957     \textcolor{keyword}{class }RedirectedStdOut \{}
\DoxyCodeLine{11958         ReusableStringStream m\_rss;}
\DoxyCodeLine{11959         RedirectedStream m\_cout;}
\DoxyCodeLine{11960     \textcolor{keyword}{public}:}
\DoxyCodeLine{11961         RedirectedStdOut();}
\DoxyCodeLine{11962         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11963     \};}
\DoxyCodeLine{11964 }
\DoxyCodeLine{11965     \textcolor{comment}{// StdErr has two constituent streams in C++, std::cerr and std::clog}}
\DoxyCodeLine{11966     \textcolor{comment}{// This means that we need to redirect 2 streams into 1 to keep proper}}
\DoxyCodeLine{11967     \textcolor{comment}{// order of writes}}
\DoxyCodeLine{11968     class RedirectedStdErr \{}
\DoxyCodeLine{11969         ReusableStringStream m\_rss;}
\DoxyCodeLine{11970         RedirectedStream m\_cerr;}
\DoxyCodeLine{11971         RedirectedStream m\_clog;}
\DoxyCodeLine{11972     \textcolor{keyword}{public}:}
\DoxyCodeLine{11973         RedirectedStdErr();}
\DoxyCodeLine{11974         \textcolor{keyword}{auto} str() const -\/> std::\textcolor{keywordtype}{string};}
\DoxyCodeLine{11975     \};}
\DoxyCodeLine{11976 }
\DoxyCodeLine{11977     class RedirectedStreams \{}
\DoxyCodeLine{11978     \textcolor{keyword}{public}:}
\DoxyCodeLine{11979         RedirectedStreams(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11980         RedirectedStreams\& operator=(RedirectedStreams \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11981         RedirectedStreams(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11982         RedirectedStreams\& operator=(RedirectedStreams\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{11983 }
\DoxyCodeLine{11984         RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr);}
\DoxyCodeLine{11985         \string~RedirectedStreams();}
\DoxyCodeLine{11986     \textcolor{keyword}{private}:}
\DoxyCodeLine{11987         std::string\& m\_redirectedCout;}
\DoxyCodeLine{11988         std::string\& m\_redirectedCerr;}
\DoxyCodeLine{11989         RedirectedStdOut m\_redirectedStdOut;}
\DoxyCodeLine{11990         RedirectedStdErr m\_redirectedStdErr;}
\DoxyCodeLine{11991     \};}
\DoxyCodeLine{11992 }
\DoxyCodeLine{11993 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{11994 }
\DoxyCodeLine{11995     \textcolor{comment}{// Windows's implementation of std::tmpfile is terrible (it tries}}
\DoxyCodeLine{11996     \textcolor{comment}{// to create a file inside system folder, thus requiring elevated}}
\DoxyCodeLine{11997     \textcolor{comment}{// privileges for the binary), so we have to use tmpnam(\_s) and}}
\DoxyCodeLine{11998     \textcolor{comment}{// create the file ourselves there.}}
\DoxyCodeLine{11999     \textcolor{keyword}{class }TempFile \{}
\DoxyCodeLine{12000     \textcolor{keyword}{public}:}
\DoxyCodeLine{12001         TempFile(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12002         TempFile\& operator=(TempFile \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12003         TempFile(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12004         TempFile\& operator=(TempFile\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12005 }
\DoxyCodeLine{12006         TempFile();}
\DoxyCodeLine{12007         \string~TempFile();}
\DoxyCodeLine{12008 }
\DoxyCodeLine{12009         std::FILE* getFile();}
\DoxyCodeLine{12010         std::string getContents();}
\DoxyCodeLine{12011 }
\DoxyCodeLine{12012     \textcolor{keyword}{private}:}
\DoxyCodeLine{12013         std::FILE* m\_file = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12014 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12015         \textcolor{keywordtype}{char} m\_buffer[L\_tmpnam] = \{ 0 \};}
\DoxyCodeLine{12016 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12017     \};}
\DoxyCodeLine{12018 }
\DoxyCodeLine{12019     \textcolor{keyword}{class }OutputRedirect \{}
\DoxyCodeLine{12020     \textcolor{keyword}{public}:}
\DoxyCodeLine{12021         OutputRedirect(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12022         OutputRedirect\& operator=(OutputRedirect \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12023         OutputRedirect(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12024         OutputRedirect\& operator=(OutputRedirect\&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{12025 }
\DoxyCodeLine{12026         OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest);}
\DoxyCodeLine{12027         \string~OutputRedirect();}
\DoxyCodeLine{12028 }
\DoxyCodeLine{12029     \textcolor{keyword}{private}:}
\DoxyCodeLine{12030         \textcolor{keywordtype}{int} m\_originalStdout = -\/1;}
\DoxyCodeLine{12031         \textcolor{keywordtype}{int} m\_originalStderr = -\/1;}
\DoxyCodeLine{12032         TempFile m\_stdoutFile;}
\DoxyCodeLine{12033         TempFile m\_stderrFile;}
\DoxyCodeLine{12034         std::string\& m\_stdoutDest;}
\DoxyCodeLine{12035         std::string\& m\_stderrDest;}
\DoxyCodeLine{12036     \};}
\DoxyCodeLine{12037 }
\DoxyCodeLine{12038 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12039 }
\DoxyCodeLine{12040 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12041 }
\DoxyCodeLine{12042 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_CATCH\_OUTPUT\_REDIRECT\_H}}
\DoxyCodeLine{12043 \textcolor{comment}{// end catch\_output\_redirect.h}}
\DoxyCodeLine{12044 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{12045 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{12046 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{12047 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12048 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{12049 }
\DoxyCodeLine{12050 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12051 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12052 \textcolor{preprocessor}{    \#include <io.h>}      \textcolor{comment}{//\_dup and \_dup2}}
\DoxyCodeLine{12053 \textcolor{preprocessor}{    \#define dup \_dup}}
\DoxyCodeLine{12054 \textcolor{preprocessor}{    \#define dup2 \_dup2}}
\DoxyCodeLine{12055 \textcolor{preprocessor}{    \#define fileno \_fileno}}
\DoxyCodeLine{12056 \textcolor{preprocessor}{    \#else}}
\DoxyCodeLine{12057 \textcolor{preprocessor}{    \#include <unistd.h>}  \textcolor{comment}{// dup and dup2}}
\DoxyCodeLine{12058 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12059 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12060 }
\DoxyCodeLine{12061 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12062 }
\DoxyCodeLine{12063     RedirectedStream::RedirectedStream( std::ostream\& originalStream, std::ostream\& redirectionStream )}
\DoxyCodeLine{12064     :   m\_originalStream( originalStream ),}
\DoxyCodeLine{12065         m\_redirectionStream( redirectionStream ),}
\DoxyCodeLine{12066         m\_prevBuf( m\_originalStream.rdbuf() )}
\DoxyCodeLine{12067     \{}
\DoxyCodeLine{12068         m\_originalStream.rdbuf( m\_redirectionStream.rdbuf() );}
\DoxyCodeLine{12069     \}}
\DoxyCodeLine{12070 }
\DoxyCodeLine{12071     RedirectedStream::\string~RedirectedStream() \{}
\DoxyCodeLine{12072         m\_originalStream.rdbuf( m\_prevBuf );}
\DoxyCodeLine{12073     \}}
\DoxyCodeLine{12074 }
\DoxyCodeLine{12075     RedirectedStdOut::RedirectedStdOut() : m\_cout( Catch::cout(), m\_rss.get() ) \{\}}
\DoxyCodeLine{12076     \textcolor{keyword}{auto} RedirectedStdOut::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12077 }
\DoxyCodeLine{12078     RedirectedStdErr::RedirectedStdErr()}
\DoxyCodeLine{12079     :   m\_cerr( Catch::cerr(), m\_rss.get() ),}
\DoxyCodeLine{12080         m\_clog( Catch::clog(), m\_rss.get() )}
\DoxyCodeLine{12081     \{\}}
\DoxyCodeLine{12082     \textcolor{keyword}{auto} RedirectedStdErr::str() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} m\_rss.str(); \}}
\DoxyCodeLine{12083 }
\DoxyCodeLine{12084     RedirectedStreams::RedirectedStreams(std::string\& redirectedCout, std::string\& redirectedCerr)}
\DoxyCodeLine{12085     :   m\_redirectedCout(redirectedCout),}
\DoxyCodeLine{12086         m\_redirectedCerr(redirectedCerr)}
\DoxyCodeLine{12087     \{\}}
\DoxyCodeLine{12088 }
\DoxyCodeLine{12089     RedirectedStreams::\string~RedirectedStreams() \{}
\DoxyCodeLine{12090         m\_redirectedCout += m\_redirectedStdOut.str();}
\DoxyCodeLine{12091         m\_redirectedCerr += m\_redirectedStdErr.str();}
\DoxyCodeLine{12092     \}}
\DoxyCodeLine{12093 }
\DoxyCodeLine{12094 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12095 }
\DoxyCodeLine{12096 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12097     TempFile::TempFile() \{}
\DoxyCodeLine{12098         \textcolor{keywordflow}{if} (tmpnam\_s(m\_buffer)) \{}
\DoxyCodeLine{12099             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not get a temp filename"{}});}
\DoxyCodeLine{12100         \}}
\DoxyCodeLine{12101         \textcolor{keywordflow}{if} (fopen\_s(\&m\_file, m\_buffer, \textcolor{stringliteral}{"{}w+"{}})) \{}
\DoxyCodeLine{12102             \textcolor{keywordtype}{char} buffer[100];}
\DoxyCodeLine{12103             \textcolor{keywordflow}{if} (strerror\_s(buffer, errno)) \{}
\DoxyCodeLine{12104                 CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not translate errno to a string"{}});}
\DoxyCodeLine{12105             \}}
\DoxyCodeLine{12106             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not open the temp file: '"{}} << m\_buffer << \textcolor{stringliteral}{"{}' because: "{}} << buffer);}
\DoxyCodeLine{12107         \}}
\DoxyCodeLine{12108     \}}
\DoxyCodeLine{12109 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12110     TempFile::TempFile() \{}
\DoxyCodeLine{12111         m\_file = std::tmpfile();}
\DoxyCodeLine{12112         \textcolor{keywordflow}{if} (!m\_file) \{}
\DoxyCodeLine{12113             CATCH\_RUNTIME\_ERROR(\textcolor{stringliteral}{"{}Could not create a temp file."{}});}
\DoxyCodeLine{12114         \}}
\DoxyCodeLine{12115     \}}
\DoxyCodeLine{12116 }
\DoxyCodeLine{12117 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12118 }
\DoxyCodeLine{12119     TempFile::\string~TempFile() \{}
\DoxyCodeLine{12120          \textcolor{comment}{// TBD: What to do about errors here?}}
\DoxyCodeLine{12121          std::fclose(m\_file);}
\DoxyCodeLine{12122          \textcolor{comment}{// We manually create the file on Windows only, on Linux}}
\DoxyCodeLine{12123          \textcolor{comment}{// it will be autodeleted}}
\DoxyCodeLine{12124 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12125          std::remove(m\_buffer);}
\DoxyCodeLine{12126 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12127     \}}
\DoxyCodeLine{12128 }
\DoxyCodeLine{12129     FILE* TempFile::getFile() \{}
\DoxyCodeLine{12130         \textcolor{keywordflow}{return} m\_file;}
\DoxyCodeLine{12131     \}}
\DoxyCodeLine{12132 }
\DoxyCodeLine{12133     std::string TempFile::getContents() \{}
\DoxyCodeLine{12134         std::stringstream sstr;}
\DoxyCodeLine{12135         \textcolor{keywordtype}{char} buffer[100] = \{\};}
\DoxyCodeLine{12136         std::rewind(m\_file);}
\DoxyCodeLine{12137         \textcolor{keywordflow}{while} (std::fgets(buffer, \textcolor{keyword}{sizeof}(buffer), m\_file)) \{}
\DoxyCodeLine{12138             sstr << buffer;}
\DoxyCodeLine{12139         \}}
\DoxyCodeLine{12140         \textcolor{keywordflow}{return} sstr.str();}
\DoxyCodeLine{12141     \}}
\DoxyCodeLine{12142 }
\DoxyCodeLine{12143     OutputRedirect::OutputRedirect(std::string\& stdout\_dest, std::string\& stderr\_dest) :}
\DoxyCodeLine{12144         m\_originalStdout(dup(1)),}
\DoxyCodeLine{12145         m\_originalStderr(dup(2)),}
\DoxyCodeLine{12146         m\_stdoutDest(stdout\_dest),}
\DoxyCodeLine{12147         m\_stderrDest(stderr\_dest) \{}
\DoxyCodeLine{12148         dup2(fileno(m\_stdoutFile.getFile()), 1);}
\DoxyCodeLine{12149         dup2(fileno(m\_stderrFile.getFile()), 2);}
\DoxyCodeLine{12150     \}}
\DoxyCodeLine{12151 }
\DoxyCodeLine{12152     OutputRedirect::\string~OutputRedirect() \{}
\DoxyCodeLine{12153         Catch::cout() << std::flush;}
\DoxyCodeLine{12154         fflush(stdout);}
\DoxyCodeLine{12155         \textcolor{comment}{// Since we support overriding these streams, we flush cerr}}
\DoxyCodeLine{12156         \textcolor{comment}{// even though std::cerr is unbuffered}}
\DoxyCodeLine{12157         Catch::cerr() << std::flush;}
\DoxyCodeLine{12158         Catch::clog() << std::flush;}
\DoxyCodeLine{12159         fflush(stderr);}
\DoxyCodeLine{12160 }
\DoxyCodeLine{12161         dup2(m\_originalStdout, 1);}
\DoxyCodeLine{12162         dup2(m\_originalStderr, 2);}
\DoxyCodeLine{12163 }
\DoxyCodeLine{12164         m\_stdoutDest += m\_stdoutFile.getContents();}
\DoxyCodeLine{12165         m\_stderrDest += m\_stderrFile.getContents();}
\DoxyCodeLine{12166     \}}
\DoxyCodeLine{12167 }
\DoxyCodeLine{12168 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_NEW\_CAPTURE}}
\DoxyCodeLine{12169 }
\DoxyCodeLine{12170 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12171 }
\DoxyCodeLine{12172 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_NEW\_CAPTURE)}}
\DoxyCodeLine{12173 \textcolor{preprocessor}{    \#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12174 \textcolor{preprocessor}{    \#undef dup}}
\DoxyCodeLine{12175 \textcolor{preprocessor}{    \#undef dup2}}
\DoxyCodeLine{12176 \textcolor{preprocessor}{    \#undef fileno}}
\DoxyCodeLine{12177 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{12178 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12179 \textcolor{comment}{// end catch\_output\_redirect.cpp}}
\DoxyCodeLine{12180 \textcolor{comment}{// start catch\_polyfills.cpp}}
\DoxyCodeLine{12181 }
\DoxyCodeLine{12182 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{12183 }
\DoxyCodeLine{12184 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12185 }
\DoxyCodeLine{12186 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_POLYFILL\_ISNAN)}}
\DoxyCodeLine{12187     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12188         \textcolor{keywordflow}{return} std::isnan(f);}
\DoxyCodeLine{12189     \}}
\DoxyCodeLine{12190     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12191         \textcolor{keywordflow}{return} std::isnan(d);}
\DoxyCodeLine{12192     \}}
\DoxyCodeLine{12193 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12194     \textcolor{comment}{// For now we only use this for embarcadero}}
\DoxyCodeLine{12195     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{float} f) \{}
\DoxyCodeLine{12196         \textcolor{keywordflow}{return} std::\_isnan(f);}
\DoxyCodeLine{12197     \}}
\DoxyCodeLine{12198     \textcolor{keywordtype}{bool} isnan(\textcolor{keywordtype}{double} d) \{}
\DoxyCodeLine{12199         \textcolor{keywordflow}{return} std::\_isnan(d);}
\DoxyCodeLine{12200     \}}
\DoxyCodeLine{12201 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12202 }
\DoxyCodeLine{12203 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12204 \textcolor{comment}{// end catch\_polyfills.cpp}}
\DoxyCodeLine{12205 \textcolor{comment}{// start catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12206 }
\DoxyCodeLine{12207 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12208 }
\DoxyCodeLine{12209 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12210 }
\DoxyCodeLine{12211 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12212 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{12213 \textcolor{preprocessor}{\#pragma warning(disable:4146) }\textcolor{comment}{// we negate uint32 during the rotate}}
\DoxyCodeLine{12214 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12215         \textcolor{comment}{// Safe rotr implementation thanks to John Regehr}}
\DoxyCodeLine{12216         uint32\_t rotate\_right(uint32\_t val, uint32\_t count) \{}
\DoxyCodeLine{12217             \textcolor{keyword}{const} uint32\_t mask = 31;}
\DoxyCodeLine{12218             count \&= mask;}
\DoxyCodeLine{12219             \textcolor{keywordflow}{return} (val >> count) | (val << (-\/count \& mask));}
\DoxyCodeLine{12220         \}}
\DoxyCodeLine{12221 }
\DoxyCodeLine{12222 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{12223 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{12224 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12225 }
\DoxyCodeLine{12226 \}}
\DoxyCodeLine{12227 }
\DoxyCodeLine{12228     SimplePcg32::SimplePcg32(result\_type seed\_) \{}
\DoxyCodeLine{12229         seed(seed\_);}
\DoxyCodeLine{12230     \}}
\DoxyCodeLine{12231 }
\DoxyCodeLine{12232     \textcolor{keywordtype}{void} SimplePcg32::seed(result\_type seed\_) \{}
\DoxyCodeLine{12233         m\_state = 0;}
\DoxyCodeLine{12234         (*this)();}
\DoxyCodeLine{12235         m\_state += seed\_;}
\DoxyCodeLine{12236         (*this)();}
\DoxyCodeLine{12237     \}}
\DoxyCodeLine{12238 }
\DoxyCodeLine{12239     \textcolor{keywordtype}{void} SimplePcg32::discard(uint64\_t skip) \{}
\DoxyCodeLine{12240         \textcolor{comment}{// We could implement this to run in O(log n) steps, but this}}
\DoxyCodeLine{12241         \textcolor{comment}{// should suffice for our use case.}}
\DoxyCodeLine{12242         \textcolor{keywordflow}{for} (uint64\_t s = 0; s < skip; ++s) \{}
\DoxyCodeLine{12243             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}((*this)());}
\DoxyCodeLine{12244         \}}
\DoxyCodeLine{12245     \}}
\DoxyCodeLine{12246 }
\DoxyCodeLine{12247     SimplePcg32::result\_type SimplePcg32::operator()() \{}
\DoxyCodeLine{12248         \textcolor{comment}{// prepare the output value}}
\DoxyCodeLine{12249         \textcolor{keyword}{const} uint32\_t xorshifted = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(((m\_state >> 18u) \string^ m\_state) >> 27u);}
\DoxyCodeLine{12250         \textcolor{keyword}{const} \textcolor{keyword}{auto} output = rotate\_right(xorshifted, m\_state >> 59u);}
\DoxyCodeLine{12251 }
\DoxyCodeLine{12252         \textcolor{comment}{// advance state}}
\DoxyCodeLine{12253         m\_state = m\_state * 6364136223846793005ULL + s\_inc;}
\DoxyCodeLine{12254 }
\DoxyCodeLine{12255         \textcolor{keywordflow}{return} output;}
\DoxyCodeLine{12256     \}}
\DoxyCodeLine{12257 }
\DoxyCodeLine{12258     \textcolor{keywordtype}{bool} operator==(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12259         \textcolor{keywordflow}{return} lhs.m\_state == rhs.m\_state;}
\DoxyCodeLine{12260     \}}
\DoxyCodeLine{12261 }
\DoxyCodeLine{12262     \textcolor{keywordtype}{bool} operator!=(SimplePcg32 \textcolor{keyword}{const}\& lhs, SimplePcg32 \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{12263         \textcolor{keywordflow}{return} lhs.m\_state != rhs.m\_state;}
\DoxyCodeLine{12264     \}}
\DoxyCodeLine{12265 \}}
\DoxyCodeLine{12266 \textcolor{comment}{// end catch\_random\_number\_generator.cpp}}
\DoxyCodeLine{12267 \textcolor{comment}{// start catch\_registry\_hub.cpp}}
\DoxyCodeLine{12268 }
\DoxyCodeLine{12269 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12270 }
\DoxyCodeLine{12271 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12272 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{12273 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12274 \textcolor{preprocessor}{\#include <ios>}}
\DoxyCodeLine{12275 }
\DoxyCodeLine{12276 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12277 }
\DoxyCodeLine{12278     \textcolor{keyword}{class }TestCase;}
\DoxyCodeLine{12279     \textcolor{keyword}{struct }IConfig;}
\DoxyCodeLine{12280 }
\DoxyCodeLine{12281     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases );}
\DoxyCodeLine{12282 }
\DoxyCodeLine{12283     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12284     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12285 }
\DoxyCodeLine{12286     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions );}
\DoxyCodeLine{12287 }
\DoxyCodeLine{12288     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12289     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config );}
\DoxyCodeLine{12290 }
\DoxyCodeLine{12291     \textcolor{keyword}{class }TestRegistry : \textcolor{keyword}{public} ITestCaseRegistry \{}
\DoxyCodeLine{12292     \textcolor{keyword}{public}:}
\DoxyCodeLine{12293         \textcolor{keyword}{virtual} \string~TestRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12294 }
\DoxyCodeLine{12295         \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testCase );}
\DoxyCodeLine{12296 }
\DoxyCodeLine{12297         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTests() \textcolor{keyword}{const override};}
\DoxyCodeLine{12298         std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12299 }
\DoxyCodeLine{12300     \textcolor{keyword}{private}:}
\DoxyCodeLine{12301         std::vector<TestCase> m\_functions;}
\DoxyCodeLine{12302         \textcolor{keyword}{mutable} RunTests::InWhatOrder m\_currentSortOrder = RunTests::InDeclarationOrder;}
\DoxyCodeLine{12303         \textcolor{keyword}{mutable} std::vector<TestCase> m\_sortedFunctions;}
\DoxyCodeLine{12304         std::size\_t m\_unnamedCount = 0;}
\DoxyCodeLine{12305         std::ios\_base::Init m\_ostreamInit; \textcolor{comment}{// Forces cout/ cerr to be initialised}}
\DoxyCodeLine{12306     \};}
\DoxyCodeLine{12307 }
\DoxyCodeLine{12309 }
\DoxyCodeLine{12310     \textcolor{keyword}{class }TestInvokerAsFunction : \textcolor{keyword}{public} ITestInvoker \{}
\DoxyCodeLine{12311         void(*m\_testAsFunction)();}
\DoxyCodeLine{12312     \textcolor{keyword}{public}:}
\DoxyCodeLine{12313         TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept;}
\DoxyCodeLine{12314 }
\DoxyCodeLine{12315         \textcolor{keywordtype}{void} invoke() const override;}
\DoxyCodeLine{12316     \};}
\DoxyCodeLine{12317 }
\DoxyCodeLine{12318     std::\textcolor{keywordtype}{string} extractClassName( StringRef const\& classOrQualifiedMethodName );}
\DoxyCodeLine{12319 }
\DoxyCodeLine{12321 }
\DoxyCodeLine{12322 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12323 }
\DoxyCodeLine{12324 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.h}}
\DoxyCodeLine{12325 \textcolor{comment}{// start catch\_reporter\_registry.h}}
\DoxyCodeLine{12326 }
\DoxyCodeLine{12327 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12328 }
\DoxyCodeLine{12329 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12330 }
\DoxyCodeLine{12331     \textcolor{keyword}{class }ReporterRegistry : \textcolor{keyword}{public} IReporterRegistry \{}
\DoxyCodeLine{12332 }
\DoxyCodeLine{12333     \textcolor{keyword}{public}:}
\DoxyCodeLine{12334 }
\DoxyCodeLine{12335         \string~ReporterRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12336 }
\DoxyCodeLine{12337         IStreamingReporterPtr create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12338 }
\DoxyCodeLine{12339         \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12340         \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory );}
\DoxyCodeLine{12341 }
\DoxyCodeLine{12342         FactoryMap \textcolor{keyword}{const}\& getFactories() \textcolor{keyword}{const override};}
\DoxyCodeLine{12343         Listeners \textcolor{keyword}{const}\& getListeners() \textcolor{keyword}{const override};}
\DoxyCodeLine{12344 }
\DoxyCodeLine{12345     \textcolor{keyword}{private}:}
\DoxyCodeLine{12346         FactoryMap m\_factories;}
\DoxyCodeLine{12347         Listeners m\_listeners;}
\DoxyCodeLine{12348     \};}
\DoxyCodeLine{12349 \}}
\DoxyCodeLine{12350 }
\DoxyCodeLine{12351 \textcolor{comment}{// end catch\_reporter\_registry.h}}
\DoxyCodeLine{12352 \textcolor{comment}{// start catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12353 }
\DoxyCodeLine{12354 \textcolor{comment}{// start catch\_tag\_alias.h}}
\DoxyCodeLine{12355 }
\DoxyCodeLine{12356 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{12357 }
\DoxyCodeLine{12358 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12359 }
\DoxyCodeLine{12360     \textcolor{keyword}{struct }TagAlias \{}
\DoxyCodeLine{12361         TagAlias(std::string \textcolor{keyword}{const}\& \_tag, SourceLineInfo \_lineInfo);}
\DoxyCodeLine{12362 }
\DoxyCodeLine{12363         std::string tag;}
\DoxyCodeLine{12364         SourceLineInfo lineInfo;}
\DoxyCodeLine{12365     \};}
\DoxyCodeLine{12366 }
\DoxyCodeLine{12367 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12368 }
\DoxyCodeLine{12369 \textcolor{comment}{// end catch\_tag\_alias.h}}
\DoxyCodeLine{12370 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{12371 }
\DoxyCodeLine{12372 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12373 }
\DoxyCodeLine{12374     \textcolor{keyword}{class }TagAliasRegistry : \textcolor{keyword}{public} ITagAliasRegistry \{}
\DoxyCodeLine{12375     \textcolor{keyword}{public}:}
\DoxyCodeLine{12376         \string~TagAliasRegistry() \textcolor{keyword}{override};}
\DoxyCodeLine{12377         TagAlias \textcolor{keyword}{const}* find( std::string \textcolor{keyword}{const}\& alias ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12378         std::string expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec ) \textcolor{keyword}{const override};}
\DoxyCodeLine{12379         \textcolor{keywordtype}{void} add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo );}
\DoxyCodeLine{12380 }
\DoxyCodeLine{12381     \textcolor{keyword}{private}:}
\DoxyCodeLine{12382         std::map<std::string, TagAlias> m\_registry;}
\DoxyCodeLine{12383     \};}
\DoxyCodeLine{12384 }
\DoxyCodeLine{12385 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12386 }
\DoxyCodeLine{12387 \textcolor{comment}{// end catch\_tag\_alias\_registry.h}}
\DoxyCodeLine{12388 \textcolor{comment}{// start catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12389 }
\DoxyCodeLine{12390 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{12391 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{12392 }
\DoxyCodeLine{12393 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12394 }
\DoxyCodeLine{12395     \textcolor{keyword}{class }StartupExceptionRegistry \{}
\DoxyCodeLine{12396 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12397     \textcolor{keyword}{public}:}
\DoxyCodeLine{12398         \textcolor{keywordtype}{void} add(std::exception\_ptr \textcolor{keyword}{const}\& exception) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{12399         std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& getExceptions() const noexcept;}
\DoxyCodeLine{12400     private:}
\DoxyCodeLine{12401         std::vector<std::exception\_ptr> m\_exceptions;}
\DoxyCodeLine{12402 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12403     \};}
\DoxyCodeLine{12404 }
\DoxyCodeLine{12405 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12406 }
\DoxyCodeLine{12407 \textcolor{comment}{// end catch\_startup\_exception\_registry.h}}
\DoxyCodeLine{12408 \textcolor{comment}{// start catch\_singletons.hpp}}
\DoxyCodeLine{12409 }
\DoxyCodeLine{12410 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12411 }
\DoxyCodeLine{12412     \textcolor{keyword}{struct }ISingleton \{}
\DoxyCodeLine{12413         \textcolor{keyword}{virtual} \string~ISingleton();}
\DoxyCodeLine{12414     \};}
\DoxyCodeLine{12415 }
\DoxyCodeLine{12416     \textcolor{keywordtype}{void} addSingleton( ISingleton* singleton );}
\DoxyCodeLine{12417     \textcolor{keywordtype}{void} cleanupSingletons();}
\DoxyCodeLine{12418 }
\DoxyCodeLine{12419     \textcolor{keyword}{template}<\textcolor{keyword}{typename} SingletonImplT, \textcolor{keyword}{typename} InterfaceT = SingletonImplT, \textcolor{keyword}{typename} MutableInterfaceT = InterfaceT>}
\DoxyCodeLine{12420     \textcolor{keyword}{class }Singleton : SingletonImplT, \textcolor{keyword}{public} ISingleton \{}
\DoxyCodeLine{12421 }
\DoxyCodeLine{12422         \textcolor{keyword}{static} \textcolor{keyword}{auto} getInternal() -\/> Singleton* \{}
\DoxyCodeLine{12423             \textcolor{keyword}{static} Singleton* s\_instance = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12424             \textcolor{keywordflow}{if}( !s\_instance ) \{}
\DoxyCodeLine{12425                 s\_instance = \textcolor{keyword}{new} Singleton;}
\DoxyCodeLine{12426                 addSingleton( s\_instance );}
\DoxyCodeLine{12427             \}}
\DoxyCodeLine{12428             \textcolor{keywordflow}{return} s\_instance;}
\DoxyCodeLine{12429         \}}
\DoxyCodeLine{12430 }
\DoxyCodeLine{12431     \textcolor{keyword}{public}:}
\DoxyCodeLine{12432         \textcolor{keyword}{static} \textcolor{keyword}{auto} get() -\/> InterfaceT \textcolor{keyword}{const}\& \{}
\DoxyCodeLine{12433             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12434         \}}
\DoxyCodeLine{12435         \textcolor{keyword}{static} \textcolor{keyword}{auto} getMutable() -\/> MutableInterfaceT\& \{}
\DoxyCodeLine{12436             \textcolor{keywordflow}{return} *getInternal();}
\DoxyCodeLine{12437         \}}
\DoxyCodeLine{12438     \};}
\DoxyCodeLine{12439 }
\DoxyCodeLine{12440 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{12441 }
\DoxyCodeLine{12442 \textcolor{comment}{// end catch\_singletons.hpp}}
\DoxyCodeLine{12443 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12444 }
\DoxyCodeLine{12445     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{12446 }
\DoxyCodeLine{12447         \textcolor{keyword}{class }RegistryHub : \textcolor{keyword}{public} IRegistryHub, \textcolor{keyword}{public} IMutableRegistryHub,}
\DoxyCodeLine{12448                             \textcolor{keyword}{private} NonCopyable \{}
\DoxyCodeLine{12449 }
\DoxyCodeLine{12450         \textcolor{keyword}{public}: \textcolor{comment}{// IRegistryHub}}
\DoxyCodeLine{12451             RegistryHub() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12452             IReporterRegistry \textcolor{keyword}{const}\& getReporterRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12453                 \textcolor{keywordflow}{return} m\_reporterRegistry;}
\DoxyCodeLine{12454             \}}
\DoxyCodeLine{12455             ITestCaseRegistry \textcolor{keyword}{const}\& getTestCaseRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12456                 \textcolor{keywordflow}{return} m\_testCaseRegistry;}
\DoxyCodeLine{12457             \}}
\DoxyCodeLine{12458             IExceptionTranslatorRegistry \textcolor{keyword}{const}\& getExceptionTranslatorRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12459                 \textcolor{keywordflow}{return} m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12460             \}}
\DoxyCodeLine{12461             ITagAliasRegistry \textcolor{keyword}{const}\& getTagAliasRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12462                 \textcolor{keywordflow}{return} m\_tagAliasRegistry;}
\DoxyCodeLine{12463             \}}
\DoxyCodeLine{12464             StartupExceptionRegistry \textcolor{keyword}{const}\& getStartupExceptionRegistry()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{12465                 \textcolor{keywordflow}{return} m\_exceptionRegistry;}
\DoxyCodeLine{12466             \}}
\DoxyCodeLine{12467 }
\DoxyCodeLine{12468         \textcolor{keyword}{public}: \textcolor{comment}{// IMutableRegistryHub}}
\DoxyCodeLine{12469             \textcolor{keywordtype}{void} registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12470                 m\_reporterRegistry.registerReporter( name, factory );}
\DoxyCodeLine{12471             \}}
\DoxyCodeLine{12472             \textcolor{keywordtype}{void} registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12473                 m\_reporterRegistry.registerListener( factory );}
\DoxyCodeLine{12474             \}}
\DoxyCodeLine{12475             \textcolor{keywordtype}{void} registerTest( TestCase \textcolor{keyword}{const}\& testInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12476                 m\_testCaseRegistry.registerTest( testInfo );}
\DoxyCodeLine{12477             \}}
\DoxyCodeLine{12478             \textcolor{keywordtype}{void} registerTranslator( \textcolor{keyword}{const} IExceptionTranslator* translator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12479                 m\_exceptionTranslatorRegistry.registerTranslator( translator );}
\DoxyCodeLine{12480             \}}
\DoxyCodeLine{12481             \textcolor{keywordtype}{void} registerTagAlias( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12482                 m\_tagAliasRegistry.add( alias, tag, lineInfo );}
\DoxyCodeLine{12483             \}}
\DoxyCodeLine{12484             \textcolor{keywordtype}{void} registerStartupException() noexcept\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12485 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{12486                 m\_exceptionRegistry.add(std::current\_exception());}
\DoxyCodeLine{12487 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12488                 CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Attempted to register active exception under CATCH\_CONFIG\_DISABLE\_EXCEPTIONS!"{}});}
\DoxyCodeLine{12489 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12490             \}}
\DoxyCodeLine{12491             IMutableEnumValuesRegistry\& getMutableEnumValuesRegistry()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12492                 \textcolor{keywordflow}{return} m\_enumValuesRegistry;}
\DoxyCodeLine{12493             \}}
\DoxyCodeLine{12494 }
\DoxyCodeLine{12495         \textcolor{keyword}{private}:}
\DoxyCodeLine{12496             TestRegistry m\_testCaseRegistry;}
\DoxyCodeLine{12497             ReporterRegistry m\_reporterRegistry;}
\DoxyCodeLine{12498             ExceptionTranslatorRegistry m\_exceptionTranslatorRegistry;}
\DoxyCodeLine{12499             TagAliasRegistry m\_tagAliasRegistry;}
\DoxyCodeLine{12500             StartupExceptionRegistry m\_exceptionRegistry;}
\DoxyCodeLine{12501             Detail::EnumValuesRegistry m\_enumValuesRegistry;}
\DoxyCodeLine{12502         \};}
\DoxyCodeLine{12503     \}}
\DoxyCodeLine{12504 }
\DoxyCodeLine{12505     \textcolor{keyword}{using} RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;}
\DoxyCodeLine{12506 }
\DoxyCodeLine{12507     IRegistryHub \textcolor{keyword}{const}\& getRegistryHub() \{}
\DoxyCodeLine{12508         \textcolor{keywordflow}{return} RegistryHubSingleton::get();}
\DoxyCodeLine{12509     \}}
\DoxyCodeLine{12510     IMutableRegistryHub\& getMutableRegistryHub() \{}
\DoxyCodeLine{12511         \textcolor{keywordflow}{return} RegistryHubSingleton::getMutable();}
\DoxyCodeLine{12512     \}}
\DoxyCodeLine{12513     \textcolor{keywordtype}{void} cleanUp() \{}
\DoxyCodeLine{12514         cleanupSingletons();}
\DoxyCodeLine{12515         cleanUpContext();}
\DoxyCodeLine{12516     \}}
\DoxyCodeLine{12517     std::string translateActiveException() \{}
\DoxyCodeLine{12518         \textcolor{keywordflow}{return} getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();}
\DoxyCodeLine{12519     \}}
\DoxyCodeLine{12520 }
\DoxyCodeLine{12521 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12522 \textcolor{comment}{// end catch\_registry\_hub.cpp}}
\DoxyCodeLine{12523 \textcolor{comment}{// start catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12524 }
\DoxyCodeLine{12525 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12526 }
\DoxyCodeLine{12527     ReporterRegistry::\string~ReporterRegistry() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{12528 }
\DoxyCodeLine{12529     IStreamingReporterPtr ReporterRegistry::create( std::string \textcolor{keyword}{const}\& name, IConfigPtr \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12530         \textcolor{keyword}{auto} it =  m\_factories.find( name );}
\DoxyCodeLine{12531         \textcolor{keywordflow}{if}( it == m\_factories.end() )}
\DoxyCodeLine{12532             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12533         \textcolor{keywordflow}{return} it-\/>second-\/>create( ReporterConfig( config ) );}
\DoxyCodeLine{12534     \}}
\DoxyCodeLine{12535 }
\DoxyCodeLine{12536     \textcolor{keywordtype}{void} ReporterRegistry::registerReporter( std::string \textcolor{keyword}{const}\& name, IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12537         m\_factories.emplace(name, factory);}
\DoxyCodeLine{12538     \}}
\DoxyCodeLine{12539     \textcolor{keywordtype}{void} ReporterRegistry::registerListener( IReporterFactoryPtr \textcolor{keyword}{const}\& factory ) \{}
\DoxyCodeLine{12540         m\_listeners.push\_back( factory );}
\DoxyCodeLine{12541     \}}
\DoxyCodeLine{12542 }
\DoxyCodeLine{12543     IReporterRegistry::FactoryMap \textcolor{keyword}{const}\& ReporterRegistry::getFactories()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12544         \textcolor{keywordflow}{return} m\_factories;}
\DoxyCodeLine{12545     \}}
\DoxyCodeLine{12546     IReporterRegistry::Listeners \textcolor{keyword}{const}\& ReporterRegistry::getListeners()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12547         \textcolor{keywordflow}{return} m\_listeners;}
\DoxyCodeLine{12548     \}}
\DoxyCodeLine{12549 }
\DoxyCodeLine{12550 \}}
\DoxyCodeLine{12551 \textcolor{comment}{// end catch\_reporter\_registry.cpp}}
\DoxyCodeLine{12552 \textcolor{comment}{// start catch\_result\_type.cpp}}
\DoxyCodeLine{12553 }
\DoxyCodeLine{12554 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12555 }
\DoxyCodeLine{12556     \textcolor{keywordtype}{bool} isOk( ResultWas::OfType resultType ) \{}
\DoxyCodeLine{12557         \textcolor{keywordflow}{return} ( resultType \& ResultWas::FailureBit ) == 0;}
\DoxyCodeLine{12558     \}}
\DoxyCodeLine{12559     \textcolor{keywordtype}{bool} isJustInfo( \textcolor{keywordtype}{int} flags ) \{}
\DoxyCodeLine{12560         \textcolor{keywordflow}{return} flags == ResultWas::Info;}
\DoxyCodeLine{12561     \}}
\DoxyCodeLine{12562 }
\DoxyCodeLine{12563     ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) \{}
\DoxyCodeLine{12564         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}ResultDisposition::Flags\textcolor{keyword}{>}( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( lhs ) | \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( rhs ) );}
\DoxyCodeLine{12565     \}}
\DoxyCodeLine{12566 }
\DoxyCodeLine{12567     \textcolor{keywordtype}{bool} shouldContinueOnFailure( \textcolor{keywordtype}{int} flags )    \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::ContinueOnFailure ) != 0; \}}
\DoxyCodeLine{12568     \textcolor{keywordtype}{bool} shouldSuppressFailure( \textcolor{keywordtype}{int} flags )      \{ \textcolor{keywordflow}{return} ( flags \& ResultDisposition::SuppressFail ) != 0; \}}
\DoxyCodeLine{12569 }
\DoxyCodeLine{12570 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{12571 \textcolor{comment}{// end catch\_result\_type.cpp}}
\DoxyCodeLine{12572 \textcolor{comment}{// start catch\_run\_context.cpp}}
\DoxyCodeLine{12573 }
\DoxyCodeLine{12574 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{12575 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12576 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{12577 }
\DoxyCodeLine{12578 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{12579 }
\DoxyCodeLine{12580     \textcolor{keyword}{namespace }Generators \{}
\DoxyCodeLine{12581         \textcolor{keyword}{struct }GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker \{}
\DoxyCodeLine{12582             GeneratorBasePtr m\_generator;}
\DoxyCodeLine{12583 }
\DoxyCodeLine{12584             GeneratorTracker( TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{12585             :   TrackerBase( nameAndLocation, ctx, parent )}
\DoxyCodeLine{12586             \{\}}
\DoxyCodeLine{12587             \string~GeneratorTracker();}
\DoxyCodeLine{12588 }
\DoxyCodeLine{12589             \textcolor{keyword}{static} GeneratorTracker\& acquire( TrackerContext\& ctx, TestCaseTracking::NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{12590                 std::shared\_ptr<GeneratorTracker> tracker;}
\DoxyCodeLine{12591 }
\DoxyCodeLine{12592                 ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{12593                 \textcolor{comment}{// Under specific circumstances, the generator we want}}
\DoxyCodeLine{12594                 \textcolor{comment}{// to acquire is also the current tracker. If this is}}
\DoxyCodeLine{12595                 \textcolor{comment}{// the case, we have to avoid looking through current}}
\DoxyCodeLine{12596                 \textcolor{comment}{// tracker's children, and instead return the current}}
\DoxyCodeLine{12597                 \textcolor{comment}{// tracker.}}
\DoxyCodeLine{12598                 \textcolor{comment}{// A case where this check is important is e.g.}}
\DoxyCodeLine{12599                 \textcolor{comment}{//     for (int i = 0; i < 5; ++i) \{}}
\DoxyCodeLine{12600                 \textcolor{comment}{//         int n = GENERATE(1, 2);}}
\DoxyCodeLine{12601                 \textcolor{comment}{//     \}}}
\DoxyCodeLine{12602                 \textcolor{comment}{//}}
\DoxyCodeLine{12603                 \textcolor{comment}{// without it, the code above creates 5 nested generators.}}
\DoxyCodeLine{12604                 \textcolor{keywordflow}{if} (currentTracker.nameAndLocation() == nameAndLocation) \{}
\DoxyCodeLine{12605                     \textcolor{keyword}{auto} thisTracker = currentTracker.parent().findChild(nameAndLocation);}
\DoxyCodeLine{12606                     assert(thisTracker);}
\DoxyCodeLine{12607                     assert(thisTracker-\/>isGeneratorTracker());}
\DoxyCodeLine{12608                     tracker = std::static\_pointer\_cast<GeneratorTracker>(thisTracker);}
\DoxyCodeLine{12609                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{12610                     assert( childTracker );}
\DoxyCodeLine{12611                     assert( childTracker-\/>isGeneratorTracker() );}
\DoxyCodeLine{12612                     tracker = std::static\_pointer\_cast<GeneratorTracker>( childTracker );}
\DoxyCodeLine{12613                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12614                     tracker = std::make\_shared<GeneratorTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{12615                     currentTracker.addChild( tracker );}
\DoxyCodeLine{12616                 \}}
\DoxyCodeLine{12617 }
\DoxyCodeLine{12618                 \textcolor{keywordflow}{if}( !tracker-\/>isComplete() ) \{}
\DoxyCodeLine{12619                     tracker-\/>open();}
\DoxyCodeLine{12620                 \}}
\DoxyCodeLine{12621 }
\DoxyCodeLine{12622                 \textcolor{keywordflow}{return} *tracker;}
\DoxyCodeLine{12623             \}}
\DoxyCodeLine{12624 }
\DoxyCodeLine{12625             \textcolor{comment}{// TrackerBase interface}}
\DoxyCodeLine{12626             \textcolor{keywordtype}{bool} isGeneratorTracker()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{12627             \textcolor{keyword}{auto} hasGenerator() const -\/> \textcolor{keywordtype}{bool}\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12628                 \textcolor{keywordflow}{return} !!m\_generator;}
\DoxyCodeLine{12629             \}}
\DoxyCodeLine{12630             \textcolor{keywordtype}{void} close()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12631                 TrackerBase::close();}
\DoxyCodeLine{12632                 \textcolor{comment}{// If a generator has a child (it is followed by a section)}}
\DoxyCodeLine{12633                 \textcolor{comment}{// and none of its children have started, then we must wait}}
\DoxyCodeLine{12634                 \textcolor{comment}{// until later to start consuming its values.}}
\DoxyCodeLine{12635                 \textcolor{comment}{// This catches cases where `GENERATE` is placed between two}}
\DoxyCodeLine{12636                 \textcolor{comment}{// `SECTION`s.}}
\DoxyCodeLine{12637                 \textcolor{comment}{// **The check for m\_children.empty cannot be removed**.}}
\DoxyCodeLine{12638                 \textcolor{comment}{// doing so would break `GENERATE` \_not\_ followed by `SECTION`s.}}
\DoxyCodeLine{12639                 \textcolor{keyword}{const} \textcolor{keywordtype}{bool} should\_wait\_for\_child = [\&]() \{}
\DoxyCodeLine{12640                     \textcolor{comment}{// No children -\/> nobody to wait for}}
\DoxyCodeLine{12641                     \textcolor{keywordflow}{if} ( m\_children.empty() ) \{}
\DoxyCodeLine{12642                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12643                     \}}
\DoxyCodeLine{12644                     \textcolor{comment}{// If at least one child started executing, don't wait}}
\DoxyCodeLine{12645                     \textcolor{keywordflow}{if} ( std::find\_if(}
\DoxyCodeLine{12646                              m\_children.begin(),}
\DoxyCodeLine{12647                              m\_children.end(),}
\DoxyCodeLine{12648                              []( TestCaseTracking::ITrackerPtr tracker ) \{}
\DoxyCodeLine{12649                                  return tracker-\/>hasStarted();}
\DoxyCodeLine{12650                              \} ) != m\_children.end() ) \{}
\DoxyCodeLine{12651                         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12652                     \}}
\DoxyCodeLine{12653 }
\DoxyCodeLine{12654                     \textcolor{comment}{// No children have started. We need to check if they \_can\_}}
\DoxyCodeLine{12655                     \textcolor{comment}{// start, and thus we should wait for them, or they cannot}}
\DoxyCodeLine{12656                     \textcolor{comment}{// start (due to filters), and we shouldn't wait for them}}
\DoxyCodeLine{12657                     \textcolor{keyword}{auto}* parent = m\_parent;}
\DoxyCodeLine{12658                     \textcolor{comment}{// This is safe: there is always at least one section}}
\DoxyCodeLine{12659                     \textcolor{comment}{// tracker in a test case tracking tree}}
\DoxyCodeLine{12660                     \textcolor{keywordflow}{while} ( !parent-\/>isSectionTracker() ) \{}
\DoxyCodeLine{12661                         parent = \&( parent-\/>parent() );}
\DoxyCodeLine{12662                     \}}
\DoxyCodeLine{12663                     assert( parent \&\&}
\DoxyCodeLine{12664                             \textcolor{stringliteral}{"{}Missing root (test case) level section"{}} );}
\DoxyCodeLine{12665 }
\DoxyCodeLine{12666                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& parentSection =}
\DoxyCodeLine{12667                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{12668                     \textcolor{keyword}{auto} \textcolor{keyword}{const}\& filters = parentSection.getFilters();}
\DoxyCodeLine{12669                     \textcolor{comment}{// No filters -\/> no restrictions on running sections}}
\DoxyCodeLine{12670                     \textcolor{keywordflow}{if} ( filters.empty() ) \{}
\DoxyCodeLine{12671                         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12672                     \}}
\DoxyCodeLine{12673 }
\DoxyCodeLine{12674                     \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : m\_children ) \{}
\DoxyCodeLine{12675                         \textcolor{keywordflow}{if} ( child-\/>isSectionTracker() \&\&}
\DoxyCodeLine{12676                              std::find( filters.begin(),}
\DoxyCodeLine{12677                                         filters.end(),}
\DoxyCodeLine{12678                                         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *child )}
\DoxyCodeLine{12679                                             .trimmedName() ) !=}
\DoxyCodeLine{12680                                  filters.end() ) \{}
\DoxyCodeLine{12681                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12682                         \}}
\DoxyCodeLine{12683                     \}}
\DoxyCodeLine{12684                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12685                 \}();}
\DoxyCodeLine{12686 }
\DoxyCodeLine{12687                 \textcolor{comment}{// This check is a bit tricky, because m\_generator-\/>next()}}
\DoxyCodeLine{12688                 \textcolor{comment}{// has a side-\/effect, where it consumes generator's current}}
\DoxyCodeLine{12689                 \textcolor{comment}{// value, but we do not want to invoke the side-\/effect if}}
\DoxyCodeLine{12690                 \textcolor{comment}{// this generator is still waiting for any child to start.}}
\DoxyCodeLine{12691                 \textcolor{keywordflow}{if} ( should\_wait\_for\_child ||}
\DoxyCodeLine{12692                      ( m\_runState == CompletedSuccessfully \&\&}
\DoxyCodeLine{12693                        m\_generator-\/>next() ) ) \{}
\DoxyCodeLine{12694                     m\_children.clear();}
\DoxyCodeLine{12695                     m\_runState = Executing;}
\DoxyCodeLine{12696                 \}}
\DoxyCodeLine{12697             \}}
\DoxyCodeLine{12698 }
\DoxyCodeLine{12699             \textcolor{comment}{// IGeneratorTracker interface}}
\DoxyCodeLine{12700             \textcolor{keyword}{auto} getGenerator() const -\/> GeneratorBasePtr const\&\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12701                 \textcolor{keywordflow}{return} m\_generator;}
\DoxyCodeLine{12702             \}}
\DoxyCodeLine{12703             \textcolor{keywordtype}{void} setGenerator( GeneratorBasePtr\&\& generator )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{12704                 m\_generator = std::move( generator );}
\DoxyCodeLine{12705             \}}
\DoxyCodeLine{12706         \};}
\DoxyCodeLine{12707         GeneratorTracker::\string~GeneratorTracker() \{\}}
\DoxyCodeLine{12708     \}}
\DoxyCodeLine{12709 }
\DoxyCodeLine{12710     RunContext::RunContext(IConfigPtr \textcolor{keyword}{const}\& \_config, IStreamingReporterPtr\&\& reporter)}
\DoxyCodeLine{12711     :   m\_runInfo(\_config-\/>name()),}
\DoxyCodeLine{12712         m\_context(getCurrentMutableContext()),}
\DoxyCodeLine{12713         m\_config(\_config),}
\DoxyCodeLine{12714         m\_reporter(std::move(reporter)),}
\DoxyCodeLine{12715         m\_lastAssertionInfo\{ StringRef(), SourceLineInfo(\textcolor{stringliteral}{"{}"{}},0), StringRef(), ResultDisposition::Normal \},}
\DoxyCodeLine{12716         m\_includeSuccessfulResults( m\_config-\/>includeSuccessfulResults() || m\_reporter-\/>getPreferences().shouldReportAllAssertions )}
\DoxyCodeLine{12717     \{}
\DoxyCodeLine{12718         m\_context.setRunner(\textcolor{keyword}{this});}
\DoxyCodeLine{12719         m\_context.setConfig(m\_config);}
\DoxyCodeLine{12720         m\_context.setResultCapture(\textcolor{keyword}{this});}
\DoxyCodeLine{12721         m\_reporter-\/>testRunStarting(m\_runInfo);}
\DoxyCodeLine{12722     \}}
\DoxyCodeLine{12723 }
\DoxyCodeLine{12724     RunContext::\string~RunContext() \{}
\DoxyCodeLine{12725         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, aborting()));}
\DoxyCodeLine{12726     \}}
\DoxyCodeLine{12727 }
\DoxyCodeLine{12728     \textcolor{keywordtype}{void} RunContext::testGroupStarting(std::string \textcolor{keyword}{const}\& testSpec, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12729         m\_reporter-\/>testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));}
\DoxyCodeLine{12730     \}}
\DoxyCodeLine{12731 }
\DoxyCodeLine{12732     \textcolor{keywordtype}{void} RunContext::testGroupEnded(std::string \textcolor{keyword}{const}\& testSpec, Totals \textcolor{keyword}{const}\& totals, std::size\_t groupIndex, std::size\_t groupsCount) \{}
\DoxyCodeLine{12733         m\_reporter-\/>testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));}
\DoxyCodeLine{12734     \}}
\DoxyCodeLine{12735 }
\DoxyCodeLine{12736     Totals RunContext::runTest(TestCase \textcolor{keyword}{const}\& testCase) \{}
\DoxyCodeLine{12737         Totals prevTotals = m\_totals;}
\DoxyCodeLine{12738 }
\DoxyCodeLine{12739         std::string redirectedCout;}
\DoxyCodeLine{12740         std::string redirectedCerr;}
\DoxyCodeLine{12741 }
\DoxyCodeLine{12742         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = testCase.getTestCaseInfo();}
\DoxyCodeLine{12743 }
\DoxyCodeLine{12744         m\_reporter-\/>testCaseStarting(testInfo);}
\DoxyCodeLine{12745 }
\DoxyCodeLine{12746         m\_activeTestCase = \&testCase;}
\DoxyCodeLine{12747 }
\DoxyCodeLine{12748         ITracker\& rootTracker = m\_trackerContext.startRun();}
\DoxyCodeLine{12749         assert(rootTracker.isSectionTracker());}
\DoxyCodeLine{12750         \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}(rootTracker).addInitialFilters(m\_config-\/>getSectionsToRun());}
\DoxyCodeLine{12751         \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{12752             m\_trackerContext.startCycle();}
\DoxyCodeLine{12753             m\_testCaseTracker = \&SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));}
\DoxyCodeLine{12754             runCurrentTest(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12755         \} \textcolor{keywordflow}{while} (!m\_testCaseTracker-\/>isSuccessfullyCompleted() \&\& !aborting());}
\DoxyCodeLine{12756 }
\DoxyCodeLine{12757         Totals deltaTotals = m\_totals.delta(prevTotals);}
\DoxyCodeLine{12758         \textcolor{keywordflow}{if} (testInfo.expectedToFail() \&\& deltaTotals.testCases.passed > 0) \{}
\DoxyCodeLine{12759             deltaTotals.assertions.failed++;}
\DoxyCodeLine{12760             deltaTotals.testCases.passed-\/-\/;}
\DoxyCodeLine{12761             deltaTotals.testCases.failed++;}
\DoxyCodeLine{12762         \}}
\DoxyCodeLine{12763         m\_totals.testCases += deltaTotals.testCases;}
\DoxyCodeLine{12764         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12765                                   deltaTotals,}
\DoxyCodeLine{12766                                   redirectedCout,}
\DoxyCodeLine{12767                                   redirectedCerr,}
\DoxyCodeLine{12768                                   aborting()));}
\DoxyCodeLine{12769 }
\DoxyCodeLine{12770         m\_activeTestCase = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12771         m\_testCaseTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{12772 }
\DoxyCodeLine{12773         \textcolor{keywordflow}{return} deltaTotals;}
\DoxyCodeLine{12774     \}}
\DoxyCodeLine{12775 }
\DoxyCodeLine{12776     IConfigPtr RunContext::config()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12777         \textcolor{keywordflow}{return} m\_config;}
\DoxyCodeLine{12778     \}}
\DoxyCodeLine{12779 }
\DoxyCodeLine{12780     IStreamingReporter\& RunContext::reporter()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12781         \textcolor{keywordflow}{return} *m\_reporter;}
\DoxyCodeLine{12782     \}}
\DoxyCodeLine{12783 }
\DoxyCodeLine{12784     \textcolor{keywordtype}{void} RunContext::assertionEnded(AssertionResult \textcolor{keyword}{const} \& result) \{}
\DoxyCodeLine{12785         \textcolor{keywordflow}{if} (result.getResultType() == ResultWas::Ok) \{}
\DoxyCodeLine{12786             m\_totals.assertions.passed++;}
\DoxyCodeLine{12787             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12788         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!result.isOk()) \{}
\DoxyCodeLine{12789             m\_lastAssertionPassed = \textcolor{keyword}{false};}
\DoxyCodeLine{12790             \textcolor{keywordflow}{if}( m\_activeTestCase-\/>getTestCaseInfo().okToFail() )}
\DoxyCodeLine{12791                 m\_totals.assertions.failedButOk++;}
\DoxyCodeLine{12792             \textcolor{keywordflow}{else}}
\DoxyCodeLine{12793                 m\_totals.assertions.failed++;}
\DoxyCodeLine{12794         \}}
\DoxyCodeLine{12795         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12796             m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12797         \}}
\DoxyCodeLine{12798 }
\DoxyCodeLine{12799         \textcolor{comment}{// We have no use for the return value (whether messages should be cleared), because messages were made scoped}}
\DoxyCodeLine{12800         \textcolor{comment}{// and should be let to clear themselves out.}}
\DoxyCodeLine{12801         \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(m\_reporter-\/>assertionEnded(AssertionStats(result, m\_messages, m\_totals)));}
\DoxyCodeLine{12802 }
\DoxyCodeLine{12803         \textcolor{keywordflow}{if} (result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{12804             m\_messageScopes.clear();}
\DoxyCodeLine{12805 }
\DoxyCodeLine{12806         \textcolor{comment}{// Reset working state}}
\DoxyCodeLine{12807         resetAssertionInfo();}
\DoxyCodeLine{12808         m\_lastResult = result;}
\DoxyCodeLine{12809     \}}
\DoxyCodeLine{12810     \textcolor{keywordtype}{void} RunContext::resetAssertionInfo() \{}
\DoxyCodeLine{12811         m\_lastAssertionInfo.macroName = StringRef();}
\DoxyCodeLine{12812         m\_lastAssertionInfo.capturedExpression = \textcolor{stringliteral}{"{}\{Unknown expression after the reported line\}"{}}\_sr;}
\DoxyCodeLine{12813     \}}
\DoxyCodeLine{12814 }
\DoxyCodeLine{12815     \textcolor{keywordtype}{bool} RunContext::sectionStarted(SectionInfo \textcolor{keyword}{const} \& sectionInfo, Counts \& assertions) \{}
\DoxyCodeLine{12816         ITracker\& sectionTracker = SectionTracker::acquire(m\_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));}
\DoxyCodeLine{12817         \textcolor{keywordflow}{if} (!sectionTracker.isOpen())}
\DoxyCodeLine{12818             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12819         m\_activeSections.push\_back(\&sectionTracker);}
\DoxyCodeLine{12820 }
\DoxyCodeLine{12821         m\_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;}
\DoxyCodeLine{12822 }
\DoxyCodeLine{12823         m\_reporter-\/>sectionStarting(sectionInfo);}
\DoxyCodeLine{12824 }
\DoxyCodeLine{12825         assertions = m\_totals.assertions;}
\DoxyCodeLine{12826 }
\DoxyCodeLine{12827         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12828     \}}
\DoxyCodeLine{12829     \textcolor{keyword}{auto} RunContext::acquireGeneratorTracker( StringRef generatorName, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) -\/> IGeneratorTracker\& \{}
\DoxyCodeLine{12830         \textcolor{keyword}{using namespace }Generators;}
\DoxyCodeLine{12831         GeneratorTracker\& tracker = GeneratorTracker::acquire(m\_trackerContext,}
\DoxyCodeLine{12832                                                               TestCaseTracking::NameAndLocation( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(generatorName), lineInfo ) );}
\DoxyCodeLine{12833         m\_lastAssertionInfo.lineInfo = lineInfo;}
\DoxyCodeLine{12834         \textcolor{keywordflow}{return} tracker;}
\DoxyCodeLine{12835     \}}
\DoxyCodeLine{12836 }
\DoxyCodeLine{12837     \textcolor{keywordtype}{bool} RunContext::testForMissingAssertions(Counts\& assertions) \{}
\DoxyCodeLine{12838         \textcolor{keywordflow}{if} (assertions.total() != 0)}
\DoxyCodeLine{12839             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12840         \textcolor{keywordflow}{if} (!m\_config-\/>warnAboutMissingAssertions())}
\DoxyCodeLine{12841             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12842         \textcolor{keywordflow}{if} (m\_trackerContext.currentTracker().hasChildren())}
\DoxyCodeLine{12843             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{12844         m\_totals.assertions.failed++;}
\DoxyCodeLine{12845         assertions.failed++;}
\DoxyCodeLine{12846         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{12847     \}}
\DoxyCodeLine{12848 }
\DoxyCodeLine{12849     \textcolor{keywordtype}{void} RunContext::sectionEnded(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12850         Counts assertions = m\_totals.assertions -\/ endInfo.prevAssertions;}
\DoxyCodeLine{12851         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{12852 }
\DoxyCodeLine{12853         \textcolor{keywordflow}{if} (!m\_activeSections.empty()) \{}
\DoxyCodeLine{12854             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12855             m\_activeSections.pop\_back();}
\DoxyCodeLine{12856         \}}
\DoxyCodeLine{12857 }
\DoxyCodeLine{12858         m\_reporter-\/>sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));}
\DoxyCodeLine{12859         m\_messages.clear();}
\DoxyCodeLine{12860         m\_messageScopes.clear();}
\DoxyCodeLine{12861     \}}
\DoxyCodeLine{12862 }
\DoxyCodeLine{12863     \textcolor{keywordtype}{void} RunContext::sectionEndedEarly(SectionEndInfo \textcolor{keyword}{const} \& endInfo) \{}
\DoxyCodeLine{12864         \textcolor{keywordflow}{if} (m\_unfinishedSections.empty())}
\DoxyCodeLine{12865             m\_activeSections.back()-\/>fail();}
\DoxyCodeLine{12866         \textcolor{keywordflow}{else}}
\DoxyCodeLine{12867             m\_activeSections.back()-\/>close();}
\DoxyCodeLine{12868         m\_activeSections.pop\_back();}
\DoxyCodeLine{12869 }
\DoxyCodeLine{12870         m\_unfinishedSections.push\_back(endInfo);}
\DoxyCodeLine{12871     \}}
\DoxyCodeLine{12872 }
\DoxyCodeLine{12873 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{12874     \textcolor{keywordtype}{void} RunContext::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{12875         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{12876     \}}
\DoxyCodeLine{12877     \textcolor{keywordtype}{void} RunContext::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& info ) \{}
\DoxyCodeLine{12878         m\_reporter-\/>benchmarkStarting( info );}
\DoxyCodeLine{12879     \}}
\DoxyCodeLine{12880     \textcolor{keywordtype}{void} RunContext::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{12881         m\_reporter-\/>benchmarkEnded( stats );}
\DoxyCodeLine{12882     \}}
\DoxyCodeLine{12883     \textcolor{keywordtype}{void} RunContext::benchmarkFailed(std::string \textcolor{keyword}{const} \& error) \{}
\DoxyCodeLine{12884         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{12885     \}}
\DoxyCodeLine{12886 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{12887 }
\DoxyCodeLine{12888     \textcolor{keywordtype}{void} RunContext::pushScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12889         m\_messages.push\_back(message);}
\DoxyCodeLine{12890     \}}
\DoxyCodeLine{12891 }
\DoxyCodeLine{12892     \textcolor{keywordtype}{void} RunContext::popScopedMessage(MessageInfo \textcolor{keyword}{const} \& message) \{}
\DoxyCodeLine{12893         m\_messages.erase(std::remove(m\_messages.begin(), m\_messages.end(), message), m\_messages.end());}
\DoxyCodeLine{12894     \}}
\DoxyCodeLine{12895 }
\DoxyCodeLine{12896     \textcolor{keywordtype}{void} RunContext::emplaceUnscopedMessage( MessageBuilder \textcolor{keyword}{const}\& builder ) \{}
\DoxyCodeLine{12897         m\_messageScopes.emplace\_back( builder );}
\DoxyCodeLine{12898     \}}
\DoxyCodeLine{12899 }
\DoxyCodeLine{12900     std::string RunContext::getCurrentTestName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12901         \textcolor{keywordflow}{return} m\_activeTestCase}
\DoxyCodeLine{12902             ? m\_activeTestCase-\/>getTestCaseInfo().name}
\DoxyCodeLine{12903             : std::string();}
\DoxyCodeLine{12904     \}}
\DoxyCodeLine{12905 }
\DoxyCodeLine{12906     \textcolor{keyword}{const} AssertionResult * RunContext::getLastResult()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12907         \textcolor{keywordflow}{return} \&(*m\_lastResult);}
\DoxyCodeLine{12908     \}}
\DoxyCodeLine{12909 }
\DoxyCodeLine{12910     \textcolor{keywordtype}{void} RunContext::exceptionEarlyReported() \{}
\DoxyCodeLine{12911         m\_shouldReportUnexpected = \textcolor{keyword}{false};}
\DoxyCodeLine{12912     \}}
\DoxyCodeLine{12913 }
\DoxyCodeLine{12914     \textcolor{keywordtype}{void} RunContext::handleFatalErrorCondition( StringRef message ) \{}
\DoxyCodeLine{12915         \textcolor{comment}{// First notify reporter that bad things happened}}
\DoxyCodeLine{12916         m\_reporter-\/>fatalErrorEncountered(message);}
\DoxyCodeLine{12917 }
\DoxyCodeLine{12918         \textcolor{comment}{// Don't rebuild the result -\/-\/ the stringification itself can cause more fatal errors}}
\DoxyCodeLine{12919         \textcolor{comment}{// Instead, fake a result data.}}
\DoxyCodeLine{12920         AssertionResultData tempResult( ResultWas::FatalErrorCondition, \{ \textcolor{keyword}{false} \} );}
\DoxyCodeLine{12921         tempResult.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{12922         AssertionResult result(m\_lastAssertionInfo, tempResult);}
\DoxyCodeLine{12923 }
\DoxyCodeLine{12924         assertionEnded(result);}
\DoxyCodeLine{12925 }
\DoxyCodeLine{12926         handleUnfinishedSections();}
\DoxyCodeLine{12927 }
\DoxyCodeLine{12928         \textcolor{comment}{// Recreate section for test case (as we will lose the one that was in scope)}}
\DoxyCodeLine{12929         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12930         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12931 }
\DoxyCodeLine{12932         Counts assertions;}
\DoxyCodeLine{12933         assertions.failed = 1;}
\DoxyCodeLine{12934         SectionStats testCaseSectionStats(testCaseSection, assertions, 0, \textcolor{keyword}{false});}
\DoxyCodeLine{12935         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{12936 }
\DoxyCodeLine{12937         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12938 }
\DoxyCodeLine{12939         Totals deltaTotals;}
\DoxyCodeLine{12940         deltaTotals.testCases.failed = 1;}
\DoxyCodeLine{12941         deltaTotals.assertions.failed = 1;}
\DoxyCodeLine{12942         m\_reporter-\/>testCaseEnded(TestCaseStats(testInfo,}
\DoxyCodeLine{12943                                   deltaTotals,}
\DoxyCodeLine{12944                                   std::string(),}
\DoxyCodeLine{12945                                   std::string(),}
\DoxyCodeLine{12946                                   \textcolor{keyword}{false}));}
\DoxyCodeLine{12947         m\_totals.testCases.failed++;}
\DoxyCodeLine{12948         testGroupEnded(std::string(), m\_totals, 1, 1);}
\DoxyCodeLine{12949         m\_reporter-\/>testRunEnded(TestRunStats(m\_runInfo, m\_totals, \textcolor{keyword}{false}));}
\DoxyCodeLine{12950     \}}
\DoxyCodeLine{12951 }
\DoxyCodeLine{12952     \textcolor{keywordtype}{bool} RunContext::lastAssertionPassed() \{}
\DoxyCodeLine{12953          \textcolor{keywordflow}{return} m\_lastAssertionPassed;}
\DoxyCodeLine{12954     \}}
\DoxyCodeLine{12955 }
\DoxyCodeLine{12956     \textcolor{keywordtype}{void} RunContext::assertionPassed() \{}
\DoxyCodeLine{12957         m\_lastAssertionPassed = \textcolor{keyword}{true};}
\DoxyCodeLine{12958         ++m\_totals.assertions.passed;}
\DoxyCodeLine{12959         resetAssertionInfo();}
\DoxyCodeLine{12960         m\_messageScopes.clear();}
\DoxyCodeLine{12961     \}}
\DoxyCodeLine{12962 }
\DoxyCodeLine{12963     \textcolor{keywordtype}{bool} RunContext::aborting()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{12964         \textcolor{keywordflow}{return} m\_totals.assertions.failed >= \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_config-\/>abortAfter());}
\DoxyCodeLine{12965     \}}
\DoxyCodeLine{12966 }
\DoxyCodeLine{12967     \textcolor{keywordtype}{void} RunContext::runCurrentTest(std::string \& redirectedCout, std::string \& redirectedCerr) \{}
\DoxyCodeLine{12968         \textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCaseInfo = m\_activeTestCase-\/>getTestCaseInfo();}
\DoxyCodeLine{12969         SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);}
\DoxyCodeLine{12970         m\_reporter-\/>sectionStarting(testCaseSection);}
\DoxyCodeLine{12971         Counts prevAssertions = m\_totals.assertions;}
\DoxyCodeLine{12972         \textcolor{keywordtype}{double} duration = 0;}
\DoxyCodeLine{12973         m\_shouldReportUnexpected = \textcolor{keyword}{true};}
\DoxyCodeLine{12974         m\_lastAssertionInfo = \{ \textcolor{stringliteral}{"{}TEST\_CASE"{}}\_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal \};}
\DoxyCodeLine{12975 }
\DoxyCodeLine{12976         seedRng(*m\_config);}
\DoxyCodeLine{12977 }
\DoxyCodeLine{12978         Timer timer;}
\DoxyCodeLine{12979         CATCH\_TRY \{}
\DoxyCodeLine{12980             \textcolor{keywordflow}{if} (m\_reporter-\/>getPreferences().shouldRedirectStdOut) \{}
\DoxyCodeLine{12981 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_EXPERIMENTAL\_REDIRECT)}}
\DoxyCodeLine{12982                 RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12983 }
\DoxyCodeLine{12984                 timer.start();}
\DoxyCodeLine{12985                 invokeActiveTestCase();}
\DoxyCodeLine{12986 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{12987                 OutputRedirect r(redirectedCout, redirectedCerr);}
\DoxyCodeLine{12988                 timer.start();}
\DoxyCodeLine{12989                 invokeActiveTestCase();}
\DoxyCodeLine{12990 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{12991             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{12992                 timer.start();}
\DoxyCodeLine{12993                 invokeActiveTestCase();}
\DoxyCodeLine{12994             \}}
\DoxyCodeLine{12995             duration = timer.getElapsedSeconds();}
\DoxyCodeLine{12996         \} CATCH\_CATCH\_ANON (TestFailureException\&) \{}
\DoxyCodeLine{12997             \textcolor{comment}{// This just means the test was aborted due to failure}}
\DoxyCodeLine{12998         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{12999             \textcolor{comment}{// Under CATCH\_CONFIG\_FAST\_COMPILE, unexpected exceptions under REQUIRE assertions}}
\DoxyCodeLine{13000             \textcolor{comment}{// are reported without translation at the point of origin.}}
\DoxyCodeLine{13001             \textcolor{keywordflow}{if}( m\_shouldReportUnexpected ) \{}
\DoxyCodeLine{13002                 AssertionReaction dummyReaction;}
\DoxyCodeLine{13003                 handleUnexpectedInflightException( m\_lastAssertionInfo, translateActiveException(), dummyReaction );}
\DoxyCodeLine{13004             \}}
\DoxyCodeLine{13005         \}}
\DoxyCodeLine{13006         Counts assertions = m\_totals.assertions -\/ prevAssertions;}
\DoxyCodeLine{13007         \textcolor{keywordtype}{bool} missingAssertions = testForMissingAssertions(assertions);}
\DoxyCodeLine{13008 }
\DoxyCodeLine{13009         m\_testCaseTracker-\/>close();}
\DoxyCodeLine{13010         handleUnfinishedSections();}
\DoxyCodeLine{13011         m\_messages.clear();}
\DoxyCodeLine{13012         m\_messageScopes.clear();}
\DoxyCodeLine{13013 }
\DoxyCodeLine{13014         SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);}
\DoxyCodeLine{13015         m\_reporter-\/>sectionEnded(testCaseSectionStats);}
\DoxyCodeLine{13016     \}}
\DoxyCodeLine{13017 }
\DoxyCodeLine{13018     \textcolor{keywordtype}{void} RunContext::invokeActiveTestCase() \{}
\DoxyCodeLine{13019         FatalConditionHandlerGuard \_(\&m\_fatalConditionhandler);}
\DoxyCodeLine{13020         m\_activeTestCase-\/>invoke();}
\DoxyCodeLine{13021     \}}
\DoxyCodeLine{13022 }
\DoxyCodeLine{13023     \textcolor{keywordtype}{void} RunContext::handleUnfinishedSections() \{}
\DoxyCodeLine{13024         \textcolor{comment}{// If sections ended prematurely due to an exception we stored their}}
\DoxyCodeLine{13025         \textcolor{comment}{// infos here so we can tear them down outside the unwind process.}}
\DoxyCodeLine{13026         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = m\_unfinishedSections.rbegin(),}
\DoxyCodeLine{13027              itEnd = m\_unfinishedSections.rend();}
\DoxyCodeLine{13028              it != itEnd;}
\DoxyCodeLine{13029              ++it)}
\DoxyCodeLine{13030             sectionEnded(*it);}
\DoxyCodeLine{13031         m\_unfinishedSections.clear();}
\DoxyCodeLine{13032     \}}
\DoxyCodeLine{13033 }
\DoxyCodeLine{13034     \textcolor{keywordtype}{void} RunContext::handleExpr(}
\DoxyCodeLine{13035         AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13036         ITransientExpression \textcolor{keyword}{const}\& expr,}
\DoxyCodeLine{13037         AssertionReaction\& reaction}
\DoxyCodeLine{13038     ) \{}
\DoxyCodeLine{13039         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{13040 }
\DoxyCodeLine{13041         \textcolor{keywordtype}{bool} negated = isFalseTest( info.resultDisposition );}
\DoxyCodeLine{13042         \textcolor{keywordtype}{bool} result = expr.getResult() != negated;}
\DoxyCodeLine{13043 }
\DoxyCodeLine{13044         \textcolor{keywordflow}{if}( result ) \{}
\DoxyCodeLine{13045             \textcolor{keywordflow}{if} (!m\_includeSuccessfulResults) \{}
\DoxyCodeLine{13046                 assertionPassed();}
\DoxyCodeLine{13047             \}}
\DoxyCodeLine{13048             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13049                 reportExpr(info, ResultWas::Ok, \&expr, negated);}
\DoxyCodeLine{13050             \}}
\DoxyCodeLine{13051         \}}
\DoxyCodeLine{13052         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13053             reportExpr(info, ResultWas::ExpressionFailed, \&expr, negated );}
\DoxyCodeLine{13054             populateReaction( reaction );}
\DoxyCodeLine{13055         \}}
\DoxyCodeLine{13056     \}}
\DoxyCodeLine{13057     \textcolor{keywordtype}{void} RunContext::reportExpr(}
\DoxyCodeLine{13058             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{13059             ResultWas::OfType resultType,}
\DoxyCodeLine{13060             ITransientExpression \textcolor{keyword}{const} *expr,}
\DoxyCodeLine{13061             \textcolor{keywordtype}{bool} negated ) \{}
\DoxyCodeLine{13062 }
\DoxyCodeLine{13063         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13064         AssertionResultData data( resultType, LazyExpression( negated ) );}
\DoxyCodeLine{13065 }
\DoxyCodeLine{13066         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13067         assertionResult.m\_resultData.lazyExpression.m\_transientExpression = expr;}
\DoxyCodeLine{13068 }
\DoxyCodeLine{13069         assertionEnded( assertionResult );}
\DoxyCodeLine{13070     \}}
\DoxyCodeLine{13071 }
\DoxyCodeLine{13072     \textcolor{keywordtype}{void} RunContext::handleMessage(}
\DoxyCodeLine{13073             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13074             ResultWas::OfType resultType,}
\DoxyCodeLine{13075             StringRef \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13076             AssertionReaction\& reaction}
\DoxyCodeLine{13077     ) \{}
\DoxyCodeLine{13078         m\_reporter-\/>assertionStarting( info );}
\DoxyCodeLine{13079 }
\DoxyCodeLine{13080         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13081 }
\DoxyCodeLine{13082         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13083         data.message = \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(message);}
\DoxyCodeLine{13084         AssertionResult assertionResult\{ m\_lastAssertionInfo, data \};}
\DoxyCodeLine{13085         assertionEnded( assertionResult );}
\DoxyCodeLine{13086         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13087             populateReaction( reaction );}
\DoxyCodeLine{13088     \}}
\DoxyCodeLine{13089     \textcolor{keywordtype}{void} RunContext::handleUnexpectedExceptionNotThrown(}
\DoxyCodeLine{13090             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13091             AssertionReaction\& reaction}
\DoxyCodeLine{13092     ) \{}
\DoxyCodeLine{13093         handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);}
\DoxyCodeLine{13094     \}}
\DoxyCodeLine{13095 }
\DoxyCodeLine{13096     \textcolor{keywordtype}{void} RunContext::handleUnexpectedInflightException(}
\DoxyCodeLine{13097             AssertionInfo \textcolor{keyword}{const}\& info,}
\DoxyCodeLine{13098             std::string \textcolor{keyword}{const}\& message,}
\DoxyCodeLine{13099             AssertionReaction\& reaction}
\DoxyCodeLine{13100     ) \{}
\DoxyCodeLine{13101         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13102 }
\DoxyCodeLine{13103         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13104         data.message = message;}
\DoxyCodeLine{13105         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13106         assertionEnded( assertionResult );}
\DoxyCodeLine{13107         populateReaction( reaction );}
\DoxyCodeLine{13108     \}}
\DoxyCodeLine{13109 }
\DoxyCodeLine{13110     \textcolor{keywordtype}{void} RunContext::populateReaction( AssertionReaction\& reaction ) \{}
\DoxyCodeLine{13111         reaction.shouldDebugBreak = m\_config-\/>shouldDebugBreak();}
\DoxyCodeLine{13112         reaction.shouldThrow = aborting() || (m\_lastAssertionInfo.resultDisposition \& ResultDisposition::Normal);}
\DoxyCodeLine{13113     \}}
\DoxyCodeLine{13114 }
\DoxyCodeLine{13115     \textcolor{keywordtype}{void} RunContext::handleIncomplete(}
\DoxyCodeLine{13116             AssertionInfo \textcolor{keyword}{const}\& info}
\DoxyCodeLine{13117     ) \{}
\DoxyCodeLine{13118         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13119 }
\DoxyCodeLine{13120         AssertionResultData data( ResultWas::ThrewException, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13121         data.message = \textcolor{stringliteral}{"{}Exception translation was disabled by CATCH\_CONFIG\_FAST\_COMPILE"{}};}
\DoxyCodeLine{13122         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13123         assertionEnded( assertionResult );}
\DoxyCodeLine{13124     \}}
\DoxyCodeLine{13125     \textcolor{keywordtype}{void} RunContext::handleNonExpr(}
\DoxyCodeLine{13126             AssertionInfo \textcolor{keyword}{const} \&info,}
\DoxyCodeLine{13127             ResultWas::OfType resultType,}
\DoxyCodeLine{13128             AssertionReaction \&reaction}
\DoxyCodeLine{13129     ) \{}
\DoxyCodeLine{13130         m\_lastAssertionInfo = info;}
\DoxyCodeLine{13131 }
\DoxyCodeLine{13132         AssertionResultData data( resultType, LazyExpression( \textcolor{keyword}{false} ) );}
\DoxyCodeLine{13133         AssertionResult assertionResult\{ info, data \};}
\DoxyCodeLine{13134         assertionEnded( assertionResult );}
\DoxyCodeLine{13135 }
\DoxyCodeLine{13136         \textcolor{keywordflow}{if}( !assertionResult.isOk() )}
\DoxyCodeLine{13137             populateReaction( reaction );}
\DoxyCodeLine{13138     \}}
\DoxyCodeLine{13139 }
\DoxyCodeLine{13140     IResultCapture\& getResultCapture() \{}
\DoxyCodeLine{13141         \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* capture = getCurrentContext().getResultCapture())}
\DoxyCodeLine{13142             \textcolor{keywordflow}{return} *capture;}
\DoxyCodeLine{13143         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13144             CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}No result capture instance"{}});}
\DoxyCodeLine{13145     \}}
\DoxyCodeLine{13146 }
\DoxyCodeLine{13147     \textcolor{keywordtype}{void} seedRng(IConfig \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13148         \textcolor{keywordflow}{if} (config.rngSeed() != 0) \{}
\DoxyCodeLine{13149             std::srand(config.rngSeed());}
\DoxyCodeLine{13150             rng().seed(config.rngSeed());}
\DoxyCodeLine{13151         \}}
\DoxyCodeLine{13152     \}}
\DoxyCodeLine{13153 }
\DoxyCodeLine{13154     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} rngSeed() \{}
\DoxyCodeLine{13155         \textcolor{keywordflow}{return} getCurrentContext().getConfig()-\/>rngSeed();}
\DoxyCodeLine{13156     \}}
\DoxyCodeLine{13157 }
\DoxyCodeLine{13158 \}}
\DoxyCodeLine{13159 \textcolor{comment}{// end catch\_run\_context.cpp}}
\DoxyCodeLine{13160 \textcolor{comment}{// start catch\_section.cpp}}
\DoxyCodeLine{13161 }
\DoxyCodeLine{13162 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13163 }
\DoxyCodeLine{13164     Section::Section( SectionInfo \textcolor{keyword}{const}\& info )}
\DoxyCodeLine{13165     :   m\_info( info ),}
\DoxyCodeLine{13166         m\_sectionIncluded( getResultCapture().sectionStarted( m\_info, m\_assertions ) )}
\DoxyCodeLine{13167     \{}
\DoxyCodeLine{13168         m\_timer.start();}
\DoxyCodeLine{13169     \}}
\DoxyCodeLine{13170 }
\DoxyCodeLine{13171     Section::\string~Section() \{}
\DoxyCodeLine{13172         \textcolor{keywordflow}{if}( m\_sectionIncluded ) \{}
\DoxyCodeLine{13173             SectionEndInfo endInfo\{ m\_info, m\_assertions, m\_timer.getElapsedSeconds() \};}
\DoxyCodeLine{13174             \textcolor{keywordflow}{if}( uncaught\_exceptions() )}
\DoxyCodeLine{13175                 getResultCapture().sectionEndedEarly( endInfo );}
\DoxyCodeLine{13176             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13177                 getResultCapture().sectionEnded( endInfo );}
\DoxyCodeLine{13178         \}}
\DoxyCodeLine{13179     \}}
\DoxyCodeLine{13180 }
\DoxyCodeLine{13181     \textcolor{comment}{// This indicates whether the section should be executed or not}}
\DoxyCodeLine{13182     Section::operator bool()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13183         \textcolor{keywordflow}{return} m\_sectionIncluded;}
\DoxyCodeLine{13184     \}}
\DoxyCodeLine{13185 }
\DoxyCodeLine{13186 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13187 \textcolor{comment}{// end catch\_section.cpp}}
\DoxyCodeLine{13188 \textcolor{comment}{// start catch\_section\_info.cpp}}
\DoxyCodeLine{13189 }
\DoxyCodeLine{13190 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13191 }
\DoxyCodeLine{13192     SectionInfo::SectionInfo}
\DoxyCodeLine{13193         (   SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo,}
\DoxyCodeLine{13194             std::string \textcolor{keyword}{const}\& \_name )}
\DoxyCodeLine{13195     :   name( \_name ),}
\DoxyCodeLine{13196         lineInfo( \_lineInfo )}
\DoxyCodeLine{13197     \{\}}
\DoxyCodeLine{13198 }
\DoxyCodeLine{13199 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13200 \textcolor{comment}{// end catch\_section\_info.cpp}}
\DoxyCodeLine{13201 \textcolor{comment}{// start catch\_session.cpp}}
\DoxyCodeLine{13202 }
\DoxyCodeLine{13203 \textcolor{comment}{// start catch\_session.h}}
\DoxyCodeLine{13204 }
\DoxyCodeLine{13205 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13206 }
\DoxyCodeLine{13207 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13208 }
\DoxyCodeLine{13209     \textcolor{keyword}{class }Session : NonCopyable \{}
\DoxyCodeLine{13210     \textcolor{keyword}{public}:}
\DoxyCodeLine{13211 }
\DoxyCodeLine{13212         Session();}
\DoxyCodeLine{13213         \string~Session() \textcolor{keyword}{override};}
\DoxyCodeLine{13214 }
\DoxyCodeLine{13215         \textcolor{keywordtype}{void} showHelp() \textcolor{keyword}{const};}
\DoxyCodeLine{13216         \textcolor{keywordtype}{void} libIdentify();}
\DoxyCodeLine{13217 }
\DoxyCodeLine{13218         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13219 \textcolor{preprocessor}{    \#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13220         \textcolor{keywordtype}{int} applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv );}
\DoxyCodeLine{13221 \textcolor{preprocessor}{    \#endif}}
\DoxyCodeLine{13222 }
\DoxyCodeLine{13223         \textcolor{keywordtype}{void} useConfigData( ConfigData \textcolor{keyword}{const}\& configData );}
\DoxyCodeLine{13224 }
\DoxyCodeLine{13225         \textcolor{keyword}{template}<\textcolor{keyword}{typename} CharT>}
\DoxyCodeLine{13226         \textcolor{keywordtype}{int} run(\textcolor{keywordtype}{int} argc, CharT \textcolor{keyword}{const} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{13227             \textcolor{keywordflow}{if} (m\_startupExceptions)}
\DoxyCodeLine{13228                 \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13229             \textcolor{keywordtype}{int} returnCode = applyCommandLine(argc, argv);}
\DoxyCodeLine{13230             \textcolor{keywordflow}{if} (returnCode == 0)}
\DoxyCodeLine{13231                 returnCode = run();}
\DoxyCodeLine{13232             \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13233         \}}
\DoxyCodeLine{13234 }
\DoxyCodeLine{13235         \textcolor{keywordtype}{int} run();}
\DoxyCodeLine{13236 }
\DoxyCodeLine{13237         clara::Parser \textcolor{keyword}{const}\& cli() \textcolor{keyword}{const};}
\DoxyCodeLine{13238         \textcolor{keywordtype}{void} cli( clara::Parser \textcolor{keyword}{const}\& newParser );}
\DoxyCodeLine{13239         ConfigData\& configData();}
\DoxyCodeLine{13240         Config\& config();}
\DoxyCodeLine{13241     \textcolor{keyword}{private}:}
\DoxyCodeLine{13242         \textcolor{keywordtype}{int} runInternal();}
\DoxyCodeLine{13243 }
\DoxyCodeLine{13244         clara::Parser m\_cli;}
\DoxyCodeLine{13245         ConfigData m\_configData;}
\DoxyCodeLine{13246         std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13247         \textcolor{keywordtype}{bool} m\_startupExceptions = \textcolor{keyword}{false};}
\DoxyCodeLine{13248     \};}
\DoxyCodeLine{13249 }
\DoxyCodeLine{13250 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13251 }
\DoxyCodeLine{13252 \textcolor{comment}{// end catch\_session.h}}
\DoxyCodeLine{13253 \textcolor{comment}{// start catch\_version.h}}
\DoxyCodeLine{13254 }
\DoxyCodeLine{13255 \textcolor{preprocessor}{\#include <iosfwd>}}
\DoxyCodeLine{13256 }
\DoxyCodeLine{13257 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13258 }
\DoxyCodeLine{13259     \textcolor{comment}{// Versioning information}}
\DoxyCodeLine{13260     \textcolor{keyword}{struct }Version \{}
\DoxyCodeLine{13261         Version( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13262         Version\& operator=( Version \textcolor{keyword}{const}\& ) = \textcolor{keyword}{delete};}
\DoxyCodeLine{13263         Version(    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{13264                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{13265                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{13266                     \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{13267                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber );}
\DoxyCodeLine{13268 }
\DoxyCodeLine{13269         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} majorVersion;}
\DoxyCodeLine{13270         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} minorVersion;}
\DoxyCodeLine{13271         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} patchNumber;}
\DoxyCodeLine{13272 }
\DoxyCodeLine{13273         \textcolor{comment}{// buildNumber is only used if branchName is not null}}
\DoxyCodeLine{13274         \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} branchName;}
\DoxyCodeLine{13275         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keyword}{const} buildNumber;}
\DoxyCodeLine{13276 }
\DoxyCodeLine{13277         \textcolor{keyword}{friend} std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version );}
\DoxyCodeLine{13278     \};}
\DoxyCodeLine{13279 }
\DoxyCodeLine{13280     Version \textcolor{keyword}{const}\& libraryVersion();}
\DoxyCodeLine{13281 \}}
\DoxyCodeLine{13282 }
\DoxyCodeLine{13283 \textcolor{comment}{// end catch\_version.h}}
\DoxyCodeLine{13284 \textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{13285 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{13286 \textcolor{preprocessor}{\#include <set>}}
\DoxyCodeLine{13287 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{13288 }
\DoxyCodeLine{13289 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13290 }
\DoxyCodeLine{13291     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13292         \textcolor{keyword}{const} \textcolor{keywordtype}{int} MaxExitCode = 255;}
\DoxyCodeLine{13293 }
\DoxyCodeLine{13294         IStreamingReporterPtr createReporter(std::string \textcolor{keyword}{const}\& reporterName, IConfigPtr \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13295             \textcolor{keyword}{auto} reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);}
\DoxyCodeLine{13296             CATCH\_ENFORCE(reporter, \textcolor{stringliteral}{"{}No reporter registered with name: '"{}} << reporterName << \textcolor{stringliteral}{"{}'"{}});}
\DoxyCodeLine{13297 }
\DoxyCodeLine{13298             \textcolor{keywordflow}{return} reporter;}
\DoxyCodeLine{13299         \}}
\DoxyCodeLine{13300 }
\DoxyCodeLine{13301         IStreamingReporterPtr makeReporter(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13302             \textcolor{keywordflow}{if} (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) \{}
\DoxyCodeLine{13303                 \textcolor{keywordflow}{return} createReporter(config-\/>getReporterName(), config);}
\DoxyCodeLine{13304             \}}
\DoxyCodeLine{13305 }
\DoxyCodeLine{13306             \textcolor{comment}{// On older platforms, returning std::unique\_ptr<ListeningReporter>}}
\DoxyCodeLine{13307             \textcolor{comment}{// when the return type is std::unique\_ptr<IStreamingReporter>}}
\DoxyCodeLine{13308             \textcolor{comment}{// doesn't compile without a std::move call. However, this causes}}
\DoxyCodeLine{13309             \textcolor{comment}{// a warning on newer platforms. Thus, we have to work around}}
\DoxyCodeLine{13310             \textcolor{comment}{// it a bit and downcast the pointer manually.}}
\DoxyCodeLine{13311             \textcolor{keyword}{auto} ret = std::unique\_ptr<IStreamingReporter>(\textcolor{keyword}{new} ListeningReporter);}
\DoxyCodeLine{13312             \textcolor{keyword}{auto}\& multi = \textcolor{keyword}{static\_cast<}ListeningReporter\&\textcolor{keyword}{>}(*ret);}
\DoxyCodeLine{13313             \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();}
\DoxyCodeLine{13314             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : listeners) \{}
\DoxyCodeLine{13315                 multi.addListener(listener-\/>create(Catch::ReporterConfig(config)));}
\DoxyCodeLine{13316             \}}
\DoxyCodeLine{13317             multi.addReporter(createReporter(config-\/>getReporterName(), config));}
\DoxyCodeLine{13318             \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{13319         \}}
\DoxyCodeLine{13320 }
\DoxyCodeLine{13321         \textcolor{keyword}{class }TestGroup \{}
\DoxyCodeLine{13322         \textcolor{keyword}{public}:}
\DoxyCodeLine{13323             \textcolor{keyword}{explicit} TestGroup(std::shared\_ptr<Config> \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{13324             : m\_config\{config\}}
\DoxyCodeLine{13325             , m\_context\{config, makeReporter(config)\}}
\DoxyCodeLine{13326             \{}
\DoxyCodeLine{13327                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& allTestCases = getAllTestCasesSorted(*m\_config);}
\DoxyCodeLine{13328                 m\_matches = m\_config-\/>testSpec().matchesByFilter(allTestCases, *m\_config);}
\DoxyCodeLine{13329                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13330 }
\DoxyCodeLine{13331                 \textcolor{keywordflow}{if} (m\_matches.empty() \&\& invalidArgs.empty()) \{}
\DoxyCodeLine{13332                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& test : allTestCases)}
\DoxyCodeLine{13333                         \textcolor{keywordflow}{if} (!test.isHidden())}
\DoxyCodeLine{13334                             m\_tests.emplace(\&test);}
\DoxyCodeLine{13335                 \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13336                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches)}
\DoxyCodeLine{13337                         m\_tests.insert(match.tests.begin(), match.tests.end());}
\DoxyCodeLine{13338                 \}}
\DoxyCodeLine{13339             \}}
\DoxyCodeLine{13340 }
\DoxyCodeLine{13341             Totals execute() \{}
\DoxyCodeLine{13342                 \textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArgs = m\_config-\/>testSpec().getInvalidArgs();}
\DoxyCodeLine{13343                 Totals totals;}
\DoxyCodeLine{13344                 m\_context.testGroupStarting(m\_config-\/>name(), 1, 1);}
\DoxyCodeLine{13345                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : m\_tests) \{}
\DoxyCodeLine{13346                     \textcolor{keywordflow}{if} (!m\_context.aborting())}
\DoxyCodeLine{13347                         totals += m\_context.runTest(*testCase);}
\DoxyCodeLine{13348                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13349                         m\_context.reporter().skipTest(*testCase);}
\DoxyCodeLine{13350                 \}}
\DoxyCodeLine{13351 }
\DoxyCodeLine{13352                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& match : m\_matches) \{}
\DoxyCodeLine{13353                     \textcolor{keywordflow}{if} (match.tests.empty()) \{}
\DoxyCodeLine{13354                         m\_context.reporter().noMatchingTestCases(match.name);}
\DoxyCodeLine{13355                         totals.error = -\/1;}
\DoxyCodeLine{13356                     \}}
\DoxyCodeLine{13357                 \}}
\DoxyCodeLine{13358 }
\DoxyCodeLine{13359                 \textcolor{keywordflow}{if} (!invalidArgs.empty()) \{}
\DoxyCodeLine{13360                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& invalidArg: invalidArgs)}
\DoxyCodeLine{13361                          m\_context.reporter().reportInvalidArguments(invalidArg);}
\DoxyCodeLine{13362                 \}}
\DoxyCodeLine{13363 }
\DoxyCodeLine{13364                 m\_context.testGroupEnded(m\_config-\/>name(), totals, 1, 1);}
\DoxyCodeLine{13365                 \textcolor{keywordflow}{return} totals;}
\DoxyCodeLine{13366             \}}
\DoxyCodeLine{13367 }
\DoxyCodeLine{13368         \textcolor{keyword}{private}:}
\DoxyCodeLine{13369             \textcolor{keyword}{using} Tests = std::set<TestCase const*>;}
\DoxyCodeLine{13370 }
\DoxyCodeLine{13371             std::shared\_ptr<Config> m\_config;}
\DoxyCodeLine{13372             RunContext m\_context;}
\DoxyCodeLine{13373             Tests m\_tests;}
\DoxyCodeLine{13374             TestSpec::Matches m\_matches;}
\DoxyCodeLine{13375         \};}
\DoxyCodeLine{13376 }
\DoxyCodeLine{13377         \textcolor{keywordtype}{void} applyFilenamesAsTags(\mbox{\hyperlink{struct_catch_1_1_i_config}{Catch::IConfig}} \textcolor{keyword}{const}\& config) \{}
\DoxyCodeLine{13378             \textcolor{keyword}{auto}\& tests = \textcolor{keyword}{const\_cast<}std::vector<TestCase>\&\textcolor{keyword}{>}(getAllTestCasesSorted(config));}
\DoxyCodeLine{13379             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& testCase : tests) \{}
\DoxyCodeLine{13380                 \textcolor{keyword}{auto} tags = testCase.tags;}
\DoxyCodeLine{13381 }
\DoxyCodeLine{13382                 std::string filename = testCase.lineInfo.file;}
\DoxyCodeLine{13383                 \textcolor{keyword}{auto} lastSlash = filename.find\_last\_of(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)/"{}});}
\DoxyCodeLine{13384                 \textcolor{keywordflow}{if} (lastSlash != std::string::npos) \{}
\DoxyCodeLine{13385                     filename.erase(0, lastSlash);}
\DoxyCodeLine{13386                     filename[0] = \textcolor{charliteral}{'\#'};}
\DoxyCodeLine{13387                 \}}
\DoxyCodeLine{13388 }
\DoxyCodeLine{13389                 \textcolor{keyword}{auto} lastDot = filename.find\_last\_of(\textcolor{charliteral}{'.'});}
\DoxyCodeLine{13390                 \textcolor{keywordflow}{if} (lastDot != std::string::npos) \{}
\DoxyCodeLine{13391                     filename.erase(lastDot);}
\DoxyCodeLine{13392                 \}}
\DoxyCodeLine{13393 }
\DoxyCodeLine{13394                 tags.push\_back(std::move(filename));}
\DoxyCodeLine{13395                 setTags(testCase, tags);}
\DoxyCodeLine{13396             \}}
\DoxyCodeLine{13397         \}}
\DoxyCodeLine{13398 }
\DoxyCodeLine{13399     \} \textcolor{comment}{// anon namespace}}
\DoxyCodeLine{13400 }
\DoxyCodeLine{13401     Session::Session() \{}
\DoxyCodeLine{13402         \textcolor{keyword}{static} \textcolor{keywordtype}{bool} alreadyInstantiated = \textcolor{keyword}{false};}
\DoxyCodeLine{13403         \textcolor{keywordflow}{if}( alreadyInstantiated ) \{}
\DoxyCodeLine{13404             CATCH\_TRY \{ CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Only one instance of Catch::Session can ever be used"{}} ); \}}
\DoxyCodeLine{13405             CATCH\_CATCH\_ALL \{ getMutableRegistryHub().registerStartupException(); \}}
\DoxyCodeLine{13406         \}}
\DoxyCodeLine{13407 }
\DoxyCodeLine{13408         \textcolor{comment}{// There cannot be exceptions at startup in no-\/exception mode.}}
\DoxyCodeLine{13409 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13410         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();}
\DoxyCodeLine{13411         \textcolor{keywordflow}{if} ( !exceptions.empty() ) \{}
\DoxyCodeLine{13412             config();}
\DoxyCodeLine{13413             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13414 }
\DoxyCodeLine{13415             m\_startupExceptions = \textcolor{keyword}{true};}
\DoxyCodeLine{13416             Colour colourGuard( Colour::Red );}
\DoxyCodeLine{13417             Catch::cerr() << \textcolor{stringliteral}{"{}Errors occurred during startup!"{}} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13418             \textcolor{comment}{// iterate over all exceptions and notify user}}
\DoxyCodeLine{13419             \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keyword}{auto}\& ex\_ptr : exceptions ) \{}
\DoxyCodeLine{13420                 \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{13421                     std::rethrow\_exception(ex\_ptr);}
\DoxyCodeLine{13422                 \} \textcolor{keywordflow}{catch} ( std::exception \textcolor{keyword}{const}\& ex ) \{}
\DoxyCodeLine{13423                     Catch::cerr() << Column( ex.what() ).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{13424                 \}}
\DoxyCodeLine{13425             \}}
\DoxyCodeLine{13426         \}}
\DoxyCodeLine{13427 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13428 }
\DoxyCodeLine{13429         alreadyInstantiated = \textcolor{keyword}{true};}
\DoxyCodeLine{13430         m\_cli = makeCommandLineParser( m\_configData );}
\DoxyCodeLine{13431     \}}
\DoxyCodeLine{13432     Session::\string~Session() \{}
\DoxyCodeLine{13433         Catch::cleanUp();}
\DoxyCodeLine{13434     \}}
\DoxyCodeLine{13435 }
\DoxyCodeLine{13436     \textcolor{keywordtype}{void} Session::showHelp()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13437         Catch::cout()}
\DoxyCodeLine{13438                 << \textcolor{stringliteral}{"{}\(\backslash\)nCatch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{13439                 << m\_cli << std::endl}
\DoxyCodeLine{13440                 << \textcolor{stringliteral}{"{}For more detailed usage please see the project docs\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13441     \}}
\DoxyCodeLine{13442     \textcolor{keywordtype}{void} Session::libIdentify() \{}
\DoxyCodeLine{13443         Catch::cout()}
\DoxyCodeLine{13444                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}description: "{}} << \textcolor{stringliteral}{"{}A Catch2 test executable\(\backslash\)n"{}}}
\DoxyCodeLine{13445                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}category: "{}} << \textcolor{stringliteral}{"{}testframework\(\backslash\)n"{}}}
\DoxyCodeLine{13446                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}framework: "{}} << \textcolor{stringliteral}{"{}Catch Test\(\backslash\)n"{}}}
\DoxyCodeLine{13447                 << std::left << std::setw(16) << \textcolor{stringliteral}{"{}version: "{}} << libraryVersion() << std::endl;}
\DoxyCodeLine{13448     \}}
\DoxyCodeLine{13449 }
\DoxyCodeLine{13450     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13451         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13452             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13453 }
\DoxyCodeLine{13454         \textcolor{keyword}{auto} result = m\_cli.parse( clara::Args( argc, argv ) );}
\DoxyCodeLine{13455         \textcolor{keywordflow}{if}( !result ) \{}
\DoxyCodeLine{13456             config();}
\DoxyCodeLine{13457             getCurrentMutableContext().setConfig(m\_config);}
\DoxyCodeLine{13458             Catch::cerr()}
\DoxyCodeLine{13459                 << Colour( Colour::Red )}
\DoxyCodeLine{13460                 << \textcolor{stringliteral}{"{}\(\backslash\)nError(s) in input:\(\backslash\)n"{}}}
\DoxyCodeLine{13461                 << Column( result.errorMessage() ).indent( 2 )}
\DoxyCodeLine{13462                 << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{13463             Catch::cerr() << \textcolor{stringliteral}{"{}Run with -\/? for usage\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{13464             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13465         \}}
\DoxyCodeLine{13466 }
\DoxyCodeLine{13467         \textcolor{keywordflow}{if}( m\_configData.showHelp )}
\DoxyCodeLine{13468             showHelp();}
\DoxyCodeLine{13469         \textcolor{keywordflow}{if}( m\_configData.libIdentify )}
\DoxyCodeLine{13470             libIdentify();}
\DoxyCodeLine{13471         m\_config.reset();}
\DoxyCodeLine{13472         \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13473     \}}
\DoxyCodeLine{13474 }
\DoxyCodeLine{13475 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(\_WIN32) \&\& defined(UNICODE)}}
\DoxyCodeLine{13476     \textcolor{keywordtype}{int} Session::applyCommandLine( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * \textcolor{keyword}{const} * argv ) \{}
\DoxyCodeLine{13477 }
\DoxyCodeLine{13478         \textcolor{keywordtype}{char} **utf8Argv = \textcolor{keyword}{new} \textcolor{keywordtype}{char} *[ argc ];}
\DoxyCodeLine{13479 }
\DoxyCodeLine{13480         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i ) \{}
\DoxyCodeLine{13481             \textcolor{keywordtype}{int} bufSize = WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, \textcolor{keyword}{nullptr}, 0, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13482 }
\DoxyCodeLine{13483             utf8Argv[ i ] = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[ bufSize ];}
\DoxyCodeLine{13484 }
\DoxyCodeLine{13485             WideCharToMultiByte( CP\_UTF8, 0, argv[i], -\/1, utf8Argv[i], bufSize, \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{13486         \}}
\DoxyCodeLine{13487 }
\DoxyCodeLine{13488         \textcolor{keywordtype}{int} returnCode = applyCommandLine( argc, utf8Argv );}
\DoxyCodeLine{13489 }
\DoxyCodeLine{13490         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < argc; ++i )}
\DoxyCodeLine{13491             delete [] utf8Argv[ i ];}
\DoxyCodeLine{13492 }
\DoxyCodeLine{13493         \textcolor{keyword}{delete} [] utf8Argv;}
\DoxyCodeLine{13494 }
\DoxyCodeLine{13495         \textcolor{keywordflow}{return} returnCode;}
\DoxyCodeLine{13496     \}}
\DoxyCodeLine{13497 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13498 }
\DoxyCodeLine{13499     \textcolor{keywordtype}{void} Session::useConfigData( ConfigData \textcolor{keyword}{const}\& configData ) \{}
\DoxyCodeLine{13500         m\_configData = configData;}
\DoxyCodeLine{13501         m\_config.reset();}
\DoxyCodeLine{13502     \}}
\DoxyCodeLine{13503 }
\DoxyCodeLine{13504     \textcolor{keywordtype}{int} Session::run() \{}
\DoxyCodeLine{13505         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeStart ) != 0 ) \{}
\DoxyCodeLine{13506             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before starting"{}} << std::endl;}
\DoxyCodeLine{13507             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13508         \}}
\DoxyCodeLine{13509         \textcolor{keywordtype}{int} exitCode = runInternal();}
\DoxyCodeLine{13510         \textcolor{keywordflow}{if}( ( m\_configData.waitForKeypress \& WaitForKeypress::BeforeExit ) != 0 ) \{}
\DoxyCodeLine{13511             Catch::cout() << \textcolor{stringliteral}{"{}...waiting for enter/ return before exiting, with code: "{}} << exitCode << std::endl;}
\DoxyCodeLine{13512             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}(std::getchar());}
\DoxyCodeLine{13513         \}}
\DoxyCodeLine{13514         \textcolor{keywordflow}{return} exitCode;}
\DoxyCodeLine{13515     \}}
\DoxyCodeLine{13516 }
\DoxyCodeLine{13517     clara::Parser \textcolor{keyword}{const}\& Session::cli()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13518         \textcolor{keywordflow}{return} m\_cli;}
\DoxyCodeLine{13519     \}}
\DoxyCodeLine{13520     \textcolor{keywordtype}{void} Session::cli( clara::Parser \textcolor{keyword}{const}\& newParser ) \{}
\DoxyCodeLine{13521         m\_cli = newParser;}
\DoxyCodeLine{13522     \}}
\DoxyCodeLine{13523     ConfigData\& Session::configData() \{}
\DoxyCodeLine{13524         \textcolor{keywordflow}{return} m\_configData;}
\DoxyCodeLine{13525     \}}
\DoxyCodeLine{13526     Config\& Session::config() \{}
\DoxyCodeLine{13527         \textcolor{keywordflow}{if}( !m\_config )}
\DoxyCodeLine{13528             m\_config = std::make\_shared<Config>( m\_configData );}
\DoxyCodeLine{13529         \textcolor{keywordflow}{return} *m\_config;}
\DoxyCodeLine{13530     \}}
\DoxyCodeLine{13531 }
\DoxyCodeLine{13532     \textcolor{keywordtype}{int} Session::runInternal() \{}
\DoxyCodeLine{13533         \textcolor{keywordflow}{if}( m\_startupExceptions )}
\DoxyCodeLine{13534             \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{13535 }
\DoxyCodeLine{13536         \textcolor{keywordflow}{if} (m\_configData.showHelp || m\_configData.libIdentify) \{}
\DoxyCodeLine{13537             \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13538         \}}
\DoxyCodeLine{13539 }
\DoxyCodeLine{13540         CATCH\_TRY \{}
\DoxyCodeLine{13541             config(); \textcolor{comment}{// Force config to be constructed}}
\DoxyCodeLine{13542 }
\DoxyCodeLine{13543             seedRng( *m\_config );}
\DoxyCodeLine{13544 }
\DoxyCodeLine{13545             \textcolor{keywordflow}{if}( m\_configData.filenamesAsTags )}
\DoxyCodeLine{13546                 applyFilenamesAsTags( *m\_config );}
\DoxyCodeLine{13547 }
\DoxyCodeLine{13548             \textcolor{comment}{// Handle list request}}
\DoxyCodeLine{13549             \textcolor{keywordflow}{if}( Option<std::size\_t> listed = list( m\_config ) )}
\DoxyCodeLine{13550                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( *listed );}
\DoxyCodeLine{13551 }
\DoxyCodeLine{13552             TestGroup tests \{ m\_config \};}
\DoxyCodeLine{13553             \textcolor{keyword}{auto} \textcolor{keyword}{const} totals = tests.execute();}
\DoxyCodeLine{13554 }
\DoxyCodeLine{13555             \textcolor{keywordflow}{if}( m\_config-\/>warnAboutNoTests() \&\& totals.error == -\/1 )}
\DoxyCodeLine{13556                 \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{13557 }
\DoxyCodeLine{13558             \textcolor{comment}{// Note that on unices only the lower 8 bits are usually used, clamping}}
\DoxyCodeLine{13559             \textcolor{comment}{// the return value to 255 prevents false negative when some multiple}}
\DoxyCodeLine{13560             \textcolor{comment}{// of 256 tests has failed}}
\DoxyCodeLine{13561             \textcolor{keywordflow}{return} (std::min) (MaxExitCode, (std::max) (totals.error, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(totals.assertions.failed)));}
\DoxyCodeLine{13562         \}}
\DoxyCodeLine{13563 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13564         \textcolor{keywordflow}{catch}( std::exception\& ex ) \{}
\DoxyCodeLine{13565             Catch::cerr() << ex.what() << std::endl;}
\DoxyCodeLine{13566             \textcolor{keywordflow}{return} MaxExitCode;}
\DoxyCodeLine{13567         \}}
\DoxyCodeLine{13568 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13569     \}}
\DoxyCodeLine{13570 }
\DoxyCodeLine{13571 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13572 \textcolor{comment}{// end catch\_session.cpp}}
\DoxyCodeLine{13573 \textcolor{comment}{// start catch\_singletons.cpp}}
\DoxyCodeLine{13574 }
\DoxyCodeLine{13575 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13576 }
\DoxyCodeLine{13577 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13578 }
\DoxyCodeLine{13579     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13580         \textcolor{keyword}{static} \textcolor{keyword}{auto} getSingletons() -\/> std::vector<ISingleton*>*\& \{}
\DoxyCodeLine{13581             \textcolor{keyword}{static} std::vector<ISingleton*>* g\_singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13582             \textcolor{keywordflow}{if}( !g\_singletons )}
\DoxyCodeLine{13583                 g\_singletons = \textcolor{keyword}{new} std::vector<ISingleton*>();}
\DoxyCodeLine{13584             \textcolor{keywordflow}{return} g\_singletons;}
\DoxyCodeLine{13585         \}}
\DoxyCodeLine{13586     \}}
\DoxyCodeLine{13587 }
\DoxyCodeLine{13588     ISingleton::\string~ISingleton() \{\}}
\DoxyCodeLine{13589 }
\DoxyCodeLine{13590     \textcolor{keywordtype}{void} addSingleton(ISingleton* singleton ) \{}
\DoxyCodeLine{13591         getSingletons()-\/>push\_back( singleton );}
\DoxyCodeLine{13592     \}}
\DoxyCodeLine{13593     \textcolor{keywordtype}{void} cleanupSingletons() \{}
\DoxyCodeLine{13594         \textcolor{keyword}{auto}\& singletons = getSingletons();}
\DoxyCodeLine{13595         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} singleton : *singletons )}
\DoxyCodeLine{13596             \textcolor{keyword}{delete} singleton;}
\DoxyCodeLine{13597         \textcolor{keyword}{delete} singletons;}
\DoxyCodeLine{13598         singletons = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13599     \}}
\DoxyCodeLine{13600 }
\DoxyCodeLine{13601 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13602 \textcolor{comment}{// end catch\_singletons.cpp}}
\DoxyCodeLine{13603 \textcolor{comment}{// start catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13604 }
\DoxyCodeLine{13605 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{13606 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13607 \textcolor{keywordtype}{void} StartupExceptionRegistry::add( std::exception\_ptr \textcolor{keyword}{const}\& exception ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{13608         CATCH\_TRY \{}
\DoxyCodeLine{13609             m\_exceptions.push\_back(exception);}
\DoxyCodeLine{13610         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13611             \textcolor{comment}{// If we run out of memory during start-\/up there's really not a lot more we can do about it}}
\DoxyCodeLine{13612             std::terminate();}
\DoxyCodeLine{13613         \}}
\DoxyCodeLine{13614     \}}
\DoxyCodeLine{13615 }
\DoxyCodeLine{13616     std::vector<std::exception\_ptr> \textcolor{keyword}{const}\& StartupExceptionRegistry::getExceptions() const noexcept \{}
\DoxyCodeLine{13617         \textcolor{keywordflow}{return} m\_exceptions;}
\DoxyCodeLine{13618     \}}
\DoxyCodeLine{13619 }
\DoxyCodeLine{13620 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{13621 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13622 \textcolor{comment}{// end catch\_startup\_exception\_registry.cpp}}
\DoxyCodeLine{13623 \textcolor{comment}{// start catch\_stream.cpp}}
\DoxyCodeLine{13624 }
\DoxyCodeLine{13625 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{13626 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{13627 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{13628 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13629 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13630 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{13631 }
\DoxyCodeLine{13632 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13633 }
\DoxyCodeLine{13634     Catch::IStream::\string~IStream() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13635 }
\DoxyCodeLine{13636     \textcolor{keyword}{namespace }Detail \{ \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13637         \textcolor{keyword}{template}<\textcolor{keyword}{typename} WriterF, std::\textcolor{keywordtype}{size\_t} bufferSize=256>}
\DoxyCodeLine{13638         \textcolor{keyword}{class }StreamBufImpl : \textcolor{keyword}{public} std::streambuf \{}
\DoxyCodeLine{13639             \textcolor{keywordtype}{char} data[bufferSize];}
\DoxyCodeLine{13640             WriterF m\_writer;}
\DoxyCodeLine{13641 }
\DoxyCodeLine{13642         \textcolor{keyword}{public}:}
\DoxyCodeLine{13643             StreamBufImpl() \{}
\DoxyCodeLine{13644                 setp( data, data + \textcolor{keyword}{sizeof}(data) );}
\DoxyCodeLine{13645             \}}
\DoxyCodeLine{13646 }
\DoxyCodeLine{13647             \string~StreamBufImpl() noexcept \{}
\DoxyCodeLine{13648                 StreamBufImpl::sync();}
\DoxyCodeLine{13649             \}}
\DoxyCodeLine{13650 }
\DoxyCodeLine{13651         \textcolor{keyword}{private}:}
\DoxyCodeLine{13652             \textcolor{keywordtype}{int} overflow( \textcolor{keywordtype}{int} c )\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13653                 sync();}
\DoxyCodeLine{13654 }
\DoxyCodeLine{13655                 \textcolor{keywordflow}{if}( c != EOF ) \{}
\DoxyCodeLine{13656                     \textcolor{keywordflow}{if}( pbase() == epptr() )}
\DoxyCodeLine{13657                         m\_writer( std::string( 1, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) ) );}
\DoxyCodeLine{13658                     \textcolor{keywordflow}{else}}
\DoxyCodeLine{13659                         sputc( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( c ) );}
\DoxyCodeLine{13660                 \}}
\DoxyCodeLine{13661                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13662             \}}
\DoxyCodeLine{13663 }
\DoxyCodeLine{13664             \textcolor{keywordtype}{int} sync()\textcolor{keyword}{ override }\{}
\DoxyCodeLine{13665                 \textcolor{keywordflow}{if}( pbase() != pptr() ) \{}
\DoxyCodeLine{13666                     m\_writer( std::string( pbase(), \textcolor{keyword}{static\_cast<}std::string::size\_type\textcolor{keyword}{>}( pptr() -\/ pbase() ) ) );}
\DoxyCodeLine{13667                     setp( pbase(), epptr() );}
\DoxyCodeLine{13668                 \}}
\DoxyCodeLine{13669                 \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{13670             \}}
\DoxyCodeLine{13671         \};}
\DoxyCodeLine{13672 }
\DoxyCodeLine{13674 }
\DoxyCodeLine{13675         \textcolor{keyword}{struct }OutputDebugWriter \{}
\DoxyCodeLine{13676 }
\DoxyCodeLine{13677             \textcolor{keywordtype}{void} operator()( std::string \textcolor{keyword}{const}\&str ) \{}
\DoxyCodeLine{13678                 writeToDebugConsole( str );}
\DoxyCodeLine{13679             \}}
\DoxyCodeLine{13680         \};}
\DoxyCodeLine{13681 }
\DoxyCodeLine{13683 }
\DoxyCodeLine{13684         \textcolor{keyword}{class }FileStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13685             \textcolor{keyword}{mutable} std::ofstream m\_ofs;}
\DoxyCodeLine{13686         \textcolor{keyword}{public}:}
\DoxyCodeLine{13687             FileStream( StringRef filename ) \{}
\DoxyCodeLine{13688                 m\_ofs.open( filename.c\_str() );}
\DoxyCodeLine{13689                 CATCH\_ENFORCE( !m\_ofs.fail(), \textcolor{stringliteral}{"{}Unable to open file: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13690             \}}
\DoxyCodeLine{13691             \string~FileStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13692         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13693             std::ostream\& stream()\textcolor{keyword}{ const override }\{}
\DoxyCodeLine{13694                 \textcolor{keywordflow}{return} m\_ofs;}
\DoxyCodeLine{13695             \}}
\DoxyCodeLine{13696         \};}
\DoxyCodeLine{13697 }
\DoxyCodeLine{13699 }
\DoxyCodeLine{13700         \textcolor{keyword}{class }CoutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13701             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13702         \textcolor{keyword}{public}:}
\DoxyCodeLine{13703             \textcolor{comment}{// Store the streambuf from cout up-\/front because}}
\DoxyCodeLine{13704             \textcolor{comment}{// cout may get redirected when running tests}}
\DoxyCodeLine{13705             CoutStream() : m\_os( Catch::cout().rdbuf() ) \{\}}
\DoxyCodeLine{13706             \string~CoutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13707 }
\DoxyCodeLine{13708         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13709             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13710         \};}
\DoxyCodeLine{13711 }
\DoxyCodeLine{13713 }
\DoxyCodeLine{13714         \textcolor{keyword}{class }DebugOutStream : \textcolor{keyword}{public} IStream \{}
\DoxyCodeLine{13715             std::unique\_ptr<StreamBufImpl<OutputDebugWriter>> m\_streamBuf;}
\DoxyCodeLine{13716             \textcolor{keyword}{mutable} std::ostream m\_os;}
\DoxyCodeLine{13717         \textcolor{keyword}{public}:}
\DoxyCodeLine{13718             DebugOutStream()}
\DoxyCodeLine{13719             :   m\_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),}
\DoxyCodeLine{13720                 m\_os( m\_streamBuf.get() )}
\DoxyCodeLine{13721             \{\}}
\DoxyCodeLine{13722 }
\DoxyCodeLine{13723             \string~DebugOutStream() \textcolor{keyword}{override} = \textcolor{keywordflow}{default};}
\DoxyCodeLine{13724 }
\DoxyCodeLine{13725         \textcolor{keyword}{public}: \textcolor{comment}{// IStream}}
\DoxyCodeLine{13726             std::ostream\& stream()\textcolor{keyword}{ const override }\{ \textcolor{keywordflow}{return} m\_os; \}}
\DoxyCodeLine{13727         \};}
\DoxyCodeLine{13728 }
\DoxyCodeLine{13729     \}\} \textcolor{comment}{// namespace anon::detail}}
\DoxyCodeLine{13730 }
\DoxyCodeLine{13732 }
\DoxyCodeLine{13733     \textcolor{keyword}{auto} makeStream( StringRef \textcolor{keyword}{const} \&filename ) -\/> IStream \textcolor{keyword}{const}* \{}
\DoxyCodeLine{13734         \textcolor{keywordflow}{if}( filename.empty() )}
\DoxyCodeLine{13735             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::CoutStream();}
\DoxyCodeLine{13736         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( filename[0] == \textcolor{charliteral}{'\%'} ) \{}
\DoxyCodeLine{13737             \textcolor{keywordflow}{if}( filename == \textcolor{stringliteral}{"{}\%debug"{}} )}
\DoxyCodeLine{13738                 \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::DebugOutStream();}
\DoxyCodeLine{13739             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13740                 CATCH\_ERROR( \textcolor{stringliteral}{"{}Unrecognised stream: '"{}} << filename << \textcolor{stringliteral}{"{}'"{}} );}
\DoxyCodeLine{13741         \}}
\DoxyCodeLine{13742         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13743             \textcolor{keywordflow}{return} \textcolor{keyword}{new} Detail::FileStream( filename );}
\DoxyCodeLine{13744     \}}
\DoxyCodeLine{13745 }
\DoxyCodeLine{13746     \textcolor{comment}{// This class encapsulates the idea of a pool of ostringstreams that can be reused.}}
\DoxyCodeLine{13747     \textcolor{keyword}{struct }StringStreams \{}
\DoxyCodeLine{13748         std::vector<std::unique\_ptr<std::ostringstream>> m\_streams;}
\DoxyCodeLine{13749         std::vector<std::size\_t> m\_unused;}
\DoxyCodeLine{13750         std::ostringstream m\_referenceStream; \textcolor{comment}{// Used for copy state/ flags from}}
\DoxyCodeLine{13751 }
\DoxyCodeLine{13752         \textcolor{keyword}{auto} add() -\/> std::size\_t \{}
\DoxyCodeLine{13753             \textcolor{keywordflow}{if}( m\_unused.empty() ) \{}
\DoxyCodeLine{13754                 m\_streams.push\_back( std::unique\_ptr<std::ostringstream>( \textcolor{keyword}{new} std::ostringstream ) );}
\DoxyCodeLine{13755                 \textcolor{keywordflow}{return} m\_streams.size()-\/1;}
\DoxyCodeLine{13756             \}}
\DoxyCodeLine{13757             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13758                 \textcolor{keyword}{auto} index = m\_unused.back();}
\DoxyCodeLine{13759                 m\_unused.pop\_back();}
\DoxyCodeLine{13760                 \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{13761             \}}
\DoxyCodeLine{13762         \}}
\DoxyCodeLine{13763 }
\DoxyCodeLine{13764         \textcolor{keywordtype}{void} release( std::size\_t index ) \{}
\DoxyCodeLine{13765             m\_streams[index]-\/>copyfmt( m\_referenceStream ); \textcolor{comment}{// Restore initial flags and other state}}
\DoxyCodeLine{13766             m\_unused.push\_back(index);}
\DoxyCodeLine{13767         \}}
\DoxyCodeLine{13768     \};}
\DoxyCodeLine{13769 }
\DoxyCodeLine{13770     ReusableStringStream::ReusableStringStream()}
\DoxyCodeLine{13771     :   m\_index( Singleton<StringStreams>::getMutable().add() ),}
\DoxyCodeLine{13772         m\_oss( Singleton<StringStreams>::getMutable().m\_streams[m\_index].get() )}
\DoxyCodeLine{13773     \{\}}
\DoxyCodeLine{13774 }
\DoxyCodeLine{13775     ReusableStringStream::\string~ReusableStringStream() \{}
\DoxyCodeLine{13776         \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{13777         m\_oss-\/>clear();}
\DoxyCodeLine{13778         Singleton<StringStreams>::getMutable().release( m\_index );}
\DoxyCodeLine{13779     \}}
\DoxyCodeLine{13780 }
\DoxyCodeLine{13781     \textcolor{keyword}{auto} ReusableStringStream::str() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{13782         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}std::ostringstream*\textcolor{keyword}{>}( m\_oss )-\/>str();}
\DoxyCodeLine{13783     \}}
\DoxyCodeLine{13784 }
\DoxyCodeLine{13786 }
\DoxyCodeLine{13787 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_NOSTDOUT }\textcolor{comment}{// If you \#define this you must implement these functions}}
\DoxyCodeLine{13788     std::ostream\& cout() \{ \textcolor{keywordflow}{return} std::cout; \}}
\DoxyCodeLine{13789     std::ostream\& cerr() \{ \textcolor{keywordflow}{return} std::cerr; \}}
\DoxyCodeLine{13790     std::ostream\& clog() \{ \textcolor{keywordflow}{return} std::clog; \}}
\DoxyCodeLine{13791 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{13792 \}}
\DoxyCodeLine{13793 \textcolor{comment}{// end catch\_stream.cpp}}
\DoxyCodeLine{13794 \textcolor{comment}{// start catch\_string\_manip.cpp}}
\DoxyCodeLine{13795 }
\DoxyCodeLine{13796 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13797 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13798 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13799 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{13800 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{13801 }
\DoxyCodeLine{13802 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13803 }
\DoxyCodeLine{13804     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{13805         \textcolor{keywordtype}{char} toLowerCh(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13806             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}( std::tolower( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c) ) );}
\DoxyCodeLine{13807         \}}
\DoxyCodeLine{13808     \}}
\DoxyCodeLine{13809 }
\DoxyCodeLine{13810     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& prefix ) \{}
\DoxyCodeLine{13811         \textcolor{keywordflow}{return} s.size() >= prefix.size() \&\& std::equal(prefix.begin(), prefix.end(), s.begin());}
\DoxyCodeLine{13812     \}}
\DoxyCodeLine{13813     \textcolor{keywordtype}{bool} startsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} prefix ) \{}
\DoxyCodeLine{13814         \textcolor{keywordflow}{return} !s.empty() \&\& s[0] == prefix;}
\DoxyCodeLine{13815     \}}
\DoxyCodeLine{13816     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& suffix ) \{}
\DoxyCodeLine{13817         \textcolor{keywordflow}{return} s.size() >= suffix.size() \&\& std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());}
\DoxyCodeLine{13818     \}}
\DoxyCodeLine{13819     \textcolor{keywordtype}{bool} endsWith( std::string \textcolor{keyword}{const}\& s, \textcolor{keywordtype}{char} suffix ) \{}
\DoxyCodeLine{13820         \textcolor{keywordflow}{return} !s.empty() \&\& s[s.size()-\/1] == suffix;}
\DoxyCodeLine{13821     \}}
\DoxyCodeLine{13822     \textcolor{keywordtype}{bool} contains( std::string \textcolor{keyword}{const}\& s, std::string \textcolor{keyword}{const}\& infix ) \{}
\DoxyCodeLine{13823         \textcolor{keywordflow}{return} s.find( infix ) != std::string::npos;}
\DoxyCodeLine{13824     \}}
\DoxyCodeLine{13825     \textcolor{keywordtype}{void} toLowerInPlace( std::string\& s ) \{}
\DoxyCodeLine{13826         std::transform( s.begin(), s.end(), s.begin(), toLowerCh );}
\DoxyCodeLine{13827     \}}
\DoxyCodeLine{13828     std::string toLower( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{13829         std::string lc = s;}
\DoxyCodeLine{13830         toLowerInPlace( lc );}
\DoxyCodeLine{13831         \textcolor{keywordflow}{return} lc;}
\DoxyCodeLine{13832     \}}
\DoxyCodeLine{13833     std::string trim( std::string \textcolor{keyword}{const}\& str ) \{}
\DoxyCodeLine{13834         \textcolor{keyword}{static} \textcolor{keywordtype}{char} \textcolor{keyword}{const}* whitespaceChars = \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)r\(\backslash\)t "{}};}
\DoxyCodeLine{13835         std::string::size\_type start = str.find\_first\_not\_of( whitespaceChars );}
\DoxyCodeLine{13836         std::string::size\_type end = str.find\_last\_not\_of( whitespaceChars );}
\DoxyCodeLine{13837 }
\DoxyCodeLine{13838         \textcolor{keywordflow}{return} start != std::string::npos ? str.substr( start, 1+end-\/start ) : std::string();}
\DoxyCodeLine{13839     \}}
\DoxyCodeLine{13840 }
\DoxyCodeLine{13841     StringRef trim(StringRef ref) \{}
\DoxyCodeLine{13842         \textcolor{keyword}{const} \textcolor{keyword}{auto} is\_ws = [](\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{13843             \textcolor{keywordflow}{return} c == \textcolor{charliteral}{' '} || c == \textcolor{charliteral}{'\(\backslash\)t'} || c == \textcolor{charliteral}{'\(\backslash\)n'} || c == \textcolor{charliteral}{'\(\backslash\)r'};}
\DoxyCodeLine{13844         \};}
\DoxyCodeLine{13845         \textcolor{keywordtype}{size\_t} real\_begin = 0;}
\DoxyCodeLine{13846         \textcolor{keywordflow}{while} (real\_begin < ref.size() \&\& is\_ws(ref[real\_begin])) \{ ++real\_begin; \}}
\DoxyCodeLine{13847         \textcolor{keywordtype}{size\_t} real\_end = ref.size();}
\DoxyCodeLine{13848         \textcolor{keywordflow}{while} (real\_end > real\_begin \&\& is\_ws(ref[real\_end -\/ 1])) \{ -\/-\/real\_end; \}}
\DoxyCodeLine{13849 }
\DoxyCodeLine{13850         \textcolor{keywordflow}{return} ref.substr(real\_begin, real\_end -\/ real\_begin);}
\DoxyCodeLine{13851     \}}
\DoxyCodeLine{13852 }
\DoxyCodeLine{13853     \textcolor{keywordtype}{bool} replaceInPlace( std::string\& str, std::string \textcolor{keyword}{const}\& replaceThis, std::string \textcolor{keyword}{const}\& withThis ) \{}
\DoxyCodeLine{13854         \textcolor{keywordtype}{bool} replaced = \textcolor{keyword}{false};}
\DoxyCodeLine{13855         std::size\_t i = str.find( replaceThis );}
\DoxyCodeLine{13856         \textcolor{keywordflow}{while}( i != std::string::npos ) \{}
\DoxyCodeLine{13857             replaced = \textcolor{keyword}{true};}
\DoxyCodeLine{13858             str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );}
\DoxyCodeLine{13859             \textcolor{keywordflow}{if}( i < str.size()-\/withThis.size() )}
\DoxyCodeLine{13860                 i = str.find( replaceThis, i+withThis.size() );}
\DoxyCodeLine{13861             \textcolor{keywordflow}{else}}
\DoxyCodeLine{13862                 i = std::string::npos;}
\DoxyCodeLine{13863         \}}
\DoxyCodeLine{13864         \textcolor{keywordflow}{return} replaced;}
\DoxyCodeLine{13865     \}}
\DoxyCodeLine{13866 }
\DoxyCodeLine{13867     std::vector<StringRef> splitStringRef( StringRef str, \textcolor{keywordtype}{char} delimiter ) \{}
\DoxyCodeLine{13868         std::vector<StringRef> subStrings;}
\DoxyCodeLine{13869         std::size\_t start = 0;}
\DoxyCodeLine{13870         \textcolor{keywordflow}{for}(std::size\_t pos = 0; pos < str.size(); ++pos ) \{}
\DoxyCodeLine{13871             \textcolor{keywordflow}{if}( str[pos] == delimiter ) \{}
\DoxyCodeLine{13872                 \textcolor{keywordflow}{if}( pos -\/ start > 1 )}
\DoxyCodeLine{13873                     subStrings.push\_back( str.substr( start, pos-\/start ) );}
\DoxyCodeLine{13874                 start = pos+1;}
\DoxyCodeLine{13875             \}}
\DoxyCodeLine{13876         \}}
\DoxyCodeLine{13877         \textcolor{keywordflow}{if}( start < str.size() )}
\DoxyCodeLine{13878             subStrings.push\_back( str.substr( start, str.size()-\/start ) );}
\DoxyCodeLine{13879         \textcolor{keywordflow}{return} subStrings;}
\DoxyCodeLine{13880     \}}
\DoxyCodeLine{13881 }
\DoxyCodeLine{13882     pluralise::pluralise( std::size\_t count, std::string \textcolor{keyword}{const}\& label )}
\DoxyCodeLine{13883     :   m\_count( count ),}
\DoxyCodeLine{13884         m\_label( label )}
\DoxyCodeLine{13885     \{\}}
\DoxyCodeLine{13886 }
\DoxyCodeLine{13887     std::ostream\& operator << ( std::ostream\& os, pluralise \textcolor{keyword}{const}\& pluraliser ) \{}
\DoxyCodeLine{13888         os << pluraliser.m\_count << \textcolor{charliteral}{' '} << pluraliser.m\_label;}
\DoxyCodeLine{13889         \textcolor{keywordflow}{if}( pluraliser.m\_count != 1 )}
\DoxyCodeLine{13890             os << \textcolor{charliteral}{'s'};}
\DoxyCodeLine{13891         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{13892     \}}
\DoxyCodeLine{13893 }
\DoxyCodeLine{13894 \}}
\DoxyCodeLine{13895 \textcolor{comment}{// end catch\_string\_manip.cpp}}
\DoxyCodeLine{13896 \textcolor{comment}{// start catch\_stringref.cpp}}
\DoxyCodeLine{13897 }
\DoxyCodeLine{13898 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{13899 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{13900 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{13901 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{13902 }
\DoxyCodeLine{13903 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13904     StringRef::StringRef( \textcolor{keywordtype}{char} \textcolor{keyword}{const}* rawChars ) noexcept}
\DoxyCodeLine{13905     : StringRef( rawChars, \textcolor{keyword}{static\_cast<}StringRef::size\_type\textcolor{keyword}{>}(std::strlen(rawChars) ) )}
\DoxyCodeLine{13906     \{\}}
\DoxyCodeLine{13907 }
\DoxyCodeLine{13908     \textcolor{keyword}{auto} StringRef::c\_str() const -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13909         CATCH\_ENFORCE(isNullTerminated(), \textcolor{stringliteral}{"{}Called StringRef::c\_str() on a non-\/null-\/terminated instance"{}});}
\DoxyCodeLine{13910         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13911     \}}
\DoxyCodeLine{13912     \textcolor{keyword}{auto} StringRef::data() const noexcept -\/> \textcolor{keywordtype}{char} const* \{}
\DoxyCodeLine{13913         \textcolor{keywordflow}{return} m\_start;}
\DoxyCodeLine{13914     \}}
\DoxyCodeLine{13915 }
\DoxyCodeLine{13916     \textcolor{keyword}{auto} StringRef::substr( size\_type start, size\_type size ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> StringRef \{}
\DoxyCodeLine{13917         \textcolor{keywordflow}{if} (start < m\_size) \{}
\DoxyCodeLine{13918             \textcolor{keywordflow}{return} StringRef(m\_start + start, (std::min)(m\_size -\/ start, size));}
\DoxyCodeLine{13919         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{13920             \textcolor{keywordflow}{return} StringRef();}
\DoxyCodeLine{13921         \}}
\DoxyCodeLine{13922     \}}
\DoxyCodeLine{13923     \textcolor{keyword}{auto} StringRef::operator == ( StringRef \textcolor{keyword}{const}\& other ) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{13924         \textcolor{keywordflow}{return} m\_size == other.m\_size}
\DoxyCodeLine{13925             \&\& (std::memcmp( m\_start, other.m\_start, m\_size ) == 0);}
\DoxyCodeLine{13926     \}}
\DoxyCodeLine{13927 }
\DoxyCodeLine{13928     \textcolor{keyword}{auto} operator << ( std::ostream\& os, StringRef \textcolor{keyword}{const}\& str ) -\/> std::ostream\& \{}
\DoxyCodeLine{13929         \textcolor{keywordflow}{return} os.write(str.data(), str.size());}
\DoxyCodeLine{13930     \}}
\DoxyCodeLine{13931 }
\DoxyCodeLine{13932     \textcolor{keyword}{auto} operator+=( std::string\& lhs, StringRef \textcolor{keyword}{const}\& rhs ) -\/> std::string\& \{}
\DoxyCodeLine{13933         lhs.append(rhs.data(), rhs.size());}
\DoxyCodeLine{13934         \textcolor{keywordflow}{return} lhs;}
\DoxyCodeLine{13935     \}}
\DoxyCodeLine{13936 }
\DoxyCodeLine{13937 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{13938 \textcolor{comment}{// end catch\_stringref.cpp}}
\DoxyCodeLine{13939 \textcolor{comment}{// start catch\_tag\_alias.cpp}}
\DoxyCodeLine{13940 }
\DoxyCodeLine{13941 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13942     TagAlias::TagAlias(std::string \textcolor{keyword}{const} \& \_tag, SourceLineInfo \_lineInfo): tag(\_tag), lineInfo(\_lineInfo) \{\}}
\DoxyCodeLine{13943 \}}
\DoxyCodeLine{13944 \textcolor{comment}{// end catch\_tag\_alias.cpp}}
\DoxyCodeLine{13945 \textcolor{comment}{// start catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13946 }
\DoxyCodeLine{13947 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13948 }
\DoxyCodeLine{13949     RegistrarForTagAliases::RegistrarForTagAliases(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* alias, \textcolor{keywordtype}{char} \textcolor{keyword}{const}* tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo) \{}
\DoxyCodeLine{13950         CATCH\_TRY \{}
\DoxyCodeLine{13951             getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);}
\DoxyCodeLine{13952         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{13953             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{13954             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{13955         \}}
\DoxyCodeLine{13956     \}}
\DoxyCodeLine{13957 }
\DoxyCodeLine{13958 \}}
\DoxyCodeLine{13959 \textcolor{comment}{// end catch\_tag\_alias\_autoregistrar.cpp}}
\DoxyCodeLine{13960 \textcolor{comment}{// start catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{13961 }
\DoxyCodeLine{13962 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{13963 }
\DoxyCodeLine{13964 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{13965 }
\DoxyCodeLine{13966     TagAliasRegistry::\string~TagAliasRegistry() \{\}}
\DoxyCodeLine{13967 }
\DoxyCodeLine{13968     TagAlias \textcolor{keyword}{const}* TagAliasRegistry::find( std::string \textcolor{keyword}{const}\& alias )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13969         \textcolor{keyword}{auto} it = m\_registry.find( alias );}
\DoxyCodeLine{13970         \textcolor{keywordflow}{if}( it != m\_registry.end() )}
\DoxyCodeLine{13971             \textcolor{keywordflow}{return} \&(it-\/>second);}
\DoxyCodeLine{13972         \textcolor{keywordflow}{else}}
\DoxyCodeLine{13973             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{13974     \}}
\DoxyCodeLine{13975 }
\DoxyCodeLine{13976     std::string TagAliasRegistry::expandAliases( std::string \textcolor{keyword}{const}\& unexpandedTestSpec )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{13977         std::string expandedTestSpec = unexpandedTestSpec;}
\DoxyCodeLine{13978         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& registryKvp : m\_registry ) \{}
\DoxyCodeLine{13979             std::size\_t pos = expandedTestSpec.find( registryKvp.first );}
\DoxyCodeLine{13980             \textcolor{keywordflow}{if}( pos != std::string::npos ) \{}
\DoxyCodeLine{13981                 expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +}
\DoxyCodeLine{13982                                     registryKvp.second.tag +}
\DoxyCodeLine{13983                                     expandedTestSpec.substr( pos + registryKvp.first.size() );}
\DoxyCodeLine{13984             \}}
\DoxyCodeLine{13985         \}}
\DoxyCodeLine{13986         \textcolor{keywordflow}{return} expandedTestSpec;}
\DoxyCodeLine{13987     \}}
\DoxyCodeLine{13988 }
\DoxyCodeLine{13989     \textcolor{keywordtype}{void} TagAliasRegistry::add( std::string \textcolor{keyword}{const}\& alias, std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& lineInfo ) \{}
\DoxyCodeLine{13990         CATCH\_ENFORCE( startsWith(alias, \textcolor{stringliteral}{"{}[@"{}}) \&\& endsWith(alias, \textcolor{charliteral}{']'}),}
\DoxyCodeLine{13991                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' is not of the form [@alias name].\(\backslash\)n"{}} << lineInfo );}
\DoxyCodeLine{13992 }
\DoxyCodeLine{13993         CATCH\_ENFORCE( m\_registry.insert(std::make\_pair(alias, TagAlias(tag, lineInfo))).second,}
\DoxyCodeLine{13994                       \textcolor{stringliteral}{"{}error: tag alias, '"{}} << alias << \textcolor{stringliteral}{"{}' already registered.\(\backslash\)n"{}}}
\DoxyCodeLine{13995                       << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at: "{}} << find(alias)-\/>lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{13996                       << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at: "{}} << lineInfo );}
\DoxyCodeLine{13997     \}}
\DoxyCodeLine{13998 }
\DoxyCodeLine{13999     ITagAliasRegistry::\string~ITagAliasRegistry() \{\}}
\DoxyCodeLine{14000 }
\DoxyCodeLine{14001     ITagAliasRegistry \textcolor{keyword}{const}\& ITagAliasRegistry::get() \{}
\DoxyCodeLine{14002         \textcolor{keywordflow}{return} getRegistryHub().getTagAliasRegistry();}
\DoxyCodeLine{14003     \}}
\DoxyCodeLine{14004 }
\DoxyCodeLine{14005 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14006 \textcolor{comment}{// end catch\_tag\_alias\_registry.cpp}}
\DoxyCodeLine{14007 \textcolor{comment}{// start catch\_test\_case\_info.cpp}}
\DoxyCodeLine{14008 }
\DoxyCodeLine{14009 \textcolor{preprocessor}{\#include <cctype>}}
\DoxyCodeLine{14010 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{14011 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14012 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14013 }
\DoxyCodeLine{14014 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14015 }
\DoxyCodeLine{14016     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14017         TestCaseInfo::SpecialProperties parseSpecialTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{14018             \textcolor{keywordflow}{if}( startsWith( tag, \textcolor{charliteral}{'.'} ) ||}
\DoxyCodeLine{14019                 tag == \textcolor{stringliteral}{"{}!hide"{}} )}
\DoxyCodeLine{14020                 \textcolor{keywordflow}{return} TestCaseInfo::IsHidden;}
\DoxyCodeLine{14021             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!throws"{}} )}
\DoxyCodeLine{14022                 \textcolor{keywordflow}{return} TestCaseInfo::Throws;}
\DoxyCodeLine{14023             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!shouldfail"{}} )}
\DoxyCodeLine{14024                 \textcolor{keywordflow}{return} TestCaseInfo::ShouldFail;}
\DoxyCodeLine{14025             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!mayfail"{}} )}
\DoxyCodeLine{14026                 \textcolor{keywordflow}{return} TestCaseInfo::MayFail;}
\DoxyCodeLine{14027             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!nonportable"{}} )}
\DoxyCodeLine{14028                 \textcolor{keywordflow}{return} TestCaseInfo::NonPortable;}
\DoxyCodeLine{14029             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( tag == \textcolor{stringliteral}{"{}!benchmark"{}} )}
\DoxyCodeLine{14030                 \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );}
\DoxyCodeLine{14031             \textcolor{keywordflow}{else}}
\DoxyCodeLine{14032                 \textcolor{keywordflow}{return} TestCaseInfo::None;}
\DoxyCodeLine{14033         \}}
\DoxyCodeLine{14034         \textcolor{keywordtype}{bool} isReservedTag( std::string \textcolor{keyword}{const}\& tag ) \{}
\DoxyCodeLine{14035             \textcolor{keywordflow}{return} parseSpecialTag( tag ) == TestCaseInfo::None \&\& tag.size() > 0 \&\& !std::isalnum( \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(tag[0]) );}
\DoxyCodeLine{14036         \}}
\DoxyCodeLine{14037         \textcolor{keywordtype}{void} enforceNotReservedTag( std::string \textcolor{keyword}{const}\& tag, SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo ) \{}
\DoxyCodeLine{14038             CATCH\_ENFORCE( !isReservedTag(tag),}
\DoxyCodeLine{14039                           \textcolor{stringliteral}{"{}Tag name: ["{}} << tag << \textcolor{stringliteral}{"{}] is not allowed.\(\backslash\)n"{}}}
\DoxyCodeLine{14040                           << \textcolor{stringliteral}{"{}Tag names starting with non alphanumeric characters are reserved\(\backslash\)n"{}}}
\DoxyCodeLine{14041                           << \_lineInfo );}
\DoxyCodeLine{14042         \}}
\DoxyCodeLine{14043     \}}
\DoxyCodeLine{14044 }
\DoxyCodeLine{14045     TestCase makeTestCase(  ITestInvoker* \_testCase,}
\DoxyCodeLine{14046                             std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{14047                             NameAndTags \textcolor{keyword}{const}\& nameAndTags,}
\DoxyCodeLine{14048                             SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{14049     \{}
\DoxyCodeLine{14050         \textcolor{keywordtype}{bool} isHidden = \textcolor{keyword}{false};}
\DoxyCodeLine{14051 }
\DoxyCodeLine{14052         \textcolor{comment}{// Parse out tags}}
\DoxyCodeLine{14053         std::vector<std::string> tags;}
\DoxyCodeLine{14054         std::string desc, tag;}
\DoxyCodeLine{14055         \textcolor{keywordtype}{bool} inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{14056         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : nameAndTags.tags) \{}
\DoxyCodeLine{14057             \textcolor{keywordflow}{if}( !inTag ) \{}
\DoxyCodeLine{14058                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} )}
\DoxyCodeLine{14059                     inTag = \textcolor{keyword}{true};}
\DoxyCodeLine{14060                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14061                     desc += c;}
\DoxyCodeLine{14062             \}}
\DoxyCodeLine{14063             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14064                 \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{']'} ) \{}
\DoxyCodeLine{14065                     TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );}
\DoxyCodeLine{14066                     \textcolor{keywordflow}{if}( ( prop \& TestCaseInfo::IsHidden ) != 0 )}
\DoxyCodeLine{14067                         isHidden = \textcolor{keyword}{true};}
\DoxyCodeLine{14068                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( prop == TestCaseInfo::None )}
\DoxyCodeLine{14069                         enforceNotReservedTag( tag, \_lineInfo );}
\DoxyCodeLine{14070 }
\DoxyCodeLine{14071                     \textcolor{comment}{// Merged hide tags like `[.approvals]` should be added as}}
\DoxyCodeLine{14072                     \textcolor{comment}{// `[.][approvals]`. The `[.]` is added at later point, so}}
\DoxyCodeLine{14073                     \textcolor{comment}{// we only strip the prefix}}
\DoxyCodeLine{14074                     \textcolor{keywordflow}{if} (startsWith(tag, \textcolor{charliteral}{'.'}) \&\& tag.size() > 1) \{}
\DoxyCodeLine{14075                         tag.erase(0, 1);}
\DoxyCodeLine{14076                     \}}
\DoxyCodeLine{14077                     tags.push\_back( tag );}
\DoxyCodeLine{14078                     tag.clear();}
\DoxyCodeLine{14079                     inTag = \textcolor{keyword}{false};}
\DoxyCodeLine{14080                 \}}
\DoxyCodeLine{14081                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{14082                     tag += c;}
\DoxyCodeLine{14083             \}}
\DoxyCodeLine{14084         \}}
\DoxyCodeLine{14085         \textcolor{keywordflow}{if}( isHidden ) \{}
\DoxyCodeLine{14086             \textcolor{comment}{// Add all "{}hidden"{} tags to make them behave identically}}
\DoxyCodeLine{14087             tags.insert( tags.end(), \{ \textcolor{stringliteral}{"{}."{}}, \textcolor{stringliteral}{"{}!hide"{}} \} );}
\DoxyCodeLine{14088         \}}
\DoxyCodeLine{14089 }
\DoxyCodeLine{14090         TestCaseInfo info( \textcolor{keyword}{static\_cast<}std::string\textcolor{keyword}{>}(nameAndTags.name), \_className, desc, tags, \_lineInfo );}
\DoxyCodeLine{14091         \textcolor{keywordflow}{return} TestCase( \_testCase, std::move(info) );}
\DoxyCodeLine{14092     \}}
\DoxyCodeLine{14093 }
\DoxyCodeLine{14094     \textcolor{keywordtype}{void} setTags( TestCaseInfo\& testCaseInfo, std::vector<std::string> tags ) \{}
\DoxyCodeLine{14095         std::sort(begin(tags), end(tags));}
\DoxyCodeLine{14096         tags.erase(std::unique(begin(tags), end(tags)), end(tags));}
\DoxyCodeLine{14097         testCaseInfo.lcaseTags.clear();}
\DoxyCodeLine{14098 }
\DoxyCodeLine{14099         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& tag : tags ) \{}
\DoxyCodeLine{14100             std::string lcaseTag = toLower( tag );}
\DoxyCodeLine{14101             testCaseInfo.properties = \textcolor{keyword}{static\_cast<}TestCaseInfo::SpecialProperties\textcolor{keyword}{>}( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );}
\DoxyCodeLine{14102             testCaseInfo.lcaseTags.push\_back( lcaseTag );}
\DoxyCodeLine{14103         \}}
\DoxyCodeLine{14104         testCaseInfo.tags = std::move(tags);}
\DoxyCodeLine{14105     \}}
\DoxyCodeLine{14106 }
\DoxyCodeLine{14107     TestCaseInfo::TestCaseInfo( std::string \textcolor{keyword}{const}\& \_name,}
\DoxyCodeLine{14108                                 std::string \textcolor{keyword}{const}\& \_className,}
\DoxyCodeLine{14109                                 std::string \textcolor{keyword}{const}\& \_description,}
\DoxyCodeLine{14110                                 std::vector<std::string> \textcolor{keyword}{const}\& \_tags,}
\DoxyCodeLine{14111                                 SourceLineInfo \textcolor{keyword}{const}\& \_lineInfo )}
\DoxyCodeLine{14112     :   name( \_name ),}
\DoxyCodeLine{14113         className( \_className ),}
\DoxyCodeLine{14114         description( \_description ),}
\DoxyCodeLine{14115         lineInfo( \_lineInfo ),}
\DoxyCodeLine{14116         properties( None )}
\DoxyCodeLine{14117     \{}
\DoxyCodeLine{14118         setTags( *\textcolor{keyword}{this}, \_tags );}
\DoxyCodeLine{14119     \}}
\DoxyCodeLine{14120 }
\DoxyCodeLine{14121     \textcolor{keywordtype}{bool} TestCaseInfo::isHidden()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14122         \textcolor{keywordflow}{return} ( properties \& IsHidden ) != 0;}
\DoxyCodeLine{14123     \}}
\DoxyCodeLine{14124     \textcolor{keywordtype}{bool} TestCaseInfo::throws()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14125         \textcolor{keywordflow}{return} ( properties \& Throws ) != 0;}
\DoxyCodeLine{14126     \}}
\DoxyCodeLine{14127     \textcolor{keywordtype}{bool} TestCaseInfo::okToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14128         \textcolor{keywordflow}{return} ( properties \& (ShouldFail | MayFail ) ) != 0;}
\DoxyCodeLine{14129     \}}
\DoxyCodeLine{14130     \textcolor{keywordtype}{bool} TestCaseInfo::expectedToFail()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14131         \textcolor{keywordflow}{return} ( properties \& (ShouldFail ) ) != 0;}
\DoxyCodeLine{14132     \}}
\DoxyCodeLine{14133 }
\DoxyCodeLine{14134     std::string TestCaseInfo::tagsAsString()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14135         std::string ret;}
\DoxyCodeLine{14136         \textcolor{comment}{// '[' and ']' per tag}}
\DoxyCodeLine{14137         std::size\_t full\_size = 2 * tags.size();}
\DoxyCodeLine{14138         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14139             full\_size += tag.size();}
\DoxyCodeLine{14140         \}}
\DoxyCodeLine{14141         ret.reserve(full\_size);}
\DoxyCodeLine{14142         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& tag : tags) \{}
\DoxyCodeLine{14143             ret.push\_back(\textcolor{charliteral}{'['});}
\DoxyCodeLine{14144             ret.append(tag);}
\DoxyCodeLine{14145             ret.push\_back(\textcolor{charliteral}{']'});}
\DoxyCodeLine{14146         \}}
\DoxyCodeLine{14147 }
\DoxyCodeLine{14148         \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{14149     \}}
\DoxyCodeLine{14150 }
\DoxyCodeLine{14151     TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo\&\& info ) : TestCaseInfo( std::move(info) ), test( testCase ) \{\}}
\DoxyCodeLine{14152 }
\DoxyCodeLine{14153     TestCase TestCase::withName( std::string \textcolor{keyword}{const}\& \_newName )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14154         TestCase other( *\textcolor{keyword}{this} );}
\DoxyCodeLine{14155         other.name = \_newName;}
\DoxyCodeLine{14156         \textcolor{keywordflow}{return} other;}
\DoxyCodeLine{14157     \}}
\DoxyCodeLine{14158 }
\DoxyCodeLine{14159     \textcolor{keywordtype}{void} TestCase::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14160         test-\/>invoke();}
\DoxyCodeLine{14161     \}}
\DoxyCodeLine{14162 }
\DoxyCodeLine{14163     \textcolor{keywordtype}{bool} TestCase::operator == ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14164         \textcolor{keywordflow}{return}  test.get() == other.test.get() \&\&}
\DoxyCodeLine{14165                 name == other.name \&\&}
\DoxyCodeLine{14166                 className == other.className;}
\DoxyCodeLine{14167     \}}
\DoxyCodeLine{14168 }
\DoxyCodeLine{14169     \textcolor{keywordtype}{bool} TestCase::operator < ( TestCase \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14170         \textcolor{keywordflow}{return} name < other.name;}
\DoxyCodeLine{14171     \}}
\DoxyCodeLine{14172 }
\DoxyCodeLine{14173     TestCaseInfo \textcolor{keyword}{const}\& TestCase::getTestCaseInfo()\textcolor{keyword}{ const}}
\DoxyCodeLine{14174 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14175         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14176     \}}
\DoxyCodeLine{14177 }
\DoxyCodeLine{14178 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14179 \textcolor{comment}{// end catch\_test\_case\_info.cpp}}
\DoxyCodeLine{14180 \textcolor{comment}{// start catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14181 }
\DoxyCodeLine{14182 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14183 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14184 }
\DoxyCodeLine{14185 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14186 }
\DoxyCodeLine{14187     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14188         \textcolor{keyword}{struct }TestHasher \{}
\DoxyCodeLine{14189             \textcolor{keyword}{using} hash\_t = uint64\_t;}
\DoxyCodeLine{14190 }
\DoxyCodeLine{14191             \textcolor{keyword}{explicit} TestHasher( hash\_t hashSuffix ):}
\DoxyCodeLine{14192                 m\_hashSuffix\{ hashSuffix \} \{\}}
\DoxyCodeLine{14193 }
\DoxyCodeLine{14194             uint32\_t operator()( TestCase \textcolor{keyword}{const}\& t )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14195                 \textcolor{comment}{// FNV-\/1a hash with multiplication fold.}}
\DoxyCodeLine{14196                 \textcolor{keyword}{const} hash\_t prime = 1099511628211u;}
\DoxyCodeLine{14197                 hash\_t hash = 14695981039346656037u;}
\DoxyCodeLine{14198                 \textcolor{keywordflow}{for} ( \textcolor{keyword}{const} \textcolor{keywordtype}{char} c : t.name ) \{}
\DoxyCodeLine{14199                     hash \string^= c;}
\DoxyCodeLine{14200                     hash *= prime;}
\DoxyCodeLine{14201                 \}}
\DoxyCodeLine{14202                 hash \string^= m\_hashSuffix;}
\DoxyCodeLine{14203                 hash *= prime;}
\DoxyCodeLine{14204                 \textcolor{keyword}{const} uint32\_t low\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash ) \};}
\DoxyCodeLine{14205                 \textcolor{keyword}{const} uint32\_t high\{ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}( hash >> 32 ) \};}
\DoxyCodeLine{14206                 \textcolor{keywordflow}{return} low * high;}
\DoxyCodeLine{14207             \}}
\DoxyCodeLine{14208 }
\DoxyCodeLine{14209         \textcolor{keyword}{private}:}
\DoxyCodeLine{14210             hash\_t m\_hashSuffix;}
\DoxyCodeLine{14211         \};}
\DoxyCodeLine{14212     \} \textcolor{comment}{// end unnamed namespace}}
\DoxyCodeLine{14213 }
\DoxyCodeLine{14214     std::vector<TestCase> sortTests( IConfig \textcolor{keyword}{const}\& config, std::vector<TestCase> \textcolor{keyword}{const}\& unsortedTestCases ) \{}
\DoxyCodeLine{14215         \textcolor{keywordflow}{switch}( config.runOrder() ) \{}
\DoxyCodeLine{14216             \textcolor{keywordflow}{case} RunTests::InDeclarationOrder:}
\DoxyCodeLine{14217                 \textcolor{comment}{// already in declaration order}}
\DoxyCodeLine{14218                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14219 }
\DoxyCodeLine{14220             \textcolor{keywordflow}{case} RunTests::InLexicographicalOrder: \{}
\DoxyCodeLine{14221                 std::vector<TestCase> sorted = unsortedTestCases;}
\DoxyCodeLine{14222                 std::sort( sorted.begin(), sorted.end() );}
\DoxyCodeLine{14223                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14224             \}}
\DoxyCodeLine{14225 }
\DoxyCodeLine{14226             \textcolor{keywordflow}{case} RunTests::InRandomOrder: \{}
\DoxyCodeLine{14227                 seedRng( config );}
\DoxyCodeLine{14228                 TestHasher h\{ config.rngSeed() \};}
\DoxyCodeLine{14229 }
\DoxyCodeLine{14230                 \textcolor{keyword}{using} hashedTest = std::pair<TestHasher::hash\_t, TestCase const*>;}
\DoxyCodeLine{14231                 std::vector<hashedTest> indexed\_tests;}
\DoxyCodeLine{14232                 indexed\_tests.reserve( unsortedTestCases.size() );}
\DoxyCodeLine{14233 }
\DoxyCodeLine{14234                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : unsortedTestCases) \{}
\DoxyCodeLine{14235                     indexed\_tests.emplace\_back(h(testCase), \&testCase);}
\DoxyCodeLine{14236                 \}}
\DoxyCodeLine{14237 }
\DoxyCodeLine{14238                 std::sort(indexed\_tests.begin(), indexed\_tests.end(),}
\DoxyCodeLine{14239                           [](hashedTest \textcolor{keyword}{const}\& lhs, hashedTest \textcolor{keyword}{const}\& rhs) \{}
\DoxyCodeLine{14240                           if (lhs.first == rhs.first) \{}
\DoxyCodeLine{14241                               return lhs.second-\/>name < rhs.second-\/>name;}
\DoxyCodeLine{14242                           \}}
\DoxyCodeLine{14243                           \textcolor{keywordflow}{return} lhs.first < rhs.first;}
\DoxyCodeLine{14244                 \});}
\DoxyCodeLine{14245 }
\DoxyCodeLine{14246                 std::vector<TestCase> sorted;}
\DoxyCodeLine{14247                 sorted.reserve( indexed\_tests.size() );}
\DoxyCodeLine{14248 }
\DoxyCodeLine{14249                 \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& hashed : indexed\_tests) \{}
\DoxyCodeLine{14250                     sorted.emplace\_back(*hashed.second);}
\DoxyCodeLine{14251                 \}}
\DoxyCodeLine{14252 }
\DoxyCodeLine{14253                 \textcolor{keywordflow}{return} sorted;}
\DoxyCodeLine{14254             \}}
\DoxyCodeLine{14255         \}}
\DoxyCodeLine{14256         \textcolor{keywordflow}{return} unsortedTestCases;}
\DoxyCodeLine{14257     \}}
\DoxyCodeLine{14258 }
\DoxyCodeLine{14259     \textcolor{keywordtype}{bool} isThrowSafe( TestCase \textcolor{keyword}{const}\& testCase, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14260         \textcolor{keywordflow}{return} !testCase.throws() || config.allowThrows();}
\DoxyCodeLine{14261     \}}
\DoxyCodeLine{14262 }
\DoxyCodeLine{14263     \textcolor{keywordtype}{bool} matchTest( TestCase \textcolor{keyword}{const}\& testCase, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14264         \textcolor{keywordflow}{return} testSpec.matches( testCase ) \&\& isThrowSafe( testCase, config );}
\DoxyCodeLine{14265     \}}
\DoxyCodeLine{14266 }
\DoxyCodeLine{14267     \textcolor{keywordtype}{void} enforceNoDuplicateTestCases( std::vector<TestCase> \textcolor{keyword}{const}\& functions ) \{}
\DoxyCodeLine{14268         std::set<TestCase> seenFunctions;}
\DoxyCodeLine{14269         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& \textcolor{keyword}{function} : functions ) \{}
\DoxyCodeLine{14270             \textcolor{keyword}{auto} prev = seenFunctions.insert( \textcolor{keyword}{function} );}
\DoxyCodeLine{14271             CATCH\_ENFORCE( prev.second,}
\DoxyCodeLine{14272                     \textcolor{stringliteral}{"{}error: TEST\_CASE( \(\backslash\)"{}"{}} << \textcolor{keyword}{function}.name << \textcolor{stringliteral}{"{}\(\backslash\)"{} ) already defined.\(\backslash\)n"{}}}
\DoxyCodeLine{14273                     << \textcolor{stringliteral}{"{}\(\backslash\)tFirst seen at "{}} << prev.first-\/>getTestCaseInfo().lineInfo << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{14274                     << \textcolor{stringliteral}{"{}\(\backslash\)tRedefined at "{}} << \textcolor{keyword}{function}.getTestCaseInfo().lineInfo );}
\DoxyCodeLine{14275         \}}
\DoxyCodeLine{14276     \}}
\DoxyCodeLine{14277 }
\DoxyCodeLine{14278     std::vector<TestCase> filterTests( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, TestSpec \textcolor{keyword}{const}\& testSpec, IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14279         std::vector<TestCase> filtered;}
\DoxyCodeLine{14280         filtered.reserve( testCases.size() );}
\DoxyCodeLine{14281         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& testCase : testCases) \{}
\DoxyCodeLine{14282             \textcolor{keywordflow}{if} ((!testSpec.hasFilters() \&\& !testCase.isHidden()) ||}
\DoxyCodeLine{14283                 (testSpec.hasFilters() \&\& matchTest(testCase, testSpec, config))) \{}
\DoxyCodeLine{14284                 filtered.push\_back(testCase);}
\DoxyCodeLine{14285             \}}
\DoxyCodeLine{14286         \}}
\DoxyCodeLine{14287         \textcolor{keywordflow}{return} filtered;}
\DoxyCodeLine{14288     \}}
\DoxyCodeLine{14289     std::vector<TestCase> \textcolor{keyword}{const}\& getAllTestCasesSorted( IConfig \textcolor{keyword}{const}\& config ) \{}
\DoxyCodeLine{14290         \textcolor{keywordflow}{return} getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );}
\DoxyCodeLine{14291     \}}
\DoxyCodeLine{14292 }
\DoxyCodeLine{14293     \textcolor{keywordtype}{void} TestRegistry::registerTest( TestCase \textcolor{keyword}{const}\& testCase ) \{}
\DoxyCodeLine{14294         std::string name = testCase.getTestCaseInfo().name;}
\DoxyCodeLine{14295         \textcolor{keywordflow}{if}( name.empty() ) \{}
\DoxyCodeLine{14296             ReusableStringStream rss;}
\DoxyCodeLine{14297             rss << \textcolor{stringliteral}{"{}Anonymous test case "{}} << ++m\_unnamedCount;}
\DoxyCodeLine{14298             \textcolor{keywordflow}{return} registerTest( testCase.withName( rss.str() ) );}
\DoxyCodeLine{14299         \}}
\DoxyCodeLine{14300         m\_functions.push\_back( testCase );}
\DoxyCodeLine{14301     \}}
\DoxyCodeLine{14302 }
\DoxyCodeLine{14303     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTests()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14304         \textcolor{keywordflow}{return} m\_functions;}
\DoxyCodeLine{14305     \}}
\DoxyCodeLine{14306     std::vector<TestCase> \textcolor{keyword}{const}\& TestRegistry::getAllTestsSorted( IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14307         \textcolor{keywordflow}{if}( m\_sortedFunctions.empty() )}
\DoxyCodeLine{14308             enforceNoDuplicateTestCases( m\_functions );}
\DoxyCodeLine{14309 }
\DoxyCodeLine{14310         \textcolor{keywordflow}{if}(  m\_currentSortOrder != config.runOrder() || m\_sortedFunctions.empty() ) \{}
\DoxyCodeLine{14311             m\_sortedFunctions = sortTests( config, m\_functions );}
\DoxyCodeLine{14312             m\_currentSortOrder = config.runOrder();}
\DoxyCodeLine{14313         \}}
\DoxyCodeLine{14314         \textcolor{keywordflow}{return} m\_sortedFunctions;}
\DoxyCodeLine{14315     \}}
\DoxyCodeLine{14316 }
\DoxyCodeLine{14318     TestInvokerAsFunction::TestInvokerAsFunction( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept : m\_testAsFunction( testAsFunction ) \{\}}
\DoxyCodeLine{14319 }
\DoxyCodeLine{14320     \textcolor{keywordtype}{void} TestInvokerAsFunction::invoke()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14321         m\_testAsFunction();}
\DoxyCodeLine{14322     \}}
\DoxyCodeLine{14323 }
\DoxyCodeLine{14324     std::string extractClassName( StringRef \textcolor{keyword}{const}\& classOrQualifiedMethodName ) \{}
\DoxyCodeLine{14325         std::string className(classOrQualifiedMethodName);}
\DoxyCodeLine{14326         \textcolor{keywordflow}{if}( startsWith( className, \textcolor{charliteral}{'\&'} ) )}
\DoxyCodeLine{14327         \{}
\DoxyCodeLine{14328             std::size\_t lastColons = className.rfind( \textcolor{stringliteral}{"{}::"{}} );}
\DoxyCodeLine{14329             std::size\_t penultimateColons = className.rfind( \textcolor{stringliteral}{"{}::"{}}, lastColons-\/1 );}
\DoxyCodeLine{14330             \textcolor{keywordflow}{if}( penultimateColons == std::string::npos )}
\DoxyCodeLine{14331                 penultimateColons = 1;}
\DoxyCodeLine{14332             className = className.substr( penultimateColons, lastColons-\/penultimateColons );}
\DoxyCodeLine{14333         \}}
\DoxyCodeLine{14334         \textcolor{keywordflow}{return} className;}
\DoxyCodeLine{14335     \}}
\DoxyCodeLine{14336 }
\DoxyCodeLine{14337 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{14338 \textcolor{comment}{// end catch\_test\_case\_registry\_impl.cpp}}
\DoxyCodeLine{14339 \textcolor{comment}{// start catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14340 }
\DoxyCodeLine{14341 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14342 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{14343 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{14344 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14345 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{14346 }
\DoxyCodeLine{14347 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14348 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{14349 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{14350 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14351 }
\DoxyCodeLine{14352 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14353 \textcolor{keyword}{namespace }TestCaseTracking \{}
\DoxyCodeLine{14354 }
\DoxyCodeLine{14355     NameAndLocation::NameAndLocation( std::string \textcolor{keyword}{const}\& \_name, SourceLineInfo \textcolor{keyword}{const}\& \_location )}
\DoxyCodeLine{14356     :   name( \_name ),}
\DoxyCodeLine{14357         location( \_location )}
\DoxyCodeLine{14358     \{\}}
\DoxyCodeLine{14359 }
\DoxyCodeLine{14360     ITracker::\string~ITracker() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14361 }
\DoxyCodeLine{14362     ITracker\& TrackerContext::startRun() \{}
\DoxyCodeLine{14363         m\_rootTracker = std::make\_shared<SectionTracker>( NameAndLocation( \textcolor{stringliteral}{"{}\{root\}"{}}, CATCH\_INTERNAL\_LINEINFO ), *\textcolor{keyword}{this}, \textcolor{keyword}{nullptr} );}
\DoxyCodeLine{14364         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14365         m\_runState = Executing;}
\DoxyCodeLine{14366         \textcolor{keywordflow}{return} *m\_rootTracker;}
\DoxyCodeLine{14367     \}}
\DoxyCodeLine{14368 }
\DoxyCodeLine{14369     \textcolor{keywordtype}{void} TrackerContext::endRun() \{}
\DoxyCodeLine{14370         m\_rootTracker.reset();}
\DoxyCodeLine{14371         m\_currentTracker = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14372         m\_runState = NotStarted;}
\DoxyCodeLine{14373     \}}
\DoxyCodeLine{14374 }
\DoxyCodeLine{14375     \textcolor{keywordtype}{void} TrackerContext::startCycle() \{}
\DoxyCodeLine{14376         m\_currentTracker = m\_rootTracker.get();}
\DoxyCodeLine{14377         m\_runState = Executing;}
\DoxyCodeLine{14378     \}}
\DoxyCodeLine{14379     \textcolor{keywordtype}{void} TrackerContext::completeCycle() \{}
\DoxyCodeLine{14380         m\_runState = CompletedCycle;}
\DoxyCodeLine{14381     \}}
\DoxyCodeLine{14382 }
\DoxyCodeLine{14383     \textcolor{keywordtype}{bool} TrackerContext::completedCycle()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14384         \textcolor{keywordflow}{return} m\_runState == CompletedCycle;}
\DoxyCodeLine{14385     \}}
\DoxyCodeLine{14386     ITracker\& TrackerContext::currentTracker() \{}
\DoxyCodeLine{14387         \textcolor{keywordflow}{return} *m\_currentTracker;}
\DoxyCodeLine{14388     \}}
\DoxyCodeLine{14389     \textcolor{keywordtype}{void} TrackerContext::setCurrentTracker( ITracker* tracker ) \{}
\DoxyCodeLine{14390         m\_currentTracker = tracker;}
\DoxyCodeLine{14391     \}}
\DoxyCodeLine{14392 }
\DoxyCodeLine{14393     TrackerBase::TrackerBase( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent ):}
\DoxyCodeLine{14394         ITracker(nameAndLocation),}
\DoxyCodeLine{14395         m\_ctx( ctx ),}
\DoxyCodeLine{14396         m\_parent( parent )}
\DoxyCodeLine{14397     \{\}}
\DoxyCodeLine{14398 }
\DoxyCodeLine{14399     \textcolor{keywordtype}{bool} TrackerBase::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14400         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully || m\_runState == Failed;}
\DoxyCodeLine{14401     \}}
\DoxyCodeLine{14402     \textcolor{keywordtype}{bool} TrackerBase::isSuccessfullyCompleted()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14403         \textcolor{keywordflow}{return} m\_runState == CompletedSuccessfully;}
\DoxyCodeLine{14404     \}}
\DoxyCodeLine{14405     \textcolor{keywordtype}{bool} TrackerBase::isOpen()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14406         \textcolor{keywordflow}{return} m\_runState != NotStarted \&\& !isComplete();}
\DoxyCodeLine{14407     \}}
\DoxyCodeLine{14408     \textcolor{keywordtype}{bool} TrackerBase::hasChildren()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14409         \textcolor{keywordflow}{return} !m\_children.empty();}
\DoxyCodeLine{14410     \}}
\DoxyCodeLine{14411 }
\DoxyCodeLine{14412     \textcolor{keywordtype}{void} TrackerBase::addChild( ITrackerPtr \textcolor{keyword}{const}\& child ) \{}
\DoxyCodeLine{14413         m\_children.push\_back( child );}
\DoxyCodeLine{14414     \}}
\DoxyCodeLine{14415 }
\DoxyCodeLine{14416     ITrackerPtr TrackerBase::findChild( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14417         \textcolor{keyword}{auto} it = std::find\_if( m\_children.begin(), m\_children.end(),}
\DoxyCodeLine{14418             [\&nameAndLocation]( ITrackerPtr \textcolor{keyword}{const}\& tracker )\{}
\DoxyCodeLine{14419                 return}
\DoxyCodeLine{14420                     tracker-\/>nameAndLocation().location == nameAndLocation.location \&\&}
\DoxyCodeLine{14421                     tracker-\/>nameAndLocation().name == nameAndLocation.name;}
\DoxyCodeLine{14422             \} );}
\DoxyCodeLine{14423         \textcolor{keywordflow}{return}( it != m\_children.end() )}
\DoxyCodeLine{14424             ? *it}
\DoxyCodeLine{14425             : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{14426     \}}
\DoxyCodeLine{14427     ITracker\& TrackerBase::parent() \{}
\DoxyCodeLine{14428         assert( m\_parent ); \textcolor{comment}{// Should always be non-\/null except for root}}
\DoxyCodeLine{14429         \textcolor{keywordflow}{return} *m\_parent;}
\DoxyCodeLine{14430     \}}
\DoxyCodeLine{14431 }
\DoxyCodeLine{14432     \textcolor{keywordtype}{void} TrackerBase::openChild() \{}
\DoxyCodeLine{14433         \textcolor{keywordflow}{if}( m\_runState != ExecutingChildren ) \{}
\DoxyCodeLine{14434             m\_runState = ExecutingChildren;}
\DoxyCodeLine{14435             \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14436                 m\_parent-\/>openChild();}
\DoxyCodeLine{14437         \}}
\DoxyCodeLine{14438     \}}
\DoxyCodeLine{14439 }
\DoxyCodeLine{14440     \textcolor{keywordtype}{bool} TrackerBase::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14441     \textcolor{keywordtype}{bool} TrackerBase::isGeneratorTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{14442 }
\DoxyCodeLine{14443     \textcolor{keywordtype}{void} TrackerBase::open() \{}
\DoxyCodeLine{14444         m\_runState = Executing;}
\DoxyCodeLine{14445         moveToThis();}
\DoxyCodeLine{14446         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14447             m\_parent-\/>openChild();}
\DoxyCodeLine{14448     \}}
\DoxyCodeLine{14449 }
\DoxyCodeLine{14450     \textcolor{keywordtype}{void} TrackerBase::close() \{}
\DoxyCodeLine{14451 }
\DoxyCodeLine{14452         \textcolor{comment}{// Close any still open children (e.g. generators)}}
\DoxyCodeLine{14453         \textcolor{keywordflow}{while}( \&m\_ctx.currentTracker() != \textcolor{keyword}{this} )}
\DoxyCodeLine{14454             m\_ctx.currentTracker().close();}
\DoxyCodeLine{14455 }
\DoxyCodeLine{14456         \textcolor{keywordflow}{switch}( m\_runState ) \{}
\DoxyCodeLine{14457             \textcolor{keywordflow}{case} NeedsAnotherRun:}
\DoxyCodeLine{14458                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14459 }
\DoxyCodeLine{14460             \textcolor{keywordflow}{case} Executing:}
\DoxyCodeLine{14461                 m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14462                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14463             \textcolor{keywordflow}{case} ExecutingChildren:}
\DoxyCodeLine{14464                 \textcolor{keywordflow}{if}( std::all\_of(m\_children.begin(), m\_children.end(), [](ITrackerPtr \textcolor{keyword}{const}\& t)\{ return t-\/>isComplete(); \}) )}
\DoxyCodeLine{14465                     m\_runState = CompletedSuccessfully;}
\DoxyCodeLine{14466                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{14467 }
\DoxyCodeLine{14468             \textcolor{keywordflow}{case} NotStarted:}
\DoxyCodeLine{14469             \textcolor{keywordflow}{case} CompletedSuccessfully:}
\DoxyCodeLine{14470             \textcolor{keywordflow}{case} Failed:}
\DoxyCodeLine{14471                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Illogical state: "{}} << m\_runState );}
\DoxyCodeLine{14472 }
\DoxyCodeLine{14473             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14474                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown state: "{}} << m\_runState );}
\DoxyCodeLine{14475         \}}
\DoxyCodeLine{14476         moveToParent();}
\DoxyCodeLine{14477         m\_ctx.completeCycle();}
\DoxyCodeLine{14478     \}}
\DoxyCodeLine{14479     \textcolor{keywordtype}{void} TrackerBase::fail() \{}
\DoxyCodeLine{14480         m\_runState = Failed;}
\DoxyCodeLine{14481         \textcolor{keywordflow}{if}( m\_parent )}
\DoxyCodeLine{14482             m\_parent-\/>markAsNeedingAnotherRun();}
\DoxyCodeLine{14483         moveToParent();}
\DoxyCodeLine{14484         m\_ctx.completeCycle();}
\DoxyCodeLine{14485     \}}
\DoxyCodeLine{14486     \textcolor{keywordtype}{void} TrackerBase::markAsNeedingAnotherRun() \{}
\DoxyCodeLine{14487         m\_runState = NeedsAnotherRun;}
\DoxyCodeLine{14488     \}}
\DoxyCodeLine{14489 }
\DoxyCodeLine{14490     \textcolor{keywordtype}{void} TrackerBase::moveToParent() \{}
\DoxyCodeLine{14491         assert( m\_parent );}
\DoxyCodeLine{14492         m\_ctx.setCurrentTracker( m\_parent );}
\DoxyCodeLine{14493     \}}
\DoxyCodeLine{14494     \textcolor{keywordtype}{void} TrackerBase::moveToThis() \{}
\DoxyCodeLine{14495         m\_ctx.setCurrentTracker( \textcolor{keyword}{this} );}
\DoxyCodeLine{14496     \}}
\DoxyCodeLine{14497 }
\DoxyCodeLine{14498     SectionTracker::SectionTracker( NameAndLocation \textcolor{keyword}{const}\& nameAndLocation, TrackerContext\& ctx, ITracker* parent )}
\DoxyCodeLine{14499     :   TrackerBase( nameAndLocation, ctx, parent ),}
\DoxyCodeLine{14500         m\_trimmed\_name(trim(nameAndLocation.name))}
\DoxyCodeLine{14501     \{}
\DoxyCodeLine{14502         \textcolor{keywordflow}{if}( parent ) \{}
\DoxyCodeLine{14503             \textcolor{keywordflow}{while}( !parent-\/>isSectionTracker() )}
\DoxyCodeLine{14504                 parent = \&parent-\/>parent();}
\DoxyCodeLine{14505 }
\DoxyCodeLine{14506             SectionTracker\& parentSection = \textcolor{keyword}{static\_cast<}SectionTracker\&\textcolor{keyword}{>}( *parent );}
\DoxyCodeLine{14507             addNextFilters( parentSection.m\_filters );}
\DoxyCodeLine{14508         \}}
\DoxyCodeLine{14509     \}}
\DoxyCodeLine{14510 }
\DoxyCodeLine{14511     \textcolor{keywordtype}{bool} SectionTracker::isComplete()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14512         \textcolor{keywordtype}{bool} complete = \textcolor{keyword}{true};}
\DoxyCodeLine{14513 }
\DoxyCodeLine{14514         \textcolor{keywordflow}{if} (m\_filters.empty()}
\DoxyCodeLine{14515             || m\_filters[0] == \textcolor{stringliteral}{"{}"{}}}
\DoxyCodeLine{14516             || std::find(m\_filters.begin(), m\_filters.end(), m\_trimmed\_name) != m\_filters.end()) \{}
\DoxyCodeLine{14517             complete = TrackerBase::isComplete();}
\DoxyCodeLine{14518         \}}
\DoxyCodeLine{14519         \textcolor{keywordflow}{return} complete;}
\DoxyCodeLine{14520     \}}
\DoxyCodeLine{14521 }
\DoxyCodeLine{14522     \textcolor{keywordtype}{bool} SectionTracker::isSectionTracker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{14523 }
\DoxyCodeLine{14524     SectionTracker\& SectionTracker::acquire( TrackerContext\& ctx, NameAndLocation \textcolor{keyword}{const}\& nameAndLocation ) \{}
\DoxyCodeLine{14525         std::shared\_ptr<SectionTracker> section;}
\DoxyCodeLine{14526 }
\DoxyCodeLine{14527         ITracker\& currentTracker = ctx.currentTracker();}
\DoxyCodeLine{14528         \textcolor{keywordflow}{if}( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) \{}
\DoxyCodeLine{14529             assert( childTracker );}
\DoxyCodeLine{14530             assert( childTracker-\/>isSectionTracker() );}
\DoxyCodeLine{14531             section = std::static\_pointer\_cast<SectionTracker>( childTracker );}
\DoxyCodeLine{14532         \}}
\DoxyCodeLine{14533         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{14534             section = std::make\_shared<SectionTracker>( nameAndLocation, ctx, \&currentTracker );}
\DoxyCodeLine{14535             currentTracker.addChild( section );}
\DoxyCodeLine{14536         \}}
\DoxyCodeLine{14537         \textcolor{keywordflow}{if}( !ctx.completedCycle() )}
\DoxyCodeLine{14538             section-\/>tryOpen();}
\DoxyCodeLine{14539         \textcolor{keywordflow}{return} *section;}
\DoxyCodeLine{14540     \}}
\DoxyCodeLine{14541 }
\DoxyCodeLine{14542     \textcolor{keywordtype}{void} SectionTracker::tryOpen() \{}
\DoxyCodeLine{14543         \textcolor{keywordflow}{if}( !isComplete() )}
\DoxyCodeLine{14544             open();}
\DoxyCodeLine{14545     \}}
\DoxyCodeLine{14546 }
\DoxyCodeLine{14547     \textcolor{keywordtype}{void} SectionTracker::addInitialFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14548         \textcolor{keywordflow}{if}( !filters.empty() ) \{}
\DoxyCodeLine{14549             m\_filters.reserve( m\_filters.size() + filters.size() + 2 );}
\DoxyCodeLine{14550             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Root -\/ should never be consulted}}
\DoxyCodeLine{14551             m\_filters.emplace\_back(\textcolor{stringliteral}{"{}"{}}); \textcolor{comment}{// Test Case -\/ not a section filter}}
\DoxyCodeLine{14552             m\_filters.insert( m\_filters.end(), filters.begin(), filters.end() );}
\DoxyCodeLine{14553         \}}
\DoxyCodeLine{14554     \}}
\DoxyCodeLine{14555     \textcolor{keywordtype}{void} SectionTracker::addNextFilters( std::vector<std::string> \textcolor{keyword}{const}\& filters ) \{}
\DoxyCodeLine{14556         \textcolor{keywordflow}{if}( filters.size() > 1 )}
\DoxyCodeLine{14557             m\_filters.insert( m\_filters.end(), filters.begin()+1, filters.end() );}
\DoxyCodeLine{14558     \}}
\DoxyCodeLine{14559 }
\DoxyCodeLine{14560     std::vector<std::string> \textcolor{keyword}{const}\& SectionTracker::getFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14561         \textcolor{keywordflow}{return} m\_filters;}
\DoxyCodeLine{14562     \}}
\DoxyCodeLine{14563 }
\DoxyCodeLine{14564     std::string \textcolor{keyword}{const}\& SectionTracker::trimmedName()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14565         \textcolor{keywordflow}{return} m\_trimmed\_name;}
\DoxyCodeLine{14566     \}}
\DoxyCodeLine{14567 }
\DoxyCodeLine{14568 \} \textcolor{comment}{// namespace TestCaseTracking}}
\DoxyCodeLine{14569 }
\DoxyCodeLine{14570 \textcolor{keyword}{using} TestCaseTracking::ITracker;}
\DoxyCodeLine{14571 \textcolor{keyword}{using} TestCaseTracking::TrackerContext;}
\DoxyCodeLine{14572 \textcolor{keyword}{using} TestCaseTracking::SectionTracker;}
\DoxyCodeLine{14573 }
\DoxyCodeLine{14574 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14575 }
\DoxyCodeLine{14576 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14577 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{14578 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{14579 \textcolor{comment}{// end catch\_test\_case\_tracker.cpp}}
\DoxyCodeLine{14580 \textcolor{comment}{// start catch\_test\_registry.cpp}}
\DoxyCodeLine{14581 }
\DoxyCodeLine{14582 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14583 }
\DoxyCodeLine{14584     \textcolor{keyword}{auto} makeTestInvoker( \textcolor{keywordtype}{void}(*testAsFunction)() ) noexcept -\/> ITestInvoker* \{}
\DoxyCodeLine{14585         \textcolor{keywordflow}{return} \textcolor{keyword}{new}(std::nothrow) TestInvokerAsFunction( testAsFunction );}
\DoxyCodeLine{14586     \}}
\DoxyCodeLine{14587 }
\DoxyCodeLine{14588     NameAndTags::NameAndTags( StringRef \textcolor{keyword}{const}\& name\_ , StringRef \textcolor{keyword}{const}\& tags\_ ) noexcept : name( name\_ ), tags( tags\_ ) \{\}}
\DoxyCodeLine{14589 }
\DoxyCodeLine{14590     AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo \textcolor{keyword}{const}\& lineInfo, StringRef \textcolor{keyword}{const}\& classOrMethod, NameAndTags \textcolor{keyword}{const}\& nameAndTags ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{14591         CATCH\_TRY \{}
\DoxyCodeLine{14592             getMutableRegistryHub()}
\DoxyCodeLine{14593                     .registerTest(}
\DoxyCodeLine{14594                         makeTestCase(}
\DoxyCodeLine{14595                             invoker,}
\DoxyCodeLine{14596                             extractClassName( classOrMethod ),}
\DoxyCodeLine{14597                             nameAndTags,}
\DoxyCodeLine{14598                             lineInfo));}
\DoxyCodeLine{14599         \} CATCH\_CATCH\_ALL \{}
\DoxyCodeLine{14600             \textcolor{comment}{// Do not throw when constructing global objects, instead register the exception to be processed later}}
\DoxyCodeLine{14601             getMutableRegistryHub().registerStartupException();}
\DoxyCodeLine{14602         \}}
\DoxyCodeLine{14603     \}}
\DoxyCodeLine{14604 }
\DoxyCodeLine{14605     AutoReg::\string~AutoReg() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14606 \}}
\DoxyCodeLine{14607 \textcolor{comment}{// end catch\_test\_registry.cpp}}
\DoxyCodeLine{14608 \textcolor{comment}{// start catch\_test\_spec.cpp}}
\DoxyCodeLine{14609 }
\DoxyCodeLine{14610 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{14611 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{14612 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{14613 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{14614 }
\DoxyCodeLine{14615 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14616 }
\DoxyCodeLine{14617     TestSpec::Pattern::Pattern( std::string \textcolor{keyword}{const}\& name )}
\DoxyCodeLine{14618     : m\_name( name )}
\DoxyCodeLine{14619     \{\}}
\DoxyCodeLine{14620 }
\DoxyCodeLine{14621     TestSpec::Pattern::\string~Pattern() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{14622 }
\DoxyCodeLine{14623     std::string \textcolor{keyword}{const}\& TestSpec::Pattern::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14624         \textcolor{keywordflow}{return} m\_name;}
\DoxyCodeLine{14625     \}}
\DoxyCodeLine{14626 }
\DoxyCodeLine{14627     TestSpec::NamePattern::NamePattern( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14628     : Pattern( filterString )}
\DoxyCodeLine{14629     , m\_wildcardPattern( toLower( name ), CaseSensitive::No )}
\DoxyCodeLine{14630     \{\}}
\DoxyCodeLine{14631 }
\DoxyCodeLine{14632     \textcolor{keywordtype}{bool} TestSpec::NamePattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14633         \textcolor{keywordflow}{return} m\_wildcardPattern.matches( testCase.name );}
\DoxyCodeLine{14634     \}}
\DoxyCodeLine{14635 }
\DoxyCodeLine{14636     TestSpec::TagPattern::TagPattern( std::string \textcolor{keyword}{const}\& tag, std::string \textcolor{keyword}{const}\& filterString )}
\DoxyCodeLine{14637     : Pattern( filterString )}
\DoxyCodeLine{14638     , m\_tag( toLower( tag ) )}
\DoxyCodeLine{14639     \{\}}
\DoxyCodeLine{14640 }
\DoxyCodeLine{14641     \textcolor{keywordtype}{bool} TestSpec::TagPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14642         \textcolor{keywordflow}{return} std::find(begin(testCase.lcaseTags),}
\DoxyCodeLine{14643                          end(testCase.lcaseTags),}
\DoxyCodeLine{14644                          m\_tag) != end(testCase.lcaseTags);}
\DoxyCodeLine{14645     \}}
\DoxyCodeLine{14646 }
\DoxyCodeLine{14647     TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr \textcolor{keyword}{const}\& underlyingPattern )}
\DoxyCodeLine{14648     : Pattern( underlyingPattern-\/>name() )}
\DoxyCodeLine{14649     , m\_underlyingPattern( underlyingPattern )}
\DoxyCodeLine{14650     \{\}}
\DoxyCodeLine{14651 }
\DoxyCodeLine{14652     \textcolor{keywordtype}{bool} TestSpec::ExcludedPattern::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14653         \textcolor{keywordflow}{return} !m\_underlyingPattern-\/>matches( testCase );}
\DoxyCodeLine{14654     \}}
\DoxyCodeLine{14655 }
\DoxyCodeLine{14656     \textcolor{keywordtype}{bool} TestSpec::Filter::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14657         \textcolor{keywordflow}{return} std::all\_of( m\_patterns.begin(), m\_patterns.end(), [\&]( PatternPtr \textcolor{keyword}{const}\& p )\{ return p-\/>matches( testCase ); \} );}
\DoxyCodeLine{14658     \}}
\DoxyCodeLine{14659 }
\DoxyCodeLine{14660     std::string TestSpec::Filter::name()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14661         std::string name;}
\DoxyCodeLine{14662         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& p : m\_patterns )}
\DoxyCodeLine{14663             name += p-\/>name();}
\DoxyCodeLine{14664         \textcolor{keywordflow}{return} name;}
\DoxyCodeLine{14665     \}}
\DoxyCodeLine{14666 }
\DoxyCodeLine{14667     \textcolor{keywordtype}{bool} TestSpec::hasFilters()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14668         \textcolor{keywordflow}{return} !m\_filters.empty();}
\DoxyCodeLine{14669     \}}
\DoxyCodeLine{14670 }
\DoxyCodeLine{14671     \textcolor{keywordtype}{bool} TestSpec::matches( TestCaseInfo \textcolor{keyword}{const}\& testCase )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14672         \textcolor{keywordflow}{return} std::any\_of( m\_filters.begin(), m\_filters.end(), [\&]( Filter \textcolor{keyword}{const}\& f )\{ return f.matches( testCase ); \} );}
\DoxyCodeLine{14673     \}}
\DoxyCodeLine{14674 }
\DoxyCodeLine{14675     TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> \textcolor{keyword}{const}\& testCases, IConfig \textcolor{keyword}{const}\& config )\textcolor{keyword}{ const}}
\DoxyCodeLine{14676 \textcolor{keyword}{    }\{}
\DoxyCodeLine{14677         Matches matches( m\_filters.size() );}
\DoxyCodeLine{14678         std::transform( m\_filters.begin(), m\_filters.end(), matches.begin(), [\&]( Filter \textcolor{keyword}{const}\& filter )\{}
\DoxyCodeLine{14679             std::vector<TestCase const*> currentMatches;}
\DoxyCodeLine{14680             for( auto const\& test : testCases )}
\DoxyCodeLine{14681                 if( isThrowSafe( test, config ) \&\& filter.matches( test ) )}
\DoxyCodeLine{14682                     currentMatches.emplace\_back( \&test );}
\DoxyCodeLine{14683             return FilterMatch\{ filter.name(), currentMatches \};}
\DoxyCodeLine{14684         \} );}
\DoxyCodeLine{14685         \textcolor{keywordflow}{return} matches;}
\DoxyCodeLine{14686     \}}
\DoxyCodeLine{14687 }
\DoxyCodeLine{14688     \textcolor{keyword}{const} TestSpec::vectorStrings\& TestSpec::getInvalidArgs()\textcolor{keyword}{ const}\{}
\DoxyCodeLine{14689         \textcolor{keywordflow}{return}  (m\_invalidArgs);}
\DoxyCodeLine{14690     \}}
\DoxyCodeLine{14691 }
\DoxyCodeLine{14692 \}}
\DoxyCodeLine{14693 \textcolor{comment}{// end catch\_test\_spec.cpp}}
\DoxyCodeLine{14694 \textcolor{comment}{// start catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14695 }
\DoxyCodeLine{14696 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14697 }
\DoxyCodeLine{14698     TestSpecParser::TestSpecParser( ITagAliasRegistry \textcolor{keyword}{const}\& tagAliases ) : m\_tagAliases( \&tagAliases ) \{\}}
\DoxyCodeLine{14699 }
\DoxyCodeLine{14700     TestSpecParser\& TestSpecParser::parse( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14701         m\_mode = None;}
\DoxyCodeLine{14702         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14703         m\_arg = m\_tagAliases-\/>expandAliases( arg );}
\DoxyCodeLine{14704         m\_escapeChars.clear();}
\DoxyCodeLine{14705         m\_substring.reserve(m\_arg.size());}
\DoxyCodeLine{14706         m\_patternName.reserve(m\_arg.size());}
\DoxyCodeLine{14707         m\_realPatternPos = 0;}
\DoxyCodeLine{14708 }
\DoxyCodeLine{14709         \textcolor{keywordflow}{for}( m\_pos = 0; m\_pos < m\_arg.size(); ++m\_pos )}
\DoxyCodeLine{14710           \textcolor{comment}{//if visitChar fails}}
\DoxyCodeLine{14711            if( !visitChar( m\_arg[m\_pos] ) )\{}
\DoxyCodeLine{14712                m\_testSpec.m\_invalidArgs.push\_back(arg);}
\DoxyCodeLine{14713                \textcolor{keywordflow}{break};}
\DoxyCodeLine{14714            \}}
\DoxyCodeLine{14715         endMode();}
\DoxyCodeLine{14716         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{14717     \}}
\DoxyCodeLine{14718     TestSpec TestSpecParser::testSpec() \{}
\DoxyCodeLine{14719         addFilter();}
\DoxyCodeLine{14720         \textcolor{keywordflow}{return} m\_testSpec;}
\DoxyCodeLine{14721     \}}
\DoxyCodeLine{14722     \textcolor{keywordtype}{bool} TestSpecParser::visitChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14723         \textcolor{keywordflow}{if}( (m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) ) \{}
\DoxyCodeLine{14724             escape();}
\DoxyCodeLine{14725             addCharToPattern(c);}
\DoxyCodeLine{14726             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14727         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}((m\_mode != EscapedName) \&\& (c == \textcolor{charliteral}{','}) )  \{}
\DoxyCodeLine{14728             \textcolor{keywordflow}{return} separate();}
\DoxyCodeLine{14729         \}}
\DoxyCodeLine{14730 }
\DoxyCodeLine{14731         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14732         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14733             \textcolor{keywordflow}{if}( processNoneChar( c ) )}
\DoxyCodeLine{14734                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14735             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14736         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14737             processNameChar( c );}
\DoxyCodeLine{14738             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14739         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14740             endMode();}
\DoxyCodeLine{14741             addCharToPattern(c);}
\DoxyCodeLine{14742             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14743         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14744         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14745         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14746             \textcolor{keywordflow}{if}( processOtherChar( c ) )}
\DoxyCodeLine{14747                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14748             \textcolor{keywordflow}{break};}
\DoxyCodeLine{14749         \}}
\DoxyCodeLine{14750 }
\DoxyCodeLine{14751         m\_substring += c;}
\DoxyCodeLine{14752         \textcolor{keywordflow}{if}( !isControlChar( c ) ) \{}
\DoxyCodeLine{14753             m\_patternName += c;}
\DoxyCodeLine{14754             m\_realPatternPos++;}
\DoxyCodeLine{14755         \}}
\DoxyCodeLine{14756         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14757     \}}
\DoxyCodeLine{14758     \textcolor{comment}{// Two of the processing methods return true to signal the caller to return}}
\DoxyCodeLine{14759     \textcolor{comment}{// without adding the given character to the current pattern strings}}
\DoxyCodeLine{14760     \textcolor{keywordtype}{bool} TestSpecParser::processNoneChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14761         \textcolor{keywordflow}{switch}( c ) \{}
\DoxyCodeLine{14762         \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{14763             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14764         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string~'}:}
\DoxyCodeLine{14765             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14766             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14767         \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}:}
\DoxyCodeLine{14768             startNewMode( Tag );}
\DoxyCodeLine{14769             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14770         \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{14771             startNewMode( QuotedName );}
\DoxyCodeLine{14772             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14773         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14774             startNewMode( Name );}
\DoxyCodeLine{14775             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14776         \}}
\DoxyCodeLine{14777     \}}
\DoxyCodeLine{14778     \textcolor{keywordtype}{void} TestSpecParser::processNameChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14779         \textcolor{keywordflow}{if}( c == \textcolor{charliteral}{'['} ) \{}
\DoxyCodeLine{14780             \textcolor{keywordflow}{if}( m\_substring == \textcolor{stringliteral}{"{}exclude:"{}} )}
\DoxyCodeLine{14781                 m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14782             \textcolor{keywordflow}{else}}
\DoxyCodeLine{14783                 endMode();}
\DoxyCodeLine{14784             startNewMode( Tag );}
\DoxyCodeLine{14785         \}}
\DoxyCodeLine{14786     \}}
\DoxyCodeLine{14787     \textcolor{keywordtype}{bool} TestSpecParser::processOtherChar( \textcolor{keywordtype}{char} c ) \{}
\DoxyCodeLine{14788         \textcolor{keywordflow}{if}( !isControlChar( c ) )}
\DoxyCodeLine{14789             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14790         m\_substring += c;}
\DoxyCodeLine{14791         endMode();}
\DoxyCodeLine{14792         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14793     \}}
\DoxyCodeLine{14794     \textcolor{keywordtype}{void} TestSpecParser::startNewMode( Mode mode ) \{}
\DoxyCodeLine{14795         m\_mode = mode;}
\DoxyCodeLine{14796     \}}
\DoxyCodeLine{14797     \textcolor{keywordtype}{void} TestSpecParser::endMode() \{}
\DoxyCodeLine{14798         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14799         \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14800         \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14801             \textcolor{keywordflow}{return} addNamePattern();}
\DoxyCodeLine{14802         \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14803             \textcolor{keywordflow}{return} addTagPattern();}
\DoxyCodeLine{14804         \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14805             revertBackToLastMode();}
\DoxyCodeLine{14806             \textcolor{keywordflow}{return};}
\DoxyCodeLine{14807         \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14808         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14809             \textcolor{keywordflow}{return} startNewMode( None );}
\DoxyCodeLine{14810         \}}
\DoxyCodeLine{14811     \}}
\DoxyCodeLine{14812     \textcolor{keywordtype}{void} TestSpecParser::escape() \{}
\DoxyCodeLine{14813         saveLastMode();}
\DoxyCodeLine{14814         m\_mode = EscapedName;}
\DoxyCodeLine{14815         m\_escapeChars.push\_back(m\_realPatternPos);}
\DoxyCodeLine{14816     \}}
\DoxyCodeLine{14817     \textcolor{keywordtype}{bool} TestSpecParser::isControlChar( \textcolor{keywordtype}{char} c )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{14818         \textcolor{keywordflow}{switch}( m\_mode ) \{}
\DoxyCodeLine{14819             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{14820                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14821             \textcolor{keywordflow}{case} None:}
\DoxyCodeLine{14822                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'\string~'};}
\DoxyCodeLine{14823             \textcolor{keywordflow}{case} Name:}
\DoxyCodeLine{14824                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['};}
\DoxyCodeLine{14825             \textcolor{keywordflow}{case} EscapedName:}
\DoxyCodeLine{14826                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{14827             \textcolor{keywordflow}{case} QuotedName:}
\DoxyCodeLine{14828                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{14829             \textcolor{keywordflow}{case} Tag:}
\DoxyCodeLine{14830                 \textcolor{keywordflow}{return} c == \textcolor{charliteral}{'['} || c == \textcolor{charliteral}{']'};}
\DoxyCodeLine{14831         \}}
\DoxyCodeLine{14832     \}}
\DoxyCodeLine{14833 }
\DoxyCodeLine{14834     \textcolor{keywordtype}{void} TestSpecParser::addFilter() \{}
\DoxyCodeLine{14835         \textcolor{keywordflow}{if}( !m\_currentFilter.m\_patterns.empty() ) \{}
\DoxyCodeLine{14836             m\_testSpec.m\_filters.push\_back( m\_currentFilter );}
\DoxyCodeLine{14837             m\_currentFilter = TestSpec::Filter();}
\DoxyCodeLine{14838         \}}
\DoxyCodeLine{14839     \}}
\DoxyCodeLine{14840 }
\DoxyCodeLine{14841     \textcolor{keywordtype}{void} TestSpecParser::saveLastMode() \{}
\DoxyCodeLine{14842       lastMode = m\_mode;}
\DoxyCodeLine{14843     \}}
\DoxyCodeLine{14844 }
\DoxyCodeLine{14845     \textcolor{keywordtype}{void} TestSpecParser::revertBackToLastMode() \{}
\DoxyCodeLine{14846       m\_mode = lastMode;}
\DoxyCodeLine{14847     \}}
\DoxyCodeLine{14848 }
\DoxyCodeLine{14849     \textcolor{keywordtype}{bool} TestSpecParser::separate() \{}
\DoxyCodeLine{14850       \textcolor{keywordflow}{if}( (m\_mode==QuotedName) || (m\_mode==Tag) )\{}
\DoxyCodeLine{14851          \textcolor{comment}{//invalid argument, signal failure to previous scope.}}
\DoxyCodeLine{14852          m\_mode = None;}
\DoxyCodeLine{14853          m\_pos = m\_arg.size();}
\DoxyCodeLine{14854          m\_substring.clear();}
\DoxyCodeLine{14855          m\_patternName.clear();}
\DoxyCodeLine{14856          m\_realPatternPos = 0;}
\DoxyCodeLine{14857          \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{14858       \}}
\DoxyCodeLine{14859       endMode();}
\DoxyCodeLine{14860       addFilter();}
\DoxyCodeLine{14861       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{//success}}
\DoxyCodeLine{14862     \}}
\DoxyCodeLine{14863 }
\DoxyCodeLine{14864     std::string TestSpecParser::preprocessPattern() \{}
\DoxyCodeLine{14865         std::string token = m\_patternName;}
\DoxyCodeLine{14866         \textcolor{keywordflow}{for} (std::size\_t i = 0; i < m\_escapeChars.size(); ++i)}
\DoxyCodeLine{14867             token = token.substr(0, m\_escapeChars[i] -\/ i) + token.substr(m\_escapeChars[i] -\/ i + 1);}
\DoxyCodeLine{14868         m\_escapeChars.clear();}
\DoxyCodeLine{14869         \textcolor{keywordflow}{if} (startsWith(token, \textcolor{stringliteral}{"{}exclude:"{}})) \{}
\DoxyCodeLine{14870             m\_exclusion = \textcolor{keyword}{true};}
\DoxyCodeLine{14871             token = token.substr(8);}
\DoxyCodeLine{14872         \}}
\DoxyCodeLine{14873 }
\DoxyCodeLine{14874         m\_patternName.clear();}
\DoxyCodeLine{14875         m\_realPatternPos = 0;}
\DoxyCodeLine{14876 }
\DoxyCodeLine{14877         \textcolor{keywordflow}{return} token;}
\DoxyCodeLine{14878     \}}
\DoxyCodeLine{14879 }
\DoxyCodeLine{14880     \textcolor{keywordtype}{void} TestSpecParser::addNamePattern() \{}
\DoxyCodeLine{14881         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14882 }
\DoxyCodeLine{14883         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14884             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::NamePattern>(token, m\_substring);}
\DoxyCodeLine{14885             \textcolor{keywordflow}{if} (m\_exclusion)}
\DoxyCodeLine{14886                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14887             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14888         \}}
\DoxyCodeLine{14889         m\_substring.clear();}
\DoxyCodeLine{14890         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14891         m\_mode = None;}
\DoxyCodeLine{14892     \}}
\DoxyCodeLine{14893 }
\DoxyCodeLine{14894     \textcolor{keywordtype}{void} TestSpecParser::addTagPattern() \{}
\DoxyCodeLine{14895         \textcolor{keyword}{auto} token = preprocessPattern();}
\DoxyCodeLine{14896 }
\DoxyCodeLine{14897         \textcolor{keywordflow}{if} (!token.empty()) \{}
\DoxyCodeLine{14898             \textcolor{comment}{// If the tag pattern is the "{}hide and tag"{} shorthand (e.g. [.foo])}}
\DoxyCodeLine{14899             \textcolor{comment}{// we have to create a separate hide tag and shorten the real one}}
\DoxyCodeLine{14900             \textcolor{keywordflow}{if} (token.size() > 1 \&\& token[0] == \textcolor{charliteral}{'.'}) \{}
\DoxyCodeLine{14901                 token.erase(token.begin());}
\DoxyCodeLine{14902                 TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(\textcolor{stringliteral}{"{}."{}}, m\_substring);}
\DoxyCodeLine{14903                 \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14904                     pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14905                 \}}
\DoxyCodeLine{14906                 m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14907             \}}
\DoxyCodeLine{14908 }
\DoxyCodeLine{14909             TestSpec::PatternPtr pattern = std::make\_shared<TestSpec::TagPattern>(token, m\_substring);}
\DoxyCodeLine{14910 }
\DoxyCodeLine{14911             \textcolor{keywordflow}{if} (m\_exclusion) \{}
\DoxyCodeLine{14912                 pattern = std::make\_shared<TestSpec::ExcludedPattern>(pattern);}
\DoxyCodeLine{14913             \}}
\DoxyCodeLine{14914             m\_currentFilter.m\_patterns.push\_back(pattern);}
\DoxyCodeLine{14915         \}}
\DoxyCodeLine{14916         m\_substring.clear();}
\DoxyCodeLine{14917         m\_exclusion = \textcolor{keyword}{false};}
\DoxyCodeLine{14918         m\_mode = None;}
\DoxyCodeLine{14919     \}}
\DoxyCodeLine{14920 }
\DoxyCodeLine{14921     TestSpec parseTestSpec( std::string \textcolor{keyword}{const}\& arg ) \{}
\DoxyCodeLine{14922         \textcolor{keywordflow}{return} TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();}
\DoxyCodeLine{14923     \}}
\DoxyCodeLine{14924 }
\DoxyCodeLine{14925 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14926 \textcolor{comment}{// end catch\_test\_spec\_parser.cpp}}
\DoxyCodeLine{14927 \textcolor{comment}{// start catch\_timer.cpp}}
\DoxyCodeLine{14928 }
\DoxyCodeLine{14929 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{14930 }
\DoxyCodeLine{14931 \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t nanosecondsInSecond = 1000000000;}
\DoxyCodeLine{14932 }
\DoxyCodeLine{14933 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{14934 }
\DoxyCodeLine{14935     \textcolor{keyword}{auto} getCurrentNanosecondsSinceEpoch() -\/> uint64\_t \{}
\DoxyCodeLine{14936         \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::nanoseconds>( std::chrono::high\_resolution\_clock::now().time\_since\_epoch() ).count();}
\DoxyCodeLine{14937     \}}
\DoxyCodeLine{14938 }
\DoxyCodeLine{14939     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{14940         \textcolor{keyword}{auto} estimateClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14941             uint64\_t sum = 0;}
\DoxyCodeLine{14942             \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t iterations = 1000000;}
\DoxyCodeLine{14943 }
\DoxyCodeLine{14944             \textcolor{keyword}{auto} startTime = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14945 }
\DoxyCodeLine{14946             \textcolor{keywordflow}{for}( std::size\_t i = 0; i < iterations; ++i ) \{}
\DoxyCodeLine{14947 }
\DoxyCodeLine{14948                 uint64\_t ticks;}
\DoxyCodeLine{14949                 uint64\_t baseTicks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14950                 \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{14951                     ticks = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14952                 \} \textcolor{keywordflow}{while}( ticks == baseTicks );}
\DoxyCodeLine{14953 }
\DoxyCodeLine{14954                 \textcolor{keyword}{auto} delta = ticks -\/ baseTicks;}
\DoxyCodeLine{14955                 sum += delta;}
\DoxyCodeLine{14956 }
\DoxyCodeLine{14957                 \textcolor{comment}{// If we have been calibrating for over 3 seconds -\/-\/ the clock}}
\DoxyCodeLine{14958                 \textcolor{comment}{// is terrible and we should move on.}}
\DoxyCodeLine{14959                 \textcolor{comment}{// TBD: How to signal that the measured resolution is probably wrong?}}
\DoxyCodeLine{14960                 \textcolor{keywordflow}{if} (ticks > startTime + 3 * nanosecondsInSecond) \{}
\DoxyCodeLine{14961                     \textcolor{keywordflow}{return} sum / ( i + 1u );}
\DoxyCodeLine{14962                 \}}
\DoxyCodeLine{14963             \}}
\DoxyCodeLine{14964 }
\DoxyCodeLine{14965             \textcolor{comment}{// We're just taking the mean, here. To do better we could take the std. dev and exclude outliers}}
\DoxyCodeLine{14966             \textcolor{comment}{// -\/ and potentially do more iterations if there's a high variance.}}
\DoxyCodeLine{14967             \textcolor{keywordflow}{return} sum/iterations;}
\DoxyCodeLine{14968         \}}
\DoxyCodeLine{14969     \}}
\DoxyCodeLine{14970     \textcolor{keyword}{auto} getEstimatedClockResolution() -\/> uint64\_t \{}
\DoxyCodeLine{14971         \textcolor{keyword}{static} \textcolor{keyword}{auto} s\_resolution = estimateClockResolution();}
\DoxyCodeLine{14972         \textcolor{keywordflow}{return} s\_resolution;}
\DoxyCodeLine{14973     \}}
\DoxyCodeLine{14974 }
\DoxyCodeLine{14975     \textcolor{keywordtype}{void} Timer::start() \{}
\DoxyCodeLine{14976        m\_nanoseconds = getCurrentNanosecondsSinceEpoch();}
\DoxyCodeLine{14977     \}}
\DoxyCodeLine{14978     \textcolor{keyword}{auto} Timer::getElapsedNanoseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14979         \textcolor{keywordflow}{return} getCurrentNanosecondsSinceEpoch() -\/ m\_nanoseconds;}
\DoxyCodeLine{14980     \}}
\DoxyCodeLine{14981     \textcolor{keyword}{auto} Timer::getElapsedMicroseconds() const -\/> uint64\_t \{}
\DoxyCodeLine{14982         \textcolor{keywordflow}{return} getElapsedNanoseconds()/1000;}
\DoxyCodeLine{14983     \}}
\DoxyCodeLine{14984     \textcolor{keyword}{auto} Timer::getElapsedMilliseconds() const -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{14985         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(getElapsedMicroseconds()/1000);}
\DoxyCodeLine{14986     \}}
\DoxyCodeLine{14987     \textcolor{keyword}{auto} Timer::getElapsedSeconds() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{14988         \textcolor{keywordflow}{return} getElapsedMicroseconds()/1000000.0;}
\DoxyCodeLine{14989     \}}
\DoxyCodeLine{14990 }
\DoxyCodeLine{14991 \} \textcolor{comment}{// namespace Catch}}
\DoxyCodeLine{14992 \textcolor{comment}{// end catch\_timer.cpp}}
\DoxyCodeLine{14993 \textcolor{comment}{// start catch\_tostring.cpp}}
\DoxyCodeLine{14994 }
\DoxyCodeLine{14995 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{14996 \textcolor{preprocessor}{\#    pragma clang diagnostic push}}
\DoxyCodeLine{14997 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wexit-\/time-\/destructors"{}}}
\DoxyCodeLine{14998 \textcolor{preprocessor}{\#    pragma clang diagnostic ignored "{}-\/Wglobal-\/constructors"{}}}
\DoxyCodeLine{14999 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15000 }
\DoxyCodeLine{15001 \textcolor{comment}{// Enable specific decls locally}}
\DoxyCodeLine{15002 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER)}}
\DoxyCodeLine{15003 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_ENABLE\_CHRONO\_STRINGMAKER}}
\DoxyCodeLine{15004 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15005 }
\DoxyCodeLine{15006 \textcolor{preprocessor}{\#include <cmath>}}
\DoxyCodeLine{15007 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{15008 }
\DoxyCodeLine{15009 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15010 }
\DoxyCodeLine{15011 \textcolor{keyword}{namespace }Detail \{}
\DoxyCodeLine{15012 }
\DoxyCodeLine{15013     \textcolor{keyword}{const} std::string unprintableString = \textcolor{stringliteral}{"{}\{?\}"{}};}
\DoxyCodeLine{15014 }
\DoxyCodeLine{15015     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{15016         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hexThreshold = 255;}
\DoxyCodeLine{15017 }
\DoxyCodeLine{15018         \textcolor{keyword}{struct }Endianness \{}
\DoxyCodeLine{15019             \textcolor{keyword}{enum} Arch \{ Big, Little \};}
\DoxyCodeLine{15020 }
\DoxyCodeLine{15021             \textcolor{keyword}{static} Arch which() \{}
\DoxyCodeLine{15022                 \textcolor{keywordtype}{int} one = 1;}
\DoxyCodeLine{15023                 \textcolor{comment}{// If the lowest byte we read is non-\/zero, we can assume}}
\DoxyCodeLine{15024                 \textcolor{comment}{// that little endian format is used.}}
\DoxyCodeLine{15025                 \textcolor{keyword}{auto} value = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\&one);}
\DoxyCodeLine{15026                 \textcolor{keywordflow}{return} value ? Little : Big;}
\DoxyCodeLine{15027             \}}
\DoxyCodeLine{15028         \};}
\DoxyCodeLine{15029     \}}
\DoxyCodeLine{15030 }
\DoxyCodeLine{15031     std::string rawMemoryToString( \textcolor{keyword}{const} \textcolor{keywordtype}{void} *\textcolor{keywordtype}{object}, std::size\_t size ) \{}
\DoxyCodeLine{15032         \textcolor{comment}{// Reverse order for little endian architectures}}
\DoxyCodeLine{15033         \textcolor{keywordtype}{int} i = 0, end = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}( size ), inc = 1;}
\DoxyCodeLine{15034         \textcolor{keywordflow}{if}( Endianness::which() == Endianness::Little ) \{}
\DoxyCodeLine{15035             i = end-\/1;}
\DoxyCodeLine{15036             end = inc = -\/1;}
\DoxyCodeLine{15037         \}}
\DoxyCodeLine{15038 }
\DoxyCodeLine{15039         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const} *bytes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \textcolor{keyword}{const }*\textcolor{keyword}{>}(object);}
\DoxyCodeLine{15040         ReusableStringStream rss;}
\DoxyCodeLine{15041         rss << \textcolor{stringliteral}{"{}0x"{}} << std::setfill(\textcolor{charliteral}{'0'}) << std::hex;}
\DoxyCodeLine{15042         \textcolor{keywordflow}{for}( ; i != end; i += inc )}
\DoxyCodeLine{15043              rss << std::setw(2) << static\_cast<unsigned>(bytes[i]);}
\DoxyCodeLine{15044        \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15045     \}}
\DoxyCodeLine{15046 \}}
\DoxyCodeLine{15047 }
\DoxyCodeLine{15048 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{15049 std::string fpToString( T value, \textcolor{keywordtype}{int} precision ) \{}
\DoxyCodeLine{15050     \textcolor{keywordflow}{if} (Catch::isnan(value)) \{}
\DoxyCodeLine{15051         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nan"{}};}
\DoxyCodeLine{15052     \}}
\DoxyCodeLine{15053 }
\DoxyCodeLine{15054     ReusableStringStream rss;}
\DoxyCodeLine{15055     rss << std::setprecision( precision )}
\DoxyCodeLine{15056         << std::fixed}
\DoxyCodeLine{15057         << value;}
\DoxyCodeLine{15058     std::string d = rss.str();}
\DoxyCodeLine{15059     std::size\_t i = d.find\_last\_not\_of( \textcolor{charliteral}{'0'} );}
\DoxyCodeLine{15060     \textcolor{keywordflow}{if}( i != std::string::npos \&\& i != d.size()-\/1 ) \{}
\DoxyCodeLine{15061         \textcolor{keywordflow}{if}( d[i] == \textcolor{charliteral}{'.'} )}
\DoxyCodeLine{15062             i++;}
\DoxyCodeLine{15063         d = d.substr( 0, i+1 );}
\DoxyCodeLine{15064     \}}
\DoxyCodeLine{15065     \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{15066 \}}
\DoxyCodeLine{15067 }
\DoxyCodeLine{15069 \textcolor{comment}{//}}
\DoxyCodeLine{15070 \textcolor{comment}{//   Out-\/of-\/line defs for full specialization of StringMaker}}
\DoxyCodeLine{15071 \textcolor{comment}{//}}
\DoxyCodeLine{15073 \textcolor{comment}{}}
\DoxyCodeLine{15074 std::string StringMaker<std::string>::convert(\textcolor{keyword}{const} std::string\& str) \{}
\DoxyCodeLine{15075     \textcolor{keywordflow}{if} (!getCurrentContext().getConfig()-\/>showInvisibles()) \{}
\DoxyCodeLine{15076         \textcolor{keywordflow}{return} \textcolor{charliteral}{'"{}'} + str + '"{}';}
\DoxyCodeLine{15077     \}}
\DoxyCodeLine{15078 }
\DoxyCodeLine{15079     std::string s(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15080     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : str) \{}
\DoxyCodeLine{15081         \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15082         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{15083             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)n"{}});}
\DoxyCodeLine{15084             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15085         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{15086             s.append(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)t"{}});}
\DoxyCodeLine{15087             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15088         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15089             s.push\_back(c);}
\DoxyCodeLine{15090             \textcolor{keywordflow}{break};}
\DoxyCodeLine{15091         \}}
\DoxyCodeLine{15092     \}}
\DoxyCodeLine{15093     s.append(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}});}
\DoxyCodeLine{15094     \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{15095 \}}
\DoxyCodeLine{15096 }
\DoxyCodeLine{15097 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15098 std::string StringMaker<std::string\_view>::convert(std::string\_view str) \{}
\DoxyCodeLine{15099     return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15100 \}}
\DoxyCodeLine{15101 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15102 }
\DoxyCodeLine{15103 std::string StringMaker<char const*>::convert(\textcolor{keywordtype}{char} \textcolor{keyword}{const}* str) \{}
\DoxyCodeLine{15104     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15105         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15106     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15107         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15108     \}}
\DoxyCodeLine{15109 \}}
\DoxyCodeLine{15110 std::string StringMaker<char*>::convert(\textcolor{keywordtype}{char}* str) \{}
\DoxyCodeLine{15111     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15112         return ::Catch::Detail::stringify(std::string\{ str \});}
\DoxyCodeLine{15113     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15114         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15115     \}}
\DoxyCodeLine{15116 \}}
\DoxyCodeLine{15117 }
\DoxyCodeLine{15118 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_WCHAR}}
\DoxyCodeLine{15119 std::string StringMaker<std::wstring>::convert(\textcolor{keyword}{const} std::wstring\& wstr) \{}
\DoxyCodeLine{15120     std::string s;}
\DoxyCodeLine{15121     s.reserve(wstr.size());}
\DoxyCodeLine{15122     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} c : wstr) \{}
\DoxyCodeLine{15123         s += (c <= 0xff) ? static\_cast<char>(c) : '?';}
\DoxyCodeLine{15124     \}}
\DoxyCodeLine{15125     return ::Catch::Detail::stringify(s);}
\DoxyCodeLine{15126 \}}
\DoxyCodeLine{15127 }
\DoxyCodeLine{15128 \textcolor{preprocessor}{\# ifdef CATCH\_CONFIG\_CPP17\_STRING\_VIEW}}
\DoxyCodeLine{15129 std::string StringMaker<std::wstring\_view>::convert(std::wstring\_view str) \{}
\DoxyCodeLine{15130     \textcolor{keywordflow}{return} StringMaker<std::wstring>::convert(std::wstring(str));}
\DoxyCodeLine{15131 \}}
\DoxyCodeLine{15132 \textcolor{preprocessor}{\# endif}}
\DoxyCodeLine{15133 }
\DoxyCodeLine{15134 std::string StringMaker<wchar\_t const*>::convert(\textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} * str) \{}
\DoxyCodeLine{15135     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15136         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15137     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15138         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15139     \}}
\DoxyCodeLine{15140 \}}
\DoxyCodeLine{15141 std::string StringMaker<wchar\_t *>::convert(\textcolor{keywordtype}{wchar\_t} * str) \{}
\DoxyCodeLine{15142     \textcolor{keywordflow}{if} (str) \{}
\DoxyCodeLine{15143         return ::Catch::Detail::stringify(std::wstring\{ str \});}
\DoxyCodeLine{15144     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15145         \textcolor{keywordflow}{return}\{ \textcolor{stringliteral}{"{}\{null string\}"{}} \};}
\DoxyCodeLine{15146     \}}
\DoxyCodeLine{15147 \}}
\DoxyCodeLine{15148 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15149 }
\DoxyCodeLine{15150 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15151 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{15152 std::string StringMaker<std::byte>::convert(std::byte value) \{}
\DoxyCodeLine{15153     return ::Catch::Detail::stringify(std::to\_integer<unsigned long long>(value));}
\DoxyCodeLine{15154 \}}
\DoxyCodeLine{15155 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// defined(CATCH\_CONFIG\_CPP17\_BYTE)}}
\DoxyCodeLine{15156 }
\DoxyCodeLine{15157 std::string StringMaker<int>::convert(\textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15158     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15159 \}}
\DoxyCodeLine{15160 std::string StringMaker<long>::convert(\textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15161     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15162 \}}
\DoxyCodeLine{15163 std::string StringMaker<long long>::convert(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15164     ReusableStringStream rss;}
\DoxyCodeLine{15165     rss << value;}
\DoxyCodeLine{15166     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15167         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15168     \}}
\DoxyCodeLine{15169     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15170 \}}
\DoxyCodeLine{15171 }
\DoxyCodeLine{15172 std::string StringMaker<unsigned int>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} value) \{}
\DoxyCodeLine{15173     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15174 \}}
\DoxyCodeLine{15175 std::string StringMaker<unsigned long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15176     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15177 \}}
\DoxyCodeLine{15178 std::string StringMaker<unsigned long long>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) \{}
\DoxyCodeLine{15179     ReusableStringStream rss;}
\DoxyCodeLine{15180     rss << value;}
\DoxyCodeLine{15181     \textcolor{keywordflow}{if} (value > Detail::hexThreshold) \{}
\DoxyCodeLine{15182         rss << \textcolor{stringliteral}{"{} (0x"{}} << std::hex << value << \textcolor{charliteral}{')'};}
\DoxyCodeLine{15183     \}}
\DoxyCodeLine{15184     \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{15185 \}}
\DoxyCodeLine{15186 }
\DoxyCodeLine{15187 std::string StringMaker<bool>::convert(\textcolor{keywordtype}{bool} b) \{}
\DoxyCodeLine{15188     \textcolor{keywordflow}{return} b ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}};}
\DoxyCodeLine{15189 \}}
\DoxyCodeLine{15190 }
\DoxyCodeLine{15191 std::string StringMaker<signed char>::convert(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} value) \{}
\DoxyCodeLine{15192     \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)r'}) \{}
\DoxyCodeLine{15193         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)r'"{}};}
\DoxyCodeLine{15194     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)f'}) \{}
\DoxyCodeLine{15195         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)f'"{}};}
\DoxyCodeLine{15196     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{15197         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)n'"{}};}
\DoxyCodeLine{15198     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value == \textcolor{charliteral}{'\(\backslash\)t'}) \{}
\DoxyCodeLine{15199         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}'\(\backslash\)\(\backslash\)t'"{}};}
\DoxyCodeLine{15200     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{charliteral}{'\(\backslash\)0'} <= value \&\& value < \textcolor{charliteral}{' '}) \{}
\DoxyCodeLine{15201         return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{15202     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15203         \textcolor{keywordtype}{char} chstr[] = \textcolor{stringliteral}{"{}' '"{}};}
\DoxyCodeLine{15204         chstr[1] = value;}
\DoxyCodeLine{15205         \textcolor{keywordflow}{return} chstr;}
\DoxyCodeLine{15206     \}}
\DoxyCodeLine{15207 \}}
\DoxyCodeLine{15208 std::string StringMaker<char>::convert(\textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15209     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15210 \}}
\DoxyCodeLine{15211 std::string StringMaker<unsigned char>::convert(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15212     return ::Catch::Detail::stringify(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{15213 \}}
\DoxyCodeLine{15214 }
\DoxyCodeLine{15215 std::string StringMaker<std::nullptr\_t>::convert(std::nullptr\_t) \{}
\DoxyCodeLine{15216     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}nullptr"{}};}
\DoxyCodeLine{15217 \}}
\DoxyCodeLine{15218 }
\DoxyCodeLine{15219 \textcolor{keywordtype}{int} StringMaker<float>::precision = 5;}
\DoxyCodeLine{15220 }
\DoxyCodeLine{15221 std::string StringMaker<float>::convert(\textcolor{keywordtype}{float} value) \{}
\DoxyCodeLine{15222     \textcolor{keywordflow}{return} fpToString(value, precision) + 'f';}
\DoxyCodeLine{15223 \}}
\DoxyCodeLine{15224 }
\DoxyCodeLine{15225 \textcolor{keywordtype}{int} StringMaker<double>::precision = 10;}
\DoxyCodeLine{15226 }
\DoxyCodeLine{15227 std::string StringMaker<double>::convert(\textcolor{keywordtype}{double} value) \{}
\DoxyCodeLine{15228     \textcolor{keywordflow}{return} fpToString(value, precision);}
\DoxyCodeLine{15229 \}}
\DoxyCodeLine{15230 }
\DoxyCodeLine{15231 std::string ratio\_string<std::atto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}a"{}}; \}}
\DoxyCodeLine{15232 std::string ratio\_string<std::femto>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}f"{}}; \}}
\DoxyCodeLine{15233 std::string ratio\_string<std::pico>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}p"{}}; \}}
\DoxyCodeLine{15234 std::string ratio\_string<std::nano>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}n"{}}; \}}
\DoxyCodeLine{15235 std::string ratio\_string<std::micro>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}u"{}}; \}}
\DoxyCodeLine{15236 std::string ratio\_string<std::milli>::symbol() \{ \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}}; \}}
\DoxyCodeLine{15237 }
\DoxyCodeLine{15238 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15239 }
\DoxyCodeLine{15240 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{15241 \textcolor{preprocessor}{\#    pragma clang diagnostic pop}}
\DoxyCodeLine{15242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15243 }
\DoxyCodeLine{15244 \textcolor{comment}{// end catch\_tostring.cpp}}
\DoxyCodeLine{15245 \textcolor{comment}{// start catch\_totals.cpp}}
\DoxyCodeLine{15246 }
\DoxyCodeLine{15247 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15248 }
\DoxyCodeLine{15249     Counts Counts::operator -\/ ( Counts \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15250         Counts diff;}
\DoxyCodeLine{15251         diff.passed = passed -\/ other.passed;}
\DoxyCodeLine{15252         diff.failed = failed -\/ other.failed;}
\DoxyCodeLine{15253         diff.failedButOk = failedButOk -\/ other.failedButOk;}
\DoxyCodeLine{15254         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15255     \}}
\DoxyCodeLine{15256 }
\DoxyCodeLine{15257     Counts\& Counts::operator += ( Counts \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15258         passed += other.passed;}
\DoxyCodeLine{15259         failed += other.failed;}
\DoxyCodeLine{15260         failedButOk += other.failedButOk;}
\DoxyCodeLine{15261         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15262     \}}
\DoxyCodeLine{15263 }
\DoxyCodeLine{15264     std::size\_t Counts::total()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15265         \textcolor{keywordflow}{return} passed + failed + failedButOk;}
\DoxyCodeLine{15266     \}}
\DoxyCodeLine{15267     \textcolor{keywordtype}{bool} Counts::allPassed()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15268         \textcolor{keywordflow}{return} failed == 0 \&\& failedButOk == 0;}
\DoxyCodeLine{15269     \}}
\DoxyCodeLine{15270     \textcolor{keywordtype}{bool} Counts::allOk()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15271         \textcolor{keywordflow}{return} failed == 0;}
\DoxyCodeLine{15272     \}}
\DoxyCodeLine{15273 }
\DoxyCodeLine{15274     Totals Totals::operator -\/ ( Totals \textcolor{keyword}{const}\& other )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15275         Totals diff;}
\DoxyCodeLine{15276         diff.assertions = assertions -\/ other.assertions;}
\DoxyCodeLine{15277         diff.testCases = testCases -\/ other.testCases;}
\DoxyCodeLine{15278         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15279     \}}
\DoxyCodeLine{15280 }
\DoxyCodeLine{15281     Totals\& Totals::operator += ( Totals \textcolor{keyword}{const}\& other ) \{}
\DoxyCodeLine{15282         assertions += other.assertions;}
\DoxyCodeLine{15283         testCases += other.testCases;}
\DoxyCodeLine{15284         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15285     \}}
\DoxyCodeLine{15286 }
\DoxyCodeLine{15287     Totals Totals::delta( Totals \textcolor{keyword}{const}\& prevTotals )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15288         Totals diff = *\textcolor{keyword}{this} -\/ prevTotals;}
\DoxyCodeLine{15289         \textcolor{keywordflow}{if}( diff.assertions.failed > 0 )}
\DoxyCodeLine{15290             ++diff.testCases.failed;}
\DoxyCodeLine{15291         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( diff.assertions.failedButOk > 0 )}
\DoxyCodeLine{15292             ++diff.testCases.failedButOk;}
\DoxyCodeLine{15293         \textcolor{keywordflow}{else}}
\DoxyCodeLine{15294             ++diff.testCases.passed;}
\DoxyCodeLine{15295         \textcolor{keywordflow}{return} diff;}
\DoxyCodeLine{15296     \}}
\DoxyCodeLine{15297 }
\DoxyCodeLine{15298 \}}
\DoxyCodeLine{15299 \textcolor{comment}{// end catch\_totals.cpp}}
\DoxyCodeLine{15300 \textcolor{comment}{// start catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15301 }
\DoxyCodeLine{15302 \textcolor{comment}{// start catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15303 }
\DoxyCodeLine{15304 \textcolor{comment}{//              Copyright Catch2 Authors}}
\DoxyCodeLine{15305 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{15306 \textcolor{comment}{//   (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{15307 \textcolor{comment}{//        https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{15308 }
\DoxyCodeLine{15309 \textcolor{comment}{// SPDX-\/License-\/Identifier: BSL-\/1.0}}
\DoxyCodeLine{15310 }
\DoxyCodeLine{15311 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15312 \textcolor{preprocessor}{\#define CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15313 }
\DoxyCodeLine{15314 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{15315 \textcolor{preprocessor}{\#  if \_MSC\_VER >= 1900 }\textcolor{comment}{// Visual Studio 2015 or newer}}
\DoxyCodeLine{15316 \textcolor{preprocessor}{\#    define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15317 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{15318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15319 }
\DoxyCodeLine{15320 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15321 }
\DoxyCodeLine{15322 \textcolor{preprocessor}{\#if defined(\_\_cpp\_lib\_uncaught\_exceptions) \(\backslash\)}}
\DoxyCodeLine{15323 \textcolor{preprocessor}{    \&\& !defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15324 }
\DoxyCodeLine{15325 \textcolor{preprocessor}{\#  define CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15326 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cpp\_lib\_uncaught\_exceptions}}
\DoxyCodeLine{15327 }
\DoxyCodeLine{15328 \textcolor{preprocessor}{\#if defined(CATCH\_INTERNAL\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15329 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_NO\_CPP17\_UNCAUGHT\_EXCEPTIONS) \(\backslash\)}}
\DoxyCodeLine{15330 \textcolor{preprocessor}{    \&\& !defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15331 }
\DoxyCodeLine{15332 \textcolor{preprocessor}{\#  define CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS}}
\DoxyCodeLine{15333 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15334 }
\DoxyCodeLine{15335 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_UNCAUGHT\_EXCEPTIONS\_HPP}}
\DoxyCodeLine{15336 \textcolor{comment}{// end catch\_config\_uncaught\_exceptions.hpp}}
\DoxyCodeLine{15337 \textcolor{preprocessor}{\#include <exception>}}
\DoxyCodeLine{15338 }
\DoxyCodeLine{15339 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15340     \textcolor{keywordtype}{bool} uncaught\_exceptions() \{}
\DoxyCodeLine{15341 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_DISABLE\_EXCEPTIONS)}}
\DoxyCodeLine{15342         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{15343 \textcolor{preprocessor}{\#elif defined(CATCH\_CONFIG\_CPP17\_UNCAUGHT\_EXCEPTIONS)}}
\DoxyCodeLine{15344         \textcolor{keywordflow}{return} std::uncaught\_exceptions() > 0;}
\DoxyCodeLine{15345 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{15346         \textcolor{keywordflow}{return} std::uncaught\_exception();}
\DoxyCodeLine{15347 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{15348   \}}
\DoxyCodeLine{15349 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{15350 \textcolor{comment}{// end catch\_uncaught\_exceptions.cpp}}
\DoxyCodeLine{15351 \textcolor{comment}{// start catch\_version.cpp}}
\DoxyCodeLine{15352 }
\DoxyCodeLine{15353 \textcolor{preprocessor}{\#include <ostream>}}
\DoxyCodeLine{15354 }
\DoxyCodeLine{15355 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15356 }
\DoxyCodeLine{15357     Version::Version}
\DoxyCodeLine{15358         (   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_majorVersion,}
\DoxyCodeLine{15359             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_minorVersion,}
\DoxyCodeLine{15360             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_patchNumber,}
\DoxyCodeLine{15361             \textcolor{keywordtype}{char} \textcolor{keyword}{const} * \textcolor{keyword}{const} \_branchName,}
\DoxyCodeLine{15362             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_buildNumber )}
\DoxyCodeLine{15363     :   majorVersion( \_majorVersion ),}
\DoxyCodeLine{15364         minorVersion( \_minorVersion ),}
\DoxyCodeLine{15365         patchNumber( \_patchNumber ),}
\DoxyCodeLine{15366         branchName( \_branchName ),}
\DoxyCodeLine{15367         buildNumber( \_buildNumber )}
\DoxyCodeLine{15368     \{\}}
\DoxyCodeLine{15369 }
\DoxyCodeLine{15370     std::ostream\& operator << ( std::ostream\& os, Version \textcolor{keyword}{const}\& version ) \{}
\DoxyCodeLine{15371         os  << version.majorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15372             << version.minorVersion << \textcolor{charliteral}{'.'}}
\DoxyCodeLine{15373             << version.patchNumber;}
\DoxyCodeLine{15374         \textcolor{comment}{// branchName is never null -\/> 0th char is \(\backslash\)0 if it is empty}}
\DoxyCodeLine{15375         \textcolor{keywordflow}{if} (version.branchName[0]) \{}
\DoxyCodeLine{15376             os << \textcolor{charliteral}{'-\/'} << version.branchName}
\DoxyCodeLine{15377                << \textcolor{charliteral}{'.'} << version.buildNumber;}
\DoxyCodeLine{15378         \}}
\DoxyCodeLine{15379         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15380     \}}
\DoxyCodeLine{15381 }
\DoxyCodeLine{15382     Version \textcolor{keyword}{const}\& libraryVersion() \{}
\DoxyCodeLine{15383         \textcolor{keyword}{static} Version version( 2, 13, 7, \textcolor{stringliteral}{"{}"{}}, 0 );}
\DoxyCodeLine{15384         \textcolor{keywordflow}{return} version;}
\DoxyCodeLine{15385     \}}
\DoxyCodeLine{15386 }
\DoxyCodeLine{15387 \}}
\DoxyCodeLine{15388 \textcolor{comment}{// end catch\_version.cpp}}
\DoxyCodeLine{15389 \textcolor{comment}{// start catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15390 }
\DoxyCodeLine{15391 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15392 }
\DoxyCodeLine{15393     WildcardPattern::WildcardPattern( std::string \textcolor{keyword}{const}\& pattern,}
\DoxyCodeLine{15394                                       CaseSensitive::Choice caseSensitivity )}
\DoxyCodeLine{15395     :   m\_caseSensitivity( caseSensitivity ),}
\DoxyCodeLine{15396         m\_pattern( normaliseString( pattern ) )}
\DoxyCodeLine{15397     \{}
\DoxyCodeLine{15398         \textcolor{keywordflow}{if}( startsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15399             m\_pattern = m\_pattern.substr( 1 );}
\DoxyCodeLine{15400             m\_wildcard = WildcardAtStart;}
\DoxyCodeLine{15401         \}}
\DoxyCodeLine{15402         \textcolor{keywordflow}{if}( endsWith( m\_pattern, \textcolor{charliteral}{'*'} ) ) \{}
\DoxyCodeLine{15403             m\_pattern = m\_pattern.substr( 0, m\_pattern.size()-\/1 );}
\DoxyCodeLine{15404             m\_wildcard = \textcolor{keyword}{static\_cast<}WildcardPosition\textcolor{keyword}{>}( m\_wildcard | WildcardAtEnd );}
\DoxyCodeLine{15405         \}}
\DoxyCodeLine{15406     \}}
\DoxyCodeLine{15407 }
\DoxyCodeLine{15408     \textcolor{keywordtype}{bool} WildcardPattern::matches( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15409         \textcolor{keywordflow}{switch}( m\_wildcard ) \{}
\DoxyCodeLine{15410             \textcolor{keywordflow}{case} NoWildcard:}
\DoxyCodeLine{15411                 \textcolor{keywordflow}{return} m\_pattern == normaliseString( str );}
\DoxyCodeLine{15412             \textcolor{keywordflow}{case} WildcardAtStart:}
\DoxyCodeLine{15413                 \textcolor{keywordflow}{return} endsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15414             \textcolor{keywordflow}{case} WildcardAtEnd:}
\DoxyCodeLine{15415                 \textcolor{keywordflow}{return} startsWith( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15416             \textcolor{keywordflow}{case} WildcardAtBothEnds:}
\DoxyCodeLine{15417                 \textcolor{keywordflow}{return} contains( normaliseString( str ), m\_pattern );}
\DoxyCodeLine{15418             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15419                 CATCH\_INTERNAL\_ERROR( \textcolor{stringliteral}{"{}Unknown enum"{}} );}
\DoxyCodeLine{15420         \}}
\DoxyCodeLine{15421     \}}
\DoxyCodeLine{15422 }
\DoxyCodeLine{15423     std::string WildcardPattern::normaliseString( std::string \textcolor{keyword}{const}\& str )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15424         \textcolor{keywordflow}{return} trim( m\_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );}
\DoxyCodeLine{15425     \}}
\DoxyCodeLine{15426 \}}
\DoxyCodeLine{15427 \textcolor{comment}{// end catch\_wildcard\_pattern.cpp}}
\DoxyCodeLine{15428 \textcolor{comment}{// start catch\_xmlwriter.cpp}}
\DoxyCodeLine{15429 }
\DoxyCodeLine{15430 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{15431 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{15432 }
\DoxyCodeLine{15433 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{15434 }
\DoxyCodeLine{15435 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{15436 }
\DoxyCodeLine{15437     \textcolor{keywordtype}{size\_t} trailingBytes(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15438         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15439             \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{15440         \}}
\DoxyCodeLine{15441         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15442             \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{15443         \}}
\DoxyCodeLine{15444         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15445             \textcolor{keywordflow}{return} 4;}
\DoxyCodeLine{15446         \}}
\DoxyCodeLine{15447         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15448     \}}
\DoxyCodeLine{15449 }
\DoxyCodeLine{15450     uint32\_t headerValue(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15451         \textcolor{keywordflow}{if} ((c \& 0xE0) == 0xC0) \{}
\DoxyCodeLine{15452             \textcolor{keywordflow}{return} c \& 0x1F;}
\DoxyCodeLine{15453         \}}
\DoxyCodeLine{15454         \textcolor{keywordflow}{if} ((c \& 0xF0) == 0xE0) \{}
\DoxyCodeLine{15455             \textcolor{keywordflow}{return} c \& 0x0F;}
\DoxyCodeLine{15456         \}}
\DoxyCodeLine{15457         \textcolor{keywordflow}{if} ((c \& 0xF8) == 0xF0) \{}
\DoxyCodeLine{15458             \textcolor{keywordflow}{return} c \& 0x07;}
\DoxyCodeLine{15459         \}}
\DoxyCodeLine{15460         CATCH\_INTERNAL\_ERROR(\textcolor{stringliteral}{"{}Invalid multibyte utf-\/8 start byte encountered"{}});}
\DoxyCodeLine{15461     \}}
\DoxyCodeLine{15462 }
\DoxyCodeLine{15463     \textcolor{keywordtype}{void} hexEscapeChar(std::ostream\& os, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c) \{}
\DoxyCodeLine{15464         std::ios\_base::fmtflags f(os.flags());}
\DoxyCodeLine{15465         os << \textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)x"{}}}
\DoxyCodeLine{15466             << std::uppercase << std::hex << std::setfill(\textcolor{charliteral}{'0'}) << std::setw(2)}
\DoxyCodeLine{15467             << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(c);}
\DoxyCodeLine{15468         os.flags(f);}
\DoxyCodeLine{15469     \}}
\DoxyCodeLine{15470 }
\DoxyCodeLine{15471     \textcolor{keywordtype}{bool} shouldNewline(XmlFormatting fmt) \{}
\DoxyCodeLine{15472         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Newline));}
\DoxyCodeLine{15473     \}}
\DoxyCodeLine{15474 }
\DoxyCodeLine{15475     \textcolor{keywordtype}{bool} shouldIndent(XmlFormatting fmt) \{}
\DoxyCodeLine{15476         \textcolor{keywordflow}{return} !!(\textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(fmt \& XmlFormatting::Indent));}
\DoxyCodeLine{15477     \}}
\DoxyCodeLine{15478 }
\DoxyCodeLine{15479 \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{15480 }
\DoxyCodeLine{15481     XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15482         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15483             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) |}
\DoxyCodeLine{15484             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15485         );}
\DoxyCodeLine{15486     \}}
\DoxyCodeLine{15487 }
\DoxyCodeLine{15488     XmlFormatting operator \& (XmlFormatting lhs, XmlFormatting rhs) \{}
\DoxyCodeLine{15489         \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}XmlFormatting\textcolor{keyword}{>}(}
\DoxyCodeLine{15490             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(lhs) \&}
\DoxyCodeLine{15491             \textcolor{keyword}{static\_cast<}std::underlying\_type<XmlFormatting>::type\textcolor{keyword}{>}(rhs)}
\DoxyCodeLine{15492         );}
\DoxyCodeLine{15493     \}}
\DoxyCodeLine{15494 }
\DoxyCodeLine{15495     XmlEncode::XmlEncode( std::string \textcolor{keyword}{const}\& str, ForWhat forWhat )}
\DoxyCodeLine{15496     :   m\_str( str ),}
\DoxyCodeLine{15497         m\_forWhat( forWhat )}
\DoxyCodeLine{15498     \{\}}
\DoxyCodeLine{15499 }
\DoxyCodeLine{15500     \textcolor{keywordtype}{void} XmlEncode::encodeTo( std::ostream\& os )\textcolor{keyword}{ const }\{}
\DoxyCodeLine{15501         \textcolor{comment}{// Apostrophe escaping not necessary if we always use "{} to write attributes}}
\DoxyCodeLine{15502         \textcolor{comment}{// (see: http://www.w3.org/TR/xml/\#syntax)}}
\DoxyCodeLine{15503 }
\DoxyCodeLine{15504         \textcolor{keywordflow}{for}( std::size\_t idx = 0; idx < m\_str.size(); ++ idx ) \{}
\DoxyCodeLine{15505             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c = m\_str[idx];}
\DoxyCodeLine{15506             \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{15507             \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:   os << \textcolor{stringliteral}{"{}\&lt;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15508             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\&'}:   os << \textcolor{stringliteral}{"{}\&amp;"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{15509 }
\DoxyCodeLine{15510             \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{15511                 \textcolor{comment}{// See: http://www.w3.org/TR/xml/\#syntax}}
\DoxyCodeLine{15512                 \textcolor{keywordflow}{if} (idx > 2 \&\& m\_str[idx -\/ 1] == \textcolor{charliteral}{']'} \&\& m\_str[idx -\/ 2] == \textcolor{charliteral}{']'})}
\DoxyCodeLine{15513                     os << \textcolor{stringliteral}{"{}\&gt;"{}};}
\DoxyCodeLine{15514                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15515                     os << c;}
\DoxyCodeLine{15516                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15517 }
\DoxyCodeLine{15518             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"{}'}:}
\DoxyCodeLine{15519                 \textcolor{keywordflow}{if} (m\_forWhat == ForAttributes)}
\DoxyCodeLine{15520                     os << \textcolor{stringliteral}{"{}\&quot;"{}};}
\DoxyCodeLine{15521                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{15522                     os << c;}
\DoxyCodeLine{15523                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15524 }
\DoxyCodeLine{15525             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{15526                 \textcolor{comment}{// Check for control characters and invalid utf-\/8}}
\DoxyCodeLine{15527 }
\DoxyCodeLine{15528                 \textcolor{comment}{// Escape control characters in standard ascii}}
\DoxyCodeLine{15529                 \textcolor{comment}{// see http://stackoverflow.com/questions/404107/why-\/are-\/control-\/characters-\/illegal-\/in-\/xml-\/1-\/0}}
\DoxyCodeLine{15530                 \textcolor{keywordflow}{if} (c < 0x09 || (c > 0x0D \&\& c < 0x20) || c == 0x7F) \{}
\DoxyCodeLine{15531                     hexEscapeChar(os, c);}
\DoxyCodeLine{15532                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15533                 \}}
\DoxyCodeLine{15534 }
\DoxyCodeLine{15535                 \textcolor{comment}{// Plain ASCII: Write it to stream}}
\DoxyCodeLine{15536                 \textcolor{keywordflow}{if} (c < 0x7F) \{}
\DoxyCodeLine{15537                     os << c;}
\DoxyCodeLine{15538                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15539                 \}}
\DoxyCodeLine{15540 }
\DoxyCodeLine{15541                 \textcolor{comment}{// UTF-\/8 territory}}
\DoxyCodeLine{15542                 \textcolor{comment}{// Check if the encoding is valid and if it is not, hex escape bytes.}}
\DoxyCodeLine{15543                 \textcolor{comment}{// Important: We do not check the exact decoded values for validity, only the encoding format}}
\DoxyCodeLine{15544                 \textcolor{comment}{// First check that this bytes is a valid lead byte:}}
\DoxyCodeLine{15545                 \textcolor{comment}{// This means that it is not encoded as 1111 1XXX}}
\DoxyCodeLine{15546                 \textcolor{comment}{// Or as 10XX XXXX}}
\DoxyCodeLine{15547                 \textcolor{keywordflow}{if} (c <  0xC0 ||}
\DoxyCodeLine{15548                     c >= 0xF8) \{}
\DoxyCodeLine{15549                     hexEscapeChar(os, c);}
\DoxyCodeLine{15550                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15551                 \}}
\DoxyCodeLine{15552 }
\DoxyCodeLine{15553                 \textcolor{keyword}{auto} encBytes = trailingBytes(c);}
\DoxyCodeLine{15554                 \textcolor{comment}{// Are there enough bytes left to avoid accessing out-\/of-\/bounds memory?}}
\DoxyCodeLine{15555                 \textcolor{keywordflow}{if} (idx + encBytes -\/ 1 >= m\_str.size()) \{}
\DoxyCodeLine{15556                     hexEscapeChar(os, c);}
\DoxyCodeLine{15557                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15558                 \}}
\DoxyCodeLine{15559                 \textcolor{comment}{// The header is valid, check data}}
\DoxyCodeLine{15560                 \textcolor{comment}{// The next encBytes bytes must together be a valid utf-\/8}}
\DoxyCodeLine{15561                 \textcolor{comment}{// This means: bitpattern 10XX XXXX and the extracted value is sane (ish)}}
\DoxyCodeLine{15562                 \textcolor{keywordtype}{bool} valid = \textcolor{keyword}{true};}
\DoxyCodeLine{15563                 uint32\_t value = headerValue(c);}
\DoxyCodeLine{15564                 \textcolor{keywordflow}{for} (std::size\_t n = 1; n < encBytes; ++n) \{}
\DoxyCodeLine{15565                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} nc = m\_str[idx + n];}
\DoxyCodeLine{15566                     valid \&= ((nc \& 0xC0) == 0x80);}
\DoxyCodeLine{15567                     value = (value << 6) | (nc \& 0x3F);}
\DoxyCodeLine{15568                 \}}
\DoxyCodeLine{15569 }
\DoxyCodeLine{15570                 \textcolor{keywordflow}{if} (}
\DoxyCodeLine{15571                     \textcolor{comment}{// Wrong bit pattern of following bytes}}
\DoxyCodeLine{15572                     (!valid) ||}
\DoxyCodeLine{15573                     \textcolor{comment}{// Overlong encodings}}
\DoxyCodeLine{15574                     (value < 0x80) ||}
\DoxyCodeLine{15575                     (0x80 <= value \&\& value < 0x800   \&\& encBytes > 2) ||}
\DoxyCodeLine{15576                     (0x800 < value \&\& value < 0x10000 \&\& encBytes > 3) ||}
\DoxyCodeLine{15577                     \textcolor{comment}{// Encoded value out of range}}
\DoxyCodeLine{15578                     (value >= 0x110000)}
\DoxyCodeLine{15579                     ) \{}
\DoxyCodeLine{15580                     hexEscapeChar(os, c);}
\DoxyCodeLine{15581                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{15582                 \}}
\DoxyCodeLine{15583 }
\DoxyCodeLine{15584                 \textcolor{comment}{// If we got here, this is in fact a valid(ish) utf-\/8 sequence}}
\DoxyCodeLine{15585                 \textcolor{keywordflow}{for} (std::size\_t n = 0; n < encBytes; ++n) \{}
\DoxyCodeLine{15586                     os << m\_str[idx + n];}
\DoxyCodeLine{15587                 \}}
\DoxyCodeLine{15588                 idx += encBytes -\/ 1;}
\DoxyCodeLine{15589                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{15590             \}}
\DoxyCodeLine{15591         \}}
\DoxyCodeLine{15592     \}}
\DoxyCodeLine{15593 }
\DoxyCodeLine{15594     std::ostream\& operator << ( std::ostream\& os, XmlEncode \textcolor{keyword}{const}\& xmlEncode ) \{}
\DoxyCodeLine{15595         xmlEncode.encodeTo( os );}
\DoxyCodeLine{15596         \textcolor{keywordflow}{return} os;}
\DoxyCodeLine{15597     \}}
\DoxyCodeLine{15598 }
\DoxyCodeLine{15599     XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )}
\DoxyCodeLine{15600     :   m\_writer( writer ),}
\DoxyCodeLine{15601         m\_fmt(fmt)}
\DoxyCodeLine{15602     \{\}}
\DoxyCodeLine{15603 }
\DoxyCodeLine{15604     XmlWriter::ScopedElement::ScopedElement( ScopedElement\&\& other ) noexcept}
\DoxyCodeLine{15605     :   m\_writer( other.m\_writer ),}
\DoxyCodeLine{15606         m\_fmt(other.m\_fmt)}
\DoxyCodeLine{15607     \{}
\DoxyCodeLine{15608         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15609         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15610     \}}
\DoxyCodeLine{15611     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::operator=( ScopedElement\&\& other ) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{15612         \textcolor{keywordflow}{if} ( m\_writer ) \{}
\DoxyCodeLine{15613             m\_writer-\/>endElement();}
\DoxyCodeLine{15614         \}}
\DoxyCodeLine{15615         m\_writer = other.m\_writer;}
\DoxyCodeLine{15616         other.m\_writer = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{15617         m\_fmt = other.m\_fmt;}
\DoxyCodeLine{15618         other.m\_fmt = XmlFormatting::None;}
\DoxyCodeLine{15619         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15620     \}}
\DoxyCodeLine{15621 }
\DoxyCodeLine{15622     XmlWriter::ScopedElement::\string~ScopedElement() \{}
\DoxyCodeLine{15623         \textcolor{keywordflow}{if} (m\_writer) \{}
\DoxyCodeLine{15624             m\_writer-\/>endElement(m\_fmt);}
\DoxyCodeLine{15625         \}}
\DoxyCodeLine{15626     \}}
\DoxyCodeLine{15627 }
\DoxyCodeLine{15628     XmlWriter::ScopedElement\& XmlWriter::ScopedElement::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt ) \{}
\DoxyCodeLine{15629         m\_writer-\/>writeText( text, fmt );}
\DoxyCodeLine{15630         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15631     \}}
\DoxyCodeLine{15632 }
\DoxyCodeLine{15633     XmlWriter::XmlWriter( std::ostream\& os ) : m\_os( os )}
\DoxyCodeLine{15634     \{}
\DoxyCodeLine{15635         writeDeclaration();}
\DoxyCodeLine{15636     \}}
\DoxyCodeLine{15637 }
\DoxyCodeLine{15638     XmlWriter::\string~XmlWriter() \{}
\DoxyCodeLine{15639         \textcolor{keywordflow}{while} (!m\_tags.empty()) \{}
\DoxyCodeLine{15640             endElement();}
\DoxyCodeLine{15641         \}}
\DoxyCodeLine{15642         newlineIfNecessary();}
\DoxyCodeLine{15643     \}}
\DoxyCodeLine{15644 }
\DoxyCodeLine{15645     XmlWriter\& XmlWriter::startElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15646         ensureTagClosed();}
\DoxyCodeLine{15647         newlineIfNecessary();}
\DoxyCodeLine{15648         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15649             m\_os << m\_indent;}
\DoxyCodeLine{15650             m\_indent += "{}  "{};}
\DoxyCodeLine{15651         \}}
\DoxyCodeLine{15652         m\_os << \textcolor{charliteral}{'<'} << name;}
\DoxyCodeLine{15653         m\_tags.push\_back( name );}
\DoxyCodeLine{15654         m\_tagIsOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{15655         applyFormatting(fmt);}
\DoxyCodeLine{15656         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15657     \}}
\DoxyCodeLine{15658 }
\DoxyCodeLine{15659     XmlWriter::ScopedElement XmlWriter::scopedElement( std::string \textcolor{keyword}{const}\& name, XmlFormatting fmt ) \{}
\DoxyCodeLine{15660         ScopedElement scoped( \textcolor{keyword}{this}, fmt );}
\DoxyCodeLine{15661         startElement( name, fmt );}
\DoxyCodeLine{15662         \textcolor{keywordflow}{return} scoped;}
\DoxyCodeLine{15663     \}}
\DoxyCodeLine{15664 }
\DoxyCodeLine{15665     XmlWriter\& XmlWriter::endElement(XmlFormatting fmt) \{}
\DoxyCodeLine{15666         m\_indent = m\_indent.substr(0, m\_indent.size() -\/ 2);}
\DoxyCodeLine{15667 }
\DoxyCodeLine{15668         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15669             m\_os << \textcolor{stringliteral}{"{}/>"{}};}
\DoxyCodeLine{15670             m\_tagIsOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{15671         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{15672             newlineIfNecessary();}
\DoxyCodeLine{15673             \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15674                 m\_os << m\_indent;}
\DoxyCodeLine{15675             \}}
\DoxyCodeLine{15676             m\_os << \textcolor{stringliteral}{"{}</"{}} << m\_tags.back() << \textcolor{stringliteral}{"{}>"{}};}
\DoxyCodeLine{15677         \}}
\DoxyCodeLine{15678         m\_os << std::flush;}
\DoxyCodeLine{15679         applyFormatting(fmt);}
\DoxyCodeLine{15680         m\_tags.pop\_back();}
\DoxyCodeLine{15681         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15682     \}}
\DoxyCodeLine{15683 }
\DoxyCodeLine{15684     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, std::string \textcolor{keyword}{const}\& attribute ) \{}
\DoxyCodeLine{15685         \textcolor{keywordflow}{if}( !name.empty() \&\& !attribute.empty() )}
\DoxyCodeLine{15686             m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << XmlEncode( attribute, XmlEncode::ForAttributes ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15687         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15688     \}}
\DoxyCodeLine{15689 }
\DoxyCodeLine{15690     XmlWriter\& XmlWriter::writeAttribute( std::string \textcolor{keyword}{const}\& name, \textcolor{keywordtype}{bool} attribute ) \{}
\DoxyCodeLine{15691         m\_os << \textcolor{charliteral}{' '} << name << \textcolor{stringliteral}{"{}=\(\backslash\)"{}"{}} << ( attribute ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}} ) << \textcolor{charliteral}{'"{}'};}
\DoxyCodeLine{15692         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15693     \}}
\DoxyCodeLine{15694 }
\DoxyCodeLine{15695     XmlWriter\& XmlWriter::writeText( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15696         \textcolor{keywordflow}{if}( !text.empty() )\{}
\DoxyCodeLine{15697             \textcolor{keywordtype}{bool} tagWasOpen = m\_tagIsOpen;}
\DoxyCodeLine{15698             ensureTagClosed();}
\DoxyCodeLine{15699             \textcolor{keywordflow}{if} (tagWasOpen \&\& shouldIndent(fmt)) \{}
\DoxyCodeLine{15700                 m\_os << m\_indent;}
\DoxyCodeLine{15701             \}}
\DoxyCodeLine{15702             m\_os << XmlEncode( text );}
\DoxyCodeLine{15703             applyFormatting(fmt);}
\DoxyCodeLine{15704         \}}
\DoxyCodeLine{15705         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15706     \}}
\DoxyCodeLine{15707 }
\DoxyCodeLine{15708     XmlWriter\& XmlWriter::writeComment( std::string \textcolor{keyword}{const}\& text, XmlFormatting fmt) \{}
\DoxyCodeLine{15709         ensureTagClosed();}
\DoxyCodeLine{15710         \textcolor{keywordflow}{if} (shouldIndent(fmt)) \{}
\DoxyCodeLine{15711             m\_os << m\_indent;}
\DoxyCodeLine{15712         \}}
\DoxyCodeLine{15713         m\_os << \textcolor{stringliteral}{"{}<!-\/-\/"{}} << text << \textcolor{stringliteral}{"{}-\/-\/>"{}};}
\DoxyCodeLine{15714         applyFormatting(fmt);}
\DoxyCodeLine{15715         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15716     \}}
\DoxyCodeLine{15717 }
\DoxyCodeLine{15718     \textcolor{keywordtype}{void} XmlWriter::writeStylesheetRef( std::string \textcolor{keyword}{const}\& url ) \{}
\DoxyCodeLine{15719         m\_os << \textcolor{stringliteral}{"{}<?xml-\/stylesheet type=\(\backslash\)"{}text/xsl\(\backslash\)"{} href=\(\backslash\)"{}"{}} << url << \textcolor{stringliteral}{"{}\(\backslash\)"{}?>\(\backslash\)n"{}};}
\DoxyCodeLine{15720     \}}
\DoxyCodeLine{15721 }
\DoxyCodeLine{15722     XmlWriter\& XmlWriter::writeBlankLine() \{}
\DoxyCodeLine{15723         ensureTagClosed();}
\DoxyCodeLine{15724         m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{15725         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{15726     \}}
\DoxyCodeLine{15727 }
\DoxyCodeLine{15728     \textcolor{keywordtype}{void} XmlWriter::ensureTagClosed() \{}
\DoxyCodeLine{15729         \textcolor{keywordflow}{if}( m\_tagIsOpen ) \{}
\DoxyCodeLine{15730             m\_os << '>\textcolor{stringliteral}{' << std::flush;}}
\DoxyCodeLine{15731 \textcolor{stringliteral}{            newlineIfNecessary();}}
\DoxyCodeLine{15732 \textcolor{stringliteral}{            m\_tagIsOpen = false;}}
\DoxyCodeLine{15733 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15734 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15735 \textcolor{stringliteral}{}}
\DoxyCodeLine{15736 \textcolor{stringliteral}{    void XmlWriter::applyFormatting(XmlFormatting fmt) \{}}
\DoxyCodeLine{15737 \textcolor{stringliteral}{        m\_needsNewline = shouldNewline(fmt);}}
\DoxyCodeLine{15738 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15739 \textcolor{stringliteral}{}}
\DoxyCodeLine{15740 \textcolor{stringliteral}{    void XmlWriter::writeDeclaration() \{}}
\DoxyCodeLine{15741 \textcolor{stringliteral}{        m\_os << "{}<?xml version=\(\backslash\)"{}1.0\(\backslash\)"{} encoding=\(\backslash\)"{}UTF-\/8\(\backslash\)"{}?>\(\backslash\)n"{};}}
\DoxyCodeLine{15742 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15743 \textcolor{stringliteral}{}}
\DoxyCodeLine{15744 \textcolor{stringliteral}{    void XmlWriter::newlineIfNecessary() \{}}
\DoxyCodeLine{15745 \textcolor{stringliteral}{        if( m\_needsNewline ) \{}}
\DoxyCodeLine{15746 \textcolor{stringliteral}{            m\_os << std::endl;}}
\DoxyCodeLine{15747 \textcolor{stringliteral}{            m\_needsNewline = false;}}
\DoxyCodeLine{15748 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15749 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15750 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15751 \textcolor{stringliteral}{// end catch\_xmlwriter.cpp}}
\DoxyCodeLine{15752 \textcolor{stringliteral}{// start catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15753 \textcolor{stringliteral}{}}
\DoxyCodeLine{15754 \textcolor{stringliteral}{\#include <cstring>}}
\DoxyCodeLine{15755 \textcolor{stringliteral}{\#include <cfloat>}}
\DoxyCodeLine{15756 \textcolor{stringliteral}{\#include <cstdio>}}
\DoxyCodeLine{15757 \textcolor{stringliteral}{\#include <cassert>}}
\DoxyCodeLine{15758 \textcolor{stringliteral}{\#include <memory>}}
\DoxyCodeLine{15759 \textcolor{stringliteral}{}}
\DoxyCodeLine{15760 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15761 \textcolor{stringliteral}{    void prepareExpandedExpression(AssertionResult\& result) \{}}
\DoxyCodeLine{15762 \textcolor{stringliteral}{        result.getExpandedExpression();}}
\DoxyCodeLine{15763 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15764 \textcolor{stringliteral}{}}
\DoxyCodeLine{15765 \textcolor{stringliteral}{    // Because formatting using c++ streams is stateful, drop down to C is required}}
\DoxyCodeLine{15766 \textcolor{stringliteral}{    // Alternatively we could use stringstream, but its performance is... not good.}}
\DoxyCodeLine{15767 \textcolor{stringliteral}{    std::string getFormattedDuration( double duration ) \{}}
\DoxyCodeLine{15768 \textcolor{stringliteral}{        // Max exponent + 1 is required to represent the whole part}}
\DoxyCodeLine{15769 \textcolor{stringliteral}{        // + 1 for decimal point}}
\DoxyCodeLine{15770 \textcolor{stringliteral}{        // + 3 for the 3 decimal places}}
\DoxyCodeLine{15771 \textcolor{stringliteral}{        // + 1 for null terminator}}
\DoxyCodeLine{15772 \textcolor{stringliteral}{        const std::size\_t maxDoubleSize = DBL\_MAX\_10\_EXP + 1 + 1 + 3 + 1;}}
\DoxyCodeLine{15773 \textcolor{stringliteral}{        char buffer[maxDoubleSize];}}
\DoxyCodeLine{15774 \textcolor{stringliteral}{}}
\DoxyCodeLine{15775 \textcolor{stringliteral}{        // Save previous errno, to prevent sprintf from overwriting it}}
\DoxyCodeLine{15776 \textcolor{stringliteral}{        ErrnoGuard guard;}}
\DoxyCodeLine{15777 \textcolor{stringliteral}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{15778 \textcolor{stringliteral}{        sprintf\_s(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15779 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15780 \textcolor{stringliteral}{        std::sprintf(buffer, "{}\%.3f"{}, duration);}}
\DoxyCodeLine{15781 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15782 \textcolor{stringliteral}{        return std::string(buffer);}}
\DoxyCodeLine{15783 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15784 \textcolor{stringliteral}{}}
\DoxyCodeLine{15785 \textcolor{stringliteral}{    bool shouldShowDuration( IConfig const\& config, double duration ) \{}}
\DoxyCodeLine{15786 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Always ) \{}}
\DoxyCodeLine{15787 \textcolor{stringliteral}{            return true;}}
\DoxyCodeLine{15788 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15789 \textcolor{stringliteral}{        if ( config.showDurations() == ShowDurations::Never ) \{}}
\DoxyCodeLine{15790 \textcolor{stringliteral}{            return false;}}
\DoxyCodeLine{15791 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15792 \textcolor{stringliteral}{        const double min = config.minDuration();}}
\DoxyCodeLine{15793 \textcolor{stringliteral}{        return min >= 0 \&\& duration >= min;}}
\DoxyCodeLine{15794 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15795 \textcolor{stringliteral}{}}
\DoxyCodeLine{15796 \textcolor{stringliteral}{    std::string serializeFilters( std::vector<std::string> const\& container ) \{}}
\DoxyCodeLine{15797 \textcolor{stringliteral}{        ReusableStringStream oss;}}
\DoxyCodeLine{15798 \textcolor{stringliteral}{        bool first = true;}}
\DoxyCodeLine{15799 \textcolor{stringliteral}{        for (auto\&\& filter : container)}}
\DoxyCodeLine{15800 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{15801 \textcolor{stringliteral}{            if (!first)}}
\DoxyCodeLine{15802 \textcolor{stringliteral}{                oss << '} \textcolor{stringliteral}{';}}
\DoxyCodeLine{15803 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15804 \textcolor{stringliteral}{                first = false;}}
\DoxyCodeLine{15805 \textcolor{stringliteral}{}}
\DoxyCodeLine{15806 \textcolor{stringliteral}{            oss << filter;}}
\DoxyCodeLine{15807 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15808 \textcolor{stringliteral}{        return oss.str();}}
\DoxyCodeLine{15809 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15810 \textcolor{stringliteral}{}}
\DoxyCodeLine{15811 \textcolor{stringliteral}{    TestEventListenerBase::TestEventListenerBase(ReporterConfig const \& \_config)}}
\DoxyCodeLine{15812 \textcolor{stringliteral}{        :StreamingReporterBase(\_config) \{\}}}
\DoxyCodeLine{15813 \textcolor{stringliteral}{}}
\DoxyCodeLine{15814 \textcolor{stringliteral}{    std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() \{}}
\DoxyCodeLine{15815 \textcolor{stringliteral}{        return \{ Verbosity::Quiet, Verbosity::Normal, Verbosity::High \};}}
\DoxyCodeLine{15816 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15817 \textcolor{stringliteral}{}}
\DoxyCodeLine{15818 \textcolor{stringliteral}{    void TestEventListenerBase::assertionStarting(AssertionInfo const \&) \{\}}}
\DoxyCodeLine{15819 \textcolor{stringliteral}{}}
\DoxyCodeLine{15820 \textcolor{stringliteral}{    bool TestEventListenerBase::assertionEnded(AssertionStats const \&) \{}}
\DoxyCodeLine{15821 \textcolor{stringliteral}{        return false;}}
\DoxyCodeLine{15822 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15823 \textcolor{stringliteral}{}}
\DoxyCodeLine{15824 \textcolor{stringliteral}{\} // end namespace Catch}}
\DoxyCodeLine{15825 \textcolor{stringliteral}{// end catch\_reporter\_bases.cpp}}
\DoxyCodeLine{15826 \textcolor{stringliteral}{// start catch\_reporter\_compact.cpp}}
\DoxyCodeLine{15827 \textcolor{stringliteral}{}}
\DoxyCodeLine{15828 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15829 \textcolor{stringliteral}{}}
\DoxyCodeLine{15830 \textcolor{stringliteral}{\#ifdef CATCH\_PLATFORM\_MAC}}
\DoxyCodeLine{15831 \textcolor{stringliteral}{    const char* failedString() \{ return "{}FAILED"{}; \}}}
\DoxyCodeLine{15832 \textcolor{stringliteral}{    const char* passedString() \{ return "{}PASSED"{}; \}}}
\DoxyCodeLine{15833 \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{15834 \textcolor{stringliteral}{    const char* failedString() \{ return "{}failed"{}; \}}}
\DoxyCodeLine{15835 \textcolor{stringliteral}{    const char* passedString() \{ return "{}passed"{}; \}}}
\DoxyCodeLine{15836 \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{15837 \textcolor{stringliteral}{}}
\DoxyCodeLine{15838 \textcolor{stringliteral}{    // Colour::LightGrey}}
\DoxyCodeLine{15839 \textcolor{stringliteral}{    Catch::Colour::Code dimColour() \{ return Catch::Colour::FileName; \}}}
\DoxyCodeLine{15840 \textcolor{stringliteral}{}}
\DoxyCodeLine{15841 \textcolor{stringliteral}{    std::string bothOrAll( std::size\_t count ) \{}}
\DoxyCodeLine{15842 \textcolor{stringliteral}{        return count == 1 ? std::string() :}}
\DoxyCodeLine{15843 \textcolor{stringliteral}{               count == 2 ? "{}both "{} : "{}all "{} ;}}
\DoxyCodeLine{15844 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15845 \textcolor{stringliteral}{}}
\DoxyCodeLine{15846 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{15847 \textcolor{stringliteral}{}}
\DoxyCodeLine{15848 \textcolor{stringliteral}{namespace Catch \{}}
\DoxyCodeLine{15849 \textcolor{stringliteral}{namespace \{}}
\DoxyCodeLine{15850 \textcolor{stringliteral}{// Colour, message variants:}}
\DoxyCodeLine{15851 \textcolor{stringliteral}{// -\/ white: No tests ran.}}
\DoxyCodeLine{15852 \textcolor{stringliteral}{// -\/   red: Failed [both/all] N test cases, failed [both/all] M assertions.}}
\DoxyCodeLine{15853 \textcolor{stringliteral}{// -\/ white: Passed [both/all] N test cases (no assertions).}}
\DoxyCodeLine{15854 \textcolor{stringliteral}{// -\/   red: Failed N tests cases, failed M assertions.}}
\DoxyCodeLine{15855 \textcolor{stringliteral}{// -\/ green: Passed [both/all] N tests cases with M assertions.}}
\DoxyCodeLine{15856 \textcolor{stringliteral}{void printTotals(std::ostream\& out, const Totals\& totals) \{}}
\DoxyCodeLine{15857 \textcolor{stringliteral}{    if (totals.testCases.total() == 0) \{}}
\DoxyCodeLine{15858 \textcolor{stringliteral}{        out << "{}No tests ran."{};}}
\DoxyCodeLine{15859 \textcolor{stringliteral}{    \} else if (totals.testCases.failed == totals.testCases.total()) \{}}
\DoxyCodeLine{15860 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15861 \textcolor{stringliteral}{        const std::string qualify\_assertions\_failed =}}
\DoxyCodeLine{15862 \textcolor{stringliteral}{            totals.assertions.failed == totals.assertions.total() ?}}
\DoxyCodeLine{15863 \textcolor{stringliteral}{            bothOrAll(totals.assertions.failed) : std::string();}}
\DoxyCodeLine{15864 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15865 \textcolor{stringliteral}{            "{}Failed "{} << bothOrAll(totals.testCases.failed)}}
\DoxyCodeLine{15866 \textcolor{stringliteral}{            << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15867 \textcolor{stringliteral}{            "{}failed "{} << qualify\_assertions\_failed <<}}
\DoxyCodeLine{15868 \textcolor{stringliteral}{            pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15869 \textcolor{stringliteral}{    \} else if (totals.assertions.total() == 0) \{}}
\DoxyCodeLine{15870 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15871 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.total())}}
\DoxyCodeLine{15872 \textcolor{stringliteral}{            << pluralise(totals.testCases.total(), "{}test case"{})}}
\DoxyCodeLine{15873 \textcolor{stringliteral}{            << "{} (no assertions)."{};}}
\DoxyCodeLine{15874 \textcolor{stringliteral}{    \} else if (totals.assertions.failed) \{}}
\DoxyCodeLine{15875 \textcolor{stringliteral}{        Colour colour(Colour::ResultError);}}
\DoxyCodeLine{15876 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15877 \textcolor{stringliteral}{            "{}Failed "{} << pluralise(totals.testCases.failed, "{}test case"{}) << "{}, "{}}}
\DoxyCodeLine{15878 \textcolor{stringliteral}{            "{}failed "{} << pluralise(totals.assertions.failed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15879 \textcolor{stringliteral}{    \} else \{}}
\DoxyCodeLine{15880 \textcolor{stringliteral}{        Colour colour(Colour::ResultSuccess);}}
\DoxyCodeLine{15881 \textcolor{stringliteral}{        out <<}}
\DoxyCodeLine{15882 \textcolor{stringliteral}{            "{}Passed "{} << bothOrAll(totals.testCases.passed)}}
\DoxyCodeLine{15883 \textcolor{stringliteral}{            << pluralise(totals.testCases.passed, "{}test case"{}) <<}}
\DoxyCodeLine{15884 \textcolor{stringliteral}{            "{} with "{} << pluralise(totals.assertions.passed, "{}assertion"{}) << '}.\textcolor{stringliteral}{';}}
\DoxyCodeLine{15885 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15886 \textcolor{stringliteral}{\}}}
\DoxyCodeLine{15887 \textcolor{stringliteral}{}}
\DoxyCodeLine{15888 \textcolor{stringliteral}{// Implementation of CompactReporter formatting}}
\DoxyCodeLine{15889 \textcolor{stringliteral}{class AssertionPrinter \{}}
\DoxyCodeLine{15890 \textcolor{stringliteral}{public:}}
\DoxyCodeLine{15891 \textcolor{stringliteral}{    AssertionPrinter\& operator= (AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15892 \textcolor{stringliteral}{    AssertionPrinter(AssertionPrinter const\&) = delete;}}
\DoxyCodeLine{15893 \textcolor{stringliteral}{    AssertionPrinter(std::ostream\& \_stream, AssertionStats const\& \_stats, bool \_printInfoMessages)}}
\DoxyCodeLine{15894 \textcolor{stringliteral}{        : stream(\_stream)}}
\DoxyCodeLine{15895 \textcolor{stringliteral}{        , result(\_stats.assertionResult)}}
\DoxyCodeLine{15896 \textcolor{stringliteral}{        , messages(\_stats.infoMessages)}}
\DoxyCodeLine{15897 \textcolor{stringliteral}{        , itMessage(\_stats.infoMessages.begin())}}
\DoxyCodeLine{15898 \textcolor{stringliteral}{        , printInfoMessages(\_printInfoMessages) \{\}}}
\DoxyCodeLine{15899 \textcolor{stringliteral}{}}
\DoxyCodeLine{15900 \textcolor{stringliteral}{    void print() \{}}
\DoxyCodeLine{15901 \textcolor{stringliteral}{        printSourceInfo();}}
\DoxyCodeLine{15902 \textcolor{stringliteral}{}}
\DoxyCodeLine{15903 \textcolor{stringliteral}{        itMessage = messages.begin();}}
\DoxyCodeLine{15904 \textcolor{stringliteral}{}}
\DoxyCodeLine{15905 \textcolor{stringliteral}{        switch (result.getResultType()) \{}}
\DoxyCodeLine{15906 \textcolor{stringliteral}{        case ResultWas::Ok:}}
\DoxyCodeLine{15907 \textcolor{stringliteral}{            printResultType(Colour::ResultSuccess, passedString());}}
\DoxyCodeLine{15908 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15909 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15910 \textcolor{stringliteral}{            if (!result.hasExpression())}}
\DoxyCodeLine{15911 \textcolor{stringliteral}{                printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15912 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15913 \textcolor{stringliteral}{                printRemainingMessages();}}
\DoxyCodeLine{15914 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15915 \textcolor{stringliteral}{        case ResultWas::ExpressionFailed:}}
\DoxyCodeLine{15916 \textcolor{stringliteral}{            if (result.isOk())}}
\DoxyCodeLine{15917 \textcolor{stringliteral}{                printResultType(Colour::ResultSuccess, failedString() + std::string("{} -\/ but was ok"{}));}}
\DoxyCodeLine{15918 \textcolor{stringliteral}{            else}}
\DoxyCodeLine{15919 \textcolor{stringliteral}{                printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15920 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15921 \textcolor{stringliteral}{            printReconstructedExpression();}}
\DoxyCodeLine{15922 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15923 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15924 \textcolor{stringliteral}{        case ResultWas::ThrewException:}}
\DoxyCodeLine{15925 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15926 \textcolor{stringliteral}{            printIssue("{}unexpected exception with message:"{});}}
\DoxyCodeLine{15927 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15928 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15929 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15930 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15931 \textcolor{stringliteral}{        case ResultWas::FatalErrorCondition:}}
\DoxyCodeLine{15932 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15933 \textcolor{stringliteral}{            printIssue("{}fatal error condition with message:"{});}}
\DoxyCodeLine{15934 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15935 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15936 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15937 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15938 \textcolor{stringliteral}{        case ResultWas::DidntThrowException:}}
\DoxyCodeLine{15939 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15940 \textcolor{stringliteral}{            printIssue("{}expected exception, got none"{});}}
\DoxyCodeLine{15941 \textcolor{stringliteral}{            printExpressionWas();}}
\DoxyCodeLine{15942 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15943 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15944 \textcolor{stringliteral}{        case ResultWas::Info:}}
\DoxyCodeLine{15945 \textcolor{stringliteral}{            printResultType(Colour::None, "{}info"{});}}
\DoxyCodeLine{15946 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15947 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15948 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15949 \textcolor{stringliteral}{        case ResultWas::Warning:}}
\DoxyCodeLine{15950 \textcolor{stringliteral}{            printResultType(Colour::None, "{}warning"{});}}
\DoxyCodeLine{15951 \textcolor{stringliteral}{            printMessage();}}
\DoxyCodeLine{15952 \textcolor{stringliteral}{            printRemainingMessages();}}
\DoxyCodeLine{15953 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15954 \textcolor{stringliteral}{        case ResultWas::ExplicitFailure:}}
\DoxyCodeLine{15955 \textcolor{stringliteral}{            printResultType(Colour::Error, failedString());}}
\DoxyCodeLine{15956 \textcolor{stringliteral}{            printIssue("{}explicitly"{});}}
\DoxyCodeLine{15957 \textcolor{stringliteral}{            printRemainingMessages(Colour::None);}}
\DoxyCodeLine{15958 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15959 \textcolor{stringliteral}{            // These cases are here to prevent compiler warnings}}
\DoxyCodeLine{15960 \textcolor{stringliteral}{        case ResultWas::Unknown:}}
\DoxyCodeLine{15961 \textcolor{stringliteral}{        case ResultWas::FailureBit:}}
\DoxyCodeLine{15962 \textcolor{stringliteral}{        case ResultWas::Exception:}}
\DoxyCodeLine{15963 \textcolor{stringliteral}{            printResultType(Colour::Error, "{}** internal error **"{});}}
\DoxyCodeLine{15964 \textcolor{stringliteral}{            break;}}
\DoxyCodeLine{15965 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15966 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15967 \textcolor{stringliteral}{}}
\DoxyCodeLine{15968 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{15969 \textcolor{stringliteral}{    void printSourceInfo() const \{}}
\DoxyCodeLine{15970 \textcolor{stringliteral}{        Colour colourGuard(Colour::FileName);}}
\DoxyCodeLine{15971 \textcolor{stringliteral}{        stream << result.getSourceInfo() << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15972 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15973 \textcolor{stringliteral}{}}
\DoxyCodeLine{15974 \textcolor{stringliteral}{    void printResultType(Colour::Code colour, std::string const\& passOrFail) const \{}}
\DoxyCodeLine{15975 \textcolor{stringliteral}{        if (!passOrFail.empty()) \{}}
\DoxyCodeLine{15976 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15977 \textcolor{stringliteral}{                Colour colourGuard(colour);}}
\DoxyCodeLine{15978 \textcolor{stringliteral}{                stream << '} \textcolor{stringliteral}{' << passOrFail;}}
\DoxyCodeLine{15979 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15980 \textcolor{stringliteral}{            stream << '}:\textcolor{stringliteral}{';}}
\DoxyCodeLine{15981 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15982 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15983 \textcolor{stringliteral}{}}
\DoxyCodeLine{15984 \textcolor{stringliteral}{    void printIssue(std::string const\& issue) const \{}}
\DoxyCodeLine{15985 \textcolor{stringliteral}{        stream << '} \textcolor{stringliteral}{' << issue;}}
\DoxyCodeLine{15986 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15987 \textcolor{stringliteral}{}}
\DoxyCodeLine{15988 \textcolor{stringliteral}{    void printExpressionWas() \{}}
\DoxyCodeLine{15989 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{15990 \textcolor{stringliteral}{            stream << '};\textcolor{stringliteral}{';}}
\DoxyCodeLine{15991 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{15992 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{15993 \textcolor{stringliteral}{                stream << "{} expression was:"{};}}
\DoxyCodeLine{15994 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{15995 \textcolor{stringliteral}{            printOriginalExpression();}}
\DoxyCodeLine{15996 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{15997 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{15998 \textcolor{stringliteral}{}}
\DoxyCodeLine{15999 \textcolor{stringliteral}{    void printOriginalExpression() const \{}}
\DoxyCodeLine{16000 \textcolor{stringliteral}{        if (result.hasExpression()) \{}}
\DoxyCodeLine{16001 \textcolor{stringliteral}{            stream << '} \textcolor{stringliteral}{' << result.getExpression();}}
\DoxyCodeLine{16002 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16003 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16004 \textcolor{stringliteral}{}}
\DoxyCodeLine{16005 \textcolor{stringliteral}{    void printReconstructedExpression() const \{}}
\DoxyCodeLine{16006 \textcolor{stringliteral}{        if (result.hasExpandedExpression()) \{}}
\DoxyCodeLine{16007 \textcolor{stringliteral}{            \{}}
\DoxyCodeLine{16008 \textcolor{stringliteral}{                Colour colour(dimColour());}}
\DoxyCodeLine{16009 \textcolor{stringliteral}{                stream << "{} for: "{};}}
\DoxyCodeLine{16010 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{16011 \textcolor{stringliteral}{            stream << result.getExpandedExpression();}}
\DoxyCodeLine{16012 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16013 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16014 \textcolor{stringliteral}{}}
\DoxyCodeLine{16015 \textcolor{stringliteral}{    void printMessage() \{}}
\DoxyCodeLine{16016 \textcolor{stringliteral}{        if (itMessage != messages.end()) \{}}
\DoxyCodeLine{16017 \textcolor{stringliteral}{            stream << "{} '}\textcolor{stringliteral}{"{} << itMessage-\/>message << '\(\backslash\)'';}}
\DoxyCodeLine{16018 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{16019 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16020 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16021 \textcolor{stringliteral}{}}
\DoxyCodeLine{16022 \textcolor{stringliteral}{    void printRemainingMessages(Colour::Code colour = dimColour()) \{}}
\DoxyCodeLine{16023 \textcolor{stringliteral}{        if (itMessage == messages.end())}}
\DoxyCodeLine{16024 \textcolor{stringliteral}{            return;}}
\DoxyCodeLine{16025 \textcolor{stringliteral}{}}
\DoxyCodeLine{16026 \textcolor{stringliteral}{        const auto itEnd = messages.cend();}}
\DoxyCodeLine{16027 \textcolor{stringliteral}{        const auto N = static\_cast<std::size\_t>(std::distance(itMessage, itEnd));}}
\DoxyCodeLine{16028 \textcolor{stringliteral}{}}
\DoxyCodeLine{16029 \textcolor{stringliteral}{        \{}}
\DoxyCodeLine{16030 \textcolor{stringliteral}{            Colour colourGuard(colour);}}
\DoxyCodeLine{16031 \textcolor{stringliteral}{            stream << "{}} with \textcolor{stringliteral}{"{} << pluralise(N, "{}}message\textcolor{stringliteral}{"{}) << ':';}}
\DoxyCodeLine{16032 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16033 \textcolor{stringliteral}{}}
\DoxyCodeLine{16034 \textcolor{stringliteral}{        while (itMessage != itEnd) \{}}
\DoxyCodeLine{16035 \textcolor{stringliteral}{            // If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{16036 \textcolor{stringliteral}{            if (printInfoMessages || itMessage-\/>type != ResultWas::Info) \{}}
\DoxyCodeLine{16037 \textcolor{stringliteral}{                printMessage();}}
\DoxyCodeLine{16038 \textcolor{stringliteral}{                if (itMessage != itEnd) \{}}
\DoxyCodeLine{16039 \textcolor{stringliteral}{                    Colour colourGuard(dimColour());}}
\DoxyCodeLine{16040 \textcolor{stringliteral}{                    stream << "{}} and\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{16041 \textcolor{stringliteral}{                \}}}
\DoxyCodeLine{16042 \textcolor{stringliteral}{                continue;}}
\DoxyCodeLine{16043 \textcolor{stringliteral}{            \}}}
\DoxyCodeLine{16044 \textcolor{stringliteral}{            ++itMessage;}}
\DoxyCodeLine{16045 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16046 \textcolor{stringliteral}{    \}}}
\DoxyCodeLine{16047 \textcolor{stringliteral}{}}
\DoxyCodeLine{16048 \textcolor{stringliteral}{private:}}
\DoxyCodeLine{16049 \textcolor{stringliteral}{    std::ostream\& stream;}}
\DoxyCodeLine{16050 \textcolor{stringliteral}{    AssertionResult const\& result;}}
\DoxyCodeLine{16051 \textcolor{stringliteral}{    std::vector<MessageInfo> messages;}}
\DoxyCodeLine{16052 \textcolor{stringliteral}{    std::vector<MessageInfo>::const\_iterator itMessage;}}
\DoxyCodeLine{16053 \textcolor{stringliteral}{    bool printInfoMessages;}}
\DoxyCodeLine{16054 \textcolor{stringliteral}{\};}}
\DoxyCodeLine{16055 \textcolor{stringliteral}{}}
\DoxyCodeLine{16056 \textcolor{stringliteral}{\} // anon namespace}}
\DoxyCodeLine{16057 \textcolor{stringliteral}{}}
\DoxyCodeLine{16058 \textcolor{stringliteral}{        std::string CompactReporter::getDescription() \{}}
\DoxyCodeLine{16059 \textcolor{stringliteral}{            return "{}}Reports test results on a single line, suitable \textcolor{keywordflow}{for} IDEs\textcolor{stringliteral}{"{};}}
\DoxyCodeLine{16060 \textcolor{stringliteral}{        \}}}
\DoxyCodeLine{16061 \textcolor{stringliteral}{}}
\DoxyCodeLine{16062 \textcolor{stringliteral}{        void CompactReporter::noMatchingTestCases( std::string const\& spec ) \{}}
\DoxyCodeLine{16063 \textcolor{stringliteral}{            stream << "{}}No test cases matched \textcolor{stringliteral}{'"{} << spec << '}\(\backslash\)\textcolor{stringliteral}{''} << std::endl;}
\DoxyCodeLine{16064         \}}
\DoxyCodeLine{16065 }
\DoxyCodeLine{16066         \textcolor{keywordtype}{void} CompactReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{\}}
\DoxyCodeLine{16067 }
\DoxyCodeLine{16068         \textcolor{keywordtype}{bool} CompactReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& \_assertionStats ) \{}
\DoxyCodeLine{16069             AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16070 }
\DoxyCodeLine{16071             \textcolor{keywordtype}{bool} printInfoMessages = \textcolor{keyword}{true};}
\DoxyCodeLine{16072 }
\DoxyCodeLine{16073             \textcolor{comment}{// Drop out if result was successful and we're not printing those}}
\DoxyCodeLine{16074             \textcolor{keywordflow}{if}( !m\_config-\/>includeSuccessfulResults() \&\& result.isOk() ) \{}
\DoxyCodeLine{16075                 \textcolor{keywordflow}{if}( result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{16076                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16077                 printInfoMessages = \textcolor{keyword}{false};}
\DoxyCodeLine{16078             \}}
\DoxyCodeLine{16079 }
\DoxyCodeLine{16080             AssertionPrinter printer( stream, \_assertionStats, printInfoMessages );}
\DoxyCodeLine{16081             printer.print();}
\DoxyCodeLine{16082 }
\DoxyCodeLine{16083             stream << std::endl;}
\DoxyCodeLine{16084             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16085         \}}
\DoxyCodeLine{16086 }
\DoxyCodeLine{16087         \textcolor{keywordtype}{void} CompactReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16088             \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16089             \textcolor{keywordflow}{if} ( shouldShowDuration( *m\_config, dur ) ) \{}
\DoxyCodeLine{16090                 stream << getFormattedDuration( dur ) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16091             \}}
\DoxyCodeLine{16092         \}}
\DoxyCodeLine{16093 }
\DoxyCodeLine{16094         \textcolor{keywordtype}{void} CompactReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& \_testRunStats ) \{}
\DoxyCodeLine{16095             printTotals( stream, \_testRunStats.totals );}
\DoxyCodeLine{16096             stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16097             StreamingReporterBase::testRunEnded( \_testRunStats );}
\DoxyCodeLine{16098         \}}
\DoxyCodeLine{16099 }
\DoxyCodeLine{16100         CompactReporter::\string~CompactReporter() \{\}}
\DoxyCodeLine{16101 }
\DoxyCodeLine{16102     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}compact"{}}, CompactReporter )}
\DoxyCodeLine{16103 }
\DoxyCodeLine{16104 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16105 \textcolor{comment}{// end catch\_reporter\_compact.cpp}}
\DoxyCodeLine{16106 \textcolor{comment}{// start catch\_reporter\_console.cpp}}
\DoxyCodeLine{16107 }
\DoxyCodeLine{16108 \textcolor{preprocessor}{\#include <cfloat>}}
\DoxyCodeLine{16109 \textcolor{preprocessor}{\#include <cstdio>}}
\DoxyCodeLine{16110 }
\DoxyCodeLine{16111 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16112 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{16113 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{16114  \textcolor{comment}{// Note that 4062 (not all labels are handled and default is missing) is enabled}}
\DoxyCodeLine{16115 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16116 }
\DoxyCodeLine{16117 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16118 \textcolor{preprocessor}{\#  pragma clang diagnostic push}}
\DoxyCodeLine{16119 \textcolor{comment}{// For simplicity, benchmarking-\/only helpers are always enabled}}
\DoxyCodeLine{16120 \textcolor{preprocessor}{\#  pragma clang diagnostic ignored "{}-\/Wunused-\/function"{}}}
\DoxyCodeLine{16121 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16122 }
\DoxyCodeLine{16123 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16124 }
\DoxyCodeLine{16125 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16126 }
\DoxyCodeLine{16127 \textcolor{comment}{// Formatter impl for ConsoleReporter}}
\DoxyCodeLine{16128 \textcolor{keyword}{class }ConsoleAssertionPrinter \{}
\DoxyCodeLine{16129 \textcolor{keyword}{public}:}
\DoxyCodeLine{16130     ConsoleAssertionPrinter\& operator= (ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16131     ConsoleAssertionPrinter(ConsoleAssertionPrinter \textcolor{keyword}{const}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{16132     ConsoleAssertionPrinter(std::ostream\& \_stream, AssertionStats \textcolor{keyword}{const}\& \_stats, \textcolor{keywordtype}{bool} \_printInfoMessages)}
\DoxyCodeLine{16133         : stream(\_stream),}
\DoxyCodeLine{16134         stats(\_stats),}
\DoxyCodeLine{16135         result(\_stats.assertionResult),}
\DoxyCodeLine{16136         colour(Colour::None),}
\DoxyCodeLine{16137         message(result.getMessage()),}
\DoxyCodeLine{16138         messages(\_stats.infoMessages),}
\DoxyCodeLine{16139         printInfoMessages(\_printInfoMessages) \{}
\DoxyCodeLine{16140         \textcolor{keywordflow}{switch} (result.getResultType()) \{}
\DoxyCodeLine{16141         \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{16142             colour = Colour::Success;}
\DoxyCodeLine{16143             passOrFail = \textcolor{stringliteral}{"{}PASSED"{}};}
\DoxyCodeLine{16144             \textcolor{comment}{//if( result.hasMessage() )}}
\DoxyCodeLine{16145             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16146                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16147             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16148                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16149             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16150         \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{16151             \textcolor{keywordflow}{if} (result.isOk()) \{}
\DoxyCodeLine{16152                 colour = Colour::Success;}
\DoxyCodeLine{16153                 passOrFail = \textcolor{stringliteral}{"{}FAILED -\/ but was ok"{}};}
\DoxyCodeLine{16154             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16155                 colour = Colour::Error;}
\DoxyCodeLine{16156                 passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16157             \}}
\DoxyCodeLine{16158             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16159                 messageLabel = \textcolor{stringliteral}{"{}with message"{}};}
\DoxyCodeLine{16160             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16161                 messageLabel = \textcolor{stringliteral}{"{}with messages"{}};}
\DoxyCodeLine{16162             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16163         \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{16164             colour = Colour::Error;}
\DoxyCodeLine{16165             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16166             messageLabel = \textcolor{stringliteral}{"{}due to unexpected exception with "{}};}
\DoxyCodeLine{16167             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16168                 messageLabel += "{}message"{};}
\DoxyCodeLine{16169             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16170                 messageLabel += "{}messages"{};}
\DoxyCodeLine{16171             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16172         \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{16173             colour = Colour::Error;}
\DoxyCodeLine{16174             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16175             messageLabel = \textcolor{stringliteral}{"{}due to a fatal error condition"{}};}
\DoxyCodeLine{16176             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16177         \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{16178             colour = Colour::Error;}
\DoxyCodeLine{16179             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16180             messageLabel = \textcolor{stringliteral}{"{}because no exception was thrown where one was expected"{}};}
\DoxyCodeLine{16181             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16182         \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{16183             messageLabel = \textcolor{stringliteral}{"{}info"{}};}
\DoxyCodeLine{16184             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16185         \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{16186             messageLabel = \textcolor{stringliteral}{"{}warning"{}};}
\DoxyCodeLine{16187             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16188         \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{16189             passOrFail = \textcolor{stringliteral}{"{}FAILED"{}};}
\DoxyCodeLine{16190             colour = Colour::Error;}
\DoxyCodeLine{16191             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() == 1)}
\DoxyCodeLine{16192                 messageLabel = \textcolor{stringliteral}{"{}explicitly with message"{}};}
\DoxyCodeLine{16193             \textcolor{keywordflow}{if} (\_stats.infoMessages.size() > 1)}
\DoxyCodeLine{16194                 messageLabel = \textcolor{stringliteral}{"{}explicitly with messages"{}};}
\DoxyCodeLine{16195             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16196             \textcolor{comment}{// These cases are here to prevent compiler warnings}}
\DoxyCodeLine{16197         \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{16198         \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{16199         \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{16200             passOrFail = \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16201             colour = Colour::Error;}
\DoxyCodeLine{16202             \textcolor{keywordflow}{break};}
\DoxyCodeLine{16203         \}}
\DoxyCodeLine{16204     \}}
\DoxyCodeLine{16205 }
\DoxyCodeLine{16206     \textcolor{keywordtype}{void} print()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16207         printSourceInfo();}
\DoxyCodeLine{16208         \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{16209             printResultType();}
\DoxyCodeLine{16210             printOriginalExpression();}
\DoxyCodeLine{16211             printReconstructedExpression();}
\DoxyCodeLine{16212         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16213             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16214         \}}
\DoxyCodeLine{16215         printMessage();}
\DoxyCodeLine{16216     \}}
\DoxyCodeLine{16217 }
\DoxyCodeLine{16218 \textcolor{keyword}{private}:}
\DoxyCodeLine{16219     \textcolor{keywordtype}{void} printResultType()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16220         \textcolor{keywordflow}{if} (!passOrFail.empty()) \{}
\DoxyCodeLine{16221             Colour colourGuard(colour);}
\DoxyCodeLine{16222             stream << passOrFail << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{16223         \}}
\DoxyCodeLine{16224     \}}
\DoxyCodeLine{16225     \textcolor{keywordtype}{void} printOriginalExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16226         \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{16227             Colour colourGuard(Colour::OriginalExpression);}
\DoxyCodeLine{16228             stream << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{16229             stream << result.getExpressionInMacro();}
\DoxyCodeLine{16230             stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16231         \}}
\DoxyCodeLine{16232     \}}
\DoxyCodeLine{16233     \textcolor{keywordtype}{void} printReconstructedExpression()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16234         \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{16235             stream << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{16236             Colour colourGuard(Colour::ReconstructedExpression);}
\DoxyCodeLine{16237             stream << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16238         \}}
\DoxyCodeLine{16239     \}}
\DoxyCodeLine{16240     \textcolor{keywordtype}{void} printMessage()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16241         \textcolor{keywordflow}{if} (!messageLabel.empty())}
\DoxyCodeLine{16242             stream << messageLabel << \textcolor{charliteral}{':'} << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16243         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : messages) \{}
\DoxyCodeLine{16244             \textcolor{comment}{// If this assertion is a warning ignore any INFO messages}}
\DoxyCodeLine{16245             \textcolor{keywordflow}{if} (printInfoMessages || msg.type != ResultWas::Info)}
\DoxyCodeLine{16246                 stream << Column(msg.message).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16247         \}}
\DoxyCodeLine{16248     \}}
\DoxyCodeLine{16249     \textcolor{keywordtype}{void} printSourceInfo()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{16250         Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16251         stream << result.getSourceInfo() << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16252     \}}
\DoxyCodeLine{16253 }
\DoxyCodeLine{16254     std::ostream\& stream;}
\DoxyCodeLine{16255     AssertionStats \textcolor{keyword}{const}\& stats;}
\DoxyCodeLine{16256     AssertionResult \textcolor{keyword}{const}\& result;}
\DoxyCodeLine{16257     Colour::Code colour;}
\DoxyCodeLine{16258     std::string passOrFail;}
\DoxyCodeLine{16259     std::string messageLabel;}
\DoxyCodeLine{16260     std::string message;}
\DoxyCodeLine{16261     std::vector<MessageInfo> messages;}
\DoxyCodeLine{16262     \textcolor{keywordtype}{bool} printInfoMessages;}
\DoxyCodeLine{16263 \};}
\DoxyCodeLine{16264 }
\DoxyCodeLine{16265 std::size\_t makeRatio(std::size\_t number, std::size\_t total) \{}
\DoxyCodeLine{16266     std::size\_t ratio = total > 0 ? CATCH\_CONFIG\_CONSOLE\_WIDTH * number / total : 0;}
\DoxyCodeLine{16267     \textcolor{keywordflow}{return} (ratio == 0 \&\& number > 0) ? 1 : ratio;}
\DoxyCodeLine{16268 \}}
\DoxyCodeLine{16269 }
\DoxyCodeLine{16270 std::size\_t\& findMax(std::size\_t\& i, std::size\_t\& j, std::size\_t\& k) \{}
\DoxyCodeLine{16271     \textcolor{keywordflow}{if} (i > j \&\& i > k)}
\DoxyCodeLine{16272         \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{16273     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j > k)}
\DoxyCodeLine{16274         \textcolor{keywordflow}{return} j;}
\DoxyCodeLine{16275     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16276         \textcolor{keywordflow}{return} k;}
\DoxyCodeLine{16277 \}}
\DoxyCodeLine{16278 }
\DoxyCodeLine{16279 \textcolor{keyword}{struct }ColumnInfo \{}
\DoxyCodeLine{16280     \textcolor{keyword}{enum} Justification \{ Left, Right \};}
\DoxyCodeLine{16281     std::string name;}
\DoxyCodeLine{16282     \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{16283     Justification justification;}
\DoxyCodeLine{16284 \};}
\DoxyCodeLine{16285 \textcolor{keyword}{struct }ColumnBreak \{\};}
\DoxyCodeLine{16286 \textcolor{keyword}{struct }RowBreak \{\};}
\DoxyCodeLine{16287 }
\DoxyCodeLine{16288 \textcolor{keyword}{class }Duration \{}
\DoxyCodeLine{16289     \textcolor{keyword}{enum class} Unit \{}
\DoxyCodeLine{16290         Auto,}
\DoxyCodeLine{16291         Nanoseconds,}
\DoxyCodeLine{16292         Microseconds,}
\DoxyCodeLine{16293         Milliseconds,}
\DoxyCodeLine{16294         Seconds,}
\DoxyCodeLine{16295         Minutes}
\DoxyCodeLine{16296     \};}
\DoxyCodeLine{16297     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMicrosecond = 1000;}
\DoxyCodeLine{16298     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMillisecond = 1000 * s\_nanosecondsInAMicrosecond;}
\DoxyCodeLine{16299     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInASecond = 1000 * s\_nanosecondsInAMillisecond;}
\DoxyCodeLine{16300     \textcolor{keyword}{static} \textcolor{keyword}{const} uint64\_t s\_nanosecondsInAMinute = 60 * s\_nanosecondsInASecond;}
\DoxyCodeLine{16301 }
\DoxyCodeLine{16302     \textcolor{keywordtype}{double} m\_inNanoseconds;}
\DoxyCodeLine{16303     Unit m\_units;}
\DoxyCodeLine{16304 }
\DoxyCodeLine{16305 \textcolor{keyword}{public}:}
\DoxyCodeLine{16306     \textcolor{keyword}{explicit} Duration(\textcolor{keywordtype}{double} inNanoseconds, Unit units = Unit::Auto)}
\DoxyCodeLine{16307         : m\_inNanoseconds(inNanoseconds),}
\DoxyCodeLine{16308         m\_units(units) \{}
\DoxyCodeLine{16309         \textcolor{keywordflow}{if} (m\_units == Unit::Auto) \{}
\DoxyCodeLine{16310             \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMicrosecond)}
\DoxyCodeLine{16311                 m\_units = Unit::Nanoseconds;}
\DoxyCodeLine{16312             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMillisecond)}
\DoxyCodeLine{16313                 m\_units = Unit::Microseconds;}
\DoxyCodeLine{16314             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInASecond)}
\DoxyCodeLine{16315                 m\_units = Unit::Milliseconds;}
\DoxyCodeLine{16316             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (m\_inNanoseconds < s\_nanosecondsInAMinute)}
\DoxyCodeLine{16317                 m\_units = Unit::Seconds;}
\DoxyCodeLine{16318             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16319                 m\_units = Unit::Minutes;}
\DoxyCodeLine{16320         \}}
\DoxyCodeLine{16321 }
\DoxyCodeLine{16322     \}}
\DoxyCodeLine{16323 }
\DoxyCodeLine{16324     \textcolor{keyword}{auto} value() const -\/> \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{16325         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16326         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16327             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMicrosecond);}
\DoxyCodeLine{16328         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16329             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMillisecond);}
\DoxyCodeLine{16330         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16331             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInASecond);}
\DoxyCodeLine{16332         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16333             \textcolor{keywordflow}{return} m\_inNanoseconds / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(s\_nanosecondsInAMinute);}
\DoxyCodeLine{16334         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16335             \textcolor{keywordflow}{return} m\_inNanoseconds;}
\DoxyCodeLine{16336         \}}
\DoxyCodeLine{16337     \}}
\DoxyCodeLine{16338     \textcolor{keyword}{auto} unitsAsString() const -\/> std::\textcolor{keywordtype}{string} \{}
\DoxyCodeLine{16339         \textcolor{keywordflow}{switch} (m\_units) \{}
\DoxyCodeLine{16340         \textcolor{keywordflow}{case} Unit::Nanoseconds:}
\DoxyCodeLine{16341             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ns"{}};}
\DoxyCodeLine{16342         \textcolor{keywordflow}{case} Unit::Microseconds:}
\DoxyCodeLine{16343             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}us"{}};}
\DoxyCodeLine{16344         \textcolor{keywordflow}{case} Unit::Milliseconds:}
\DoxyCodeLine{16345             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}ms"{}};}
\DoxyCodeLine{16346         \textcolor{keywordflow}{case} Unit::Seconds:}
\DoxyCodeLine{16347             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}s"{}};}
\DoxyCodeLine{16348         \textcolor{keywordflow}{case} Unit::Minutes:}
\DoxyCodeLine{16349             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}m"{}};}
\DoxyCodeLine{16350         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{16351             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}** internal error **"{}};}
\DoxyCodeLine{16352         \}}
\DoxyCodeLine{16353 }
\DoxyCodeLine{16354     \}}
\DoxyCodeLine{16355     \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator << (std::ostream\& os, Duration \textcolor{keyword}{const}\& duration) -\/> std::ostream\& \{}
\DoxyCodeLine{16356         \textcolor{keywordflow}{return} os << duration.value() << \textcolor{charliteral}{' '} << duration.unitsAsString();}
\DoxyCodeLine{16357     \}}
\DoxyCodeLine{16358 \};}
\DoxyCodeLine{16359 \} \textcolor{comment}{// end anon namespace}}
\DoxyCodeLine{16360 }
\DoxyCodeLine{16361 \textcolor{keyword}{class }TablePrinter \{}
\DoxyCodeLine{16362     std::ostream\& m\_os;}
\DoxyCodeLine{16363     std::vector<ColumnInfo> m\_columnInfos;}
\DoxyCodeLine{16364     std::ostringstream m\_oss;}
\DoxyCodeLine{16365     \textcolor{keywordtype}{int} m\_currentColumn = -\/1;}
\DoxyCodeLine{16366     \textcolor{keywordtype}{bool} m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16367 }
\DoxyCodeLine{16368 \textcolor{keyword}{public}:}
\DoxyCodeLine{16369     TablePrinter( std::ostream\& os, std::vector<ColumnInfo> columnInfos )}
\DoxyCodeLine{16370     :   m\_os( os ),}
\DoxyCodeLine{16371         m\_columnInfos( std::move( columnInfos ) ) \{\}}
\DoxyCodeLine{16372 }
\DoxyCodeLine{16373     \textcolor{keyword}{auto} columnInfos() const -\/> std::vector<ColumnInfo> const\& \{}
\DoxyCodeLine{16374         \textcolor{keywordflow}{return} m\_columnInfos;}
\DoxyCodeLine{16375     \}}
\DoxyCodeLine{16376 }
\DoxyCodeLine{16377     \textcolor{keywordtype}{void} open() \{}
\DoxyCodeLine{16378         \textcolor{keywordflow}{if} (!m\_isOpen) \{}
\DoxyCodeLine{16379             m\_isOpen = \textcolor{keyword}{true};}
\DoxyCodeLine{16380             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16381 }
\DoxyCodeLine{16382             Columns headerCols;}
\DoxyCodeLine{16383             Spacer spacer(2);}
\DoxyCodeLine{16384             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& info : m\_columnInfos) \{}
\DoxyCodeLine{16385                 headerCols += Column(info.name).width(static\_cast<std::size\_t>(info.width -\/ 2));}
\DoxyCodeLine{16386                 headerCols += spacer;}
\DoxyCodeLine{16387             \}}
\DoxyCodeLine{16388             m\_os << headerCols << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16389 }
\DoxyCodeLine{16390             m\_os << Catch::getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16391         \}}
\DoxyCodeLine{16392     \}}
\DoxyCodeLine{16393     \textcolor{keywordtype}{void} close() \{}
\DoxyCodeLine{16394         \textcolor{keywordflow}{if} (m\_isOpen) \{}
\DoxyCodeLine{16395             *\textcolor{keyword}{this} << RowBreak();}
\DoxyCodeLine{16396             m\_os << std::endl;}
\DoxyCodeLine{16397             m\_isOpen = \textcolor{keyword}{false};}
\DoxyCodeLine{16398         \}}
\DoxyCodeLine{16399     \}}
\DoxyCodeLine{16400 }
\DoxyCodeLine{16401     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{16402     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, T \textcolor{keyword}{const}\& value) \{}
\DoxyCodeLine{16403         tp.m\_oss << value;}
\DoxyCodeLine{16404         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16405     \}}
\DoxyCodeLine{16406 }
\DoxyCodeLine{16407     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, ColumnBreak) \{}
\DoxyCodeLine{16408         \textcolor{keyword}{auto} colStr = tp.m\_oss.str();}
\DoxyCodeLine{16409         \textcolor{keyword}{const} \textcolor{keyword}{auto} strSize = colStr.size();}
\DoxyCodeLine{16410         tp.m\_oss.str(\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{16411         tp.open();}
\DoxyCodeLine{16412         \textcolor{keywordflow}{if} (tp.m\_currentColumn == \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(tp.m\_columnInfos.size() -\/ 1)) \{}
\DoxyCodeLine{16413             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16414             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16415         \}}
\DoxyCodeLine{16416         tp.m\_currentColumn++;}
\DoxyCodeLine{16417 }
\DoxyCodeLine{16418         \textcolor{keyword}{auto} colInfo = tp.m\_columnInfos[tp.m\_currentColumn];}
\DoxyCodeLine{16419         \textcolor{keyword}{auto} padding = (strSize + 1 < static\_cast<std::size\_t>(colInfo.width))}
\DoxyCodeLine{16420             ? std::string(colInfo.width -\/ (strSize + 1), ' ')}
\DoxyCodeLine{16421             : std::string();}
\DoxyCodeLine{16422         \textcolor{keywordflow}{if} (colInfo.justification == ColumnInfo::Left)}
\DoxyCodeLine{16423             tp.m\_os << colStr << padding << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16424         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16425             tp.m\_os << padding << colStr << \textcolor{charliteral}{' '};}
\DoxyCodeLine{16426         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16427     \}}
\DoxyCodeLine{16428 }
\DoxyCodeLine{16429     \textcolor{keyword}{friend} TablePrinter\& operator << (TablePrinter\& tp, RowBreak) \{}
\DoxyCodeLine{16430         \textcolor{keywordflow}{if} (tp.m\_currentColumn > 0) \{}
\DoxyCodeLine{16431             tp.m\_os << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16432             tp.m\_currentColumn = -\/1;}
\DoxyCodeLine{16433         \}}
\DoxyCodeLine{16434         \textcolor{keywordflow}{return} tp;}
\DoxyCodeLine{16435     \}}
\DoxyCodeLine{16436 \};}
\DoxyCodeLine{16437 }
\DoxyCodeLine{16438 ConsoleReporter::ConsoleReporter(ReporterConfig \textcolor{keyword}{const}\& config)}
\DoxyCodeLine{16439     : StreamingReporterBase(config),}
\DoxyCodeLine{16440     m\_tablePrinter(new TablePrinter(config.stream(),}
\DoxyCodeLine{16441         [\&config]() -\/> std::vector<ColumnInfo> \{}
\DoxyCodeLine{16442         \textcolor{keywordflow}{if} (config.fullConfig()-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16443         \{}
\DoxyCodeLine{16444             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16445                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16446                 \{ \textcolor{stringliteral}{"{}     samples"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16447                 \{ \textcolor{stringliteral}{"{}  iterations"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16448                 \{ \textcolor{stringliteral}{"{}        mean"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16449             \};}
\DoxyCodeLine{16450         \}}
\DoxyCodeLine{16451         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16452         \{}
\DoxyCodeLine{16453             \textcolor{keywordflow}{return}\{}
\DoxyCodeLine{16454                 \{ \textcolor{stringliteral}{"{}benchmark name"{}}, CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 43, ColumnInfo::Left \},}
\DoxyCodeLine{16455                 \{ \textcolor{stringliteral}{"{}samples      mean       std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16456                 \{ \textcolor{stringliteral}{"{}iterations   low mean   low std dev"{}}, 14, ColumnInfo::Right \},}
\DoxyCodeLine{16457                 \{ \textcolor{stringliteral}{"{}estimated    high mean  high std dev"{}}, 14, ColumnInfo::Right \}}
\DoxyCodeLine{16458             \};}
\DoxyCodeLine{16459         \}}
\DoxyCodeLine{16460     \}())) \{\}}
\DoxyCodeLine{16461 ConsoleReporter::\string~ConsoleReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{16462 }
\DoxyCodeLine{16463 std::string ConsoleReporter::getDescription() \{}
\DoxyCodeLine{16464     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as plain lines of text"{}};}
\DoxyCodeLine{16465 \}}
\DoxyCodeLine{16466 }
\DoxyCodeLine{16467 \textcolor{keywordtype}{void} ConsoleReporter::noMatchingTestCases(std::string \textcolor{keyword}{const}\& spec) \{}
\DoxyCodeLine{16468     stream << \textcolor{stringliteral}{"{}No test cases matched '"{}} << spec << \textcolor{charliteral}{'\(\backslash\)''} << std::endl;}
\DoxyCodeLine{16469 \}}
\DoxyCodeLine{16470 }
\DoxyCodeLine{16471 \textcolor{keywordtype}{void} ConsoleReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{16472     stream << \textcolor{stringliteral}{"{}Invalid Filter: "{}} << arg << std::endl;}
\DoxyCodeLine{16473 \}}
\DoxyCodeLine{16474 }
\DoxyCodeLine{16475 \textcolor{keywordtype}{void} ConsoleReporter::assertionStarting(AssertionInfo \textcolor{keyword}{const}\&) \{\}}
\DoxyCodeLine{16476 }
\DoxyCodeLine{16477 \textcolor{keywordtype}{bool} ConsoleReporter::assertionEnded(AssertionStats \textcolor{keyword}{const}\& \_assertionStats) \{}
\DoxyCodeLine{16478     AssertionResult \textcolor{keyword}{const}\& result = \_assertionStats.assertionResult;}
\DoxyCodeLine{16479 }
\DoxyCodeLine{16480     \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{16481 }
\DoxyCodeLine{16482     \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{16483     \textcolor{keywordflow}{if} (!includeResults \&\& result.getResultType() != ResultWas::Warning)}
\DoxyCodeLine{16484         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{16485 }
\DoxyCodeLine{16486     lazyPrint();}
\DoxyCodeLine{16487 }
\DoxyCodeLine{16488     ConsoleAssertionPrinter printer(stream, \_assertionStats, includeResults);}
\DoxyCodeLine{16489     printer.print();}
\DoxyCodeLine{16490     stream << std::endl;}
\DoxyCodeLine{16491     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{16492 \}}
\DoxyCodeLine{16493 }
\DoxyCodeLine{16494 \textcolor{keywordtype}{void} ConsoleReporter::sectionStarting(SectionInfo \textcolor{keyword}{const}\& \_sectionInfo) \{}
\DoxyCodeLine{16495     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16496     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16497     StreamingReporterBase::sectionStarting(\_sectionInfo);}
\DoxyCodeLine{16498 \}}
\DoxyCodeLine{16499 \textcolor{keywordtype}{void} ConsoleReporter::sectionEnded(SectionStats \textcolor{keyword}{const}\& \_sectionStats) \{}
\DoxyCodeLine{16500     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16501     \textcolor{keywordflow}{if} (\_sectionStats.missingAssertions) \{}
\DoxyCodeLine{16502         lazyPrint();}
\DoxyCodeLine{16503         Colour colour(Colour::ResultError);}
\DoxyCodeLine{16504         \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1)}
\DoxyCodeLine{16505             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in section"{}};}
\DoxyCodeLine{16506         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16507             stream << \textcolor{stringliteral}{"{}\(\backslash\)nNo assertions in test case"{}};}
\DoxyCodeLine{16508         stream << \textcolor{stringliteral}{"{} '"{}} << \_sectionStats.sectionInfo.name << \textcolor{stringliteral}{"{}'\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{16509     \}}
\DoxyCodeLine{16510     \textcolor{keywordtype}{double} dur = \_sectionStats.durationInSeconds;}
\DoxyCodeLine{16511     \textcolor{keywordflow}{if} (shouldShowDuration(*m\_config, dur)) \{}
\DoxyCodeLine{16512         stream << getFormattedDuration(dur) << \textcolor{stringliteral}{"{} s: "{}} << \_sectionStats.sectionInfo.name << std::endl;}
\DoxyCodeLine{16513     \}}
\DoxyCodeLine{16514     \textcolor{keywordflow}{if} (m\_headerPrinted) \{}
\DoxyCodeLine{16515         m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16516     \}}
\DoxyCodeLine{16517     StreamingReporterBase::sectionEnded(\_sectionStats);}
\DoxyCodeLine{16518 \}}
\DoxyCodeLine{16519 }
\DoxyCodeLine{16520 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{16521 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{16522     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16523 }
\DoxyCodeLine{16524     \textcolor{keyword}{auto} nameCol = Column(name).width(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(m\_tablePrinter-\/>columnInfos()[0].width -\/ 2));}
\DoxyCodeLine{16525 }
\DoxyCodeLine{16526     \textcolor{keywordtype}{bool} firstLine = \textcolor{keyword}{true};}
\DoxyCodeLine{16527     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} line : nameCol) \{}
\DoxyCodeLine{16528         \textcolor{keywordflow}{if} (!firstLine)}
\DoxyCodeLine{16529             (*m\_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16530         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16531             firstLine = \textcolor{keyword}{false};}
\DoxyCodeLine{16532 }
\DoxyCodeLine{16533         (*m\_tablePrinter) << line << ColumnBreak();}
\DoxyCodeLine{16534     \}}
\DoxyCodeLine{16535 \}}
\DoxyCodeLine{16536 }
\DoxyCodeLine{16537 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const}\& info) \{}
\DoxyCodeLine{16538     (*m\_tablePrinter) << info.samples << ColumnBreak()}
\DoxyCodeLine{16539         << info.iterations << ColumnBreak();}
\DoxyCodeLine{16540     \textcolor{keywordflow}{if} (!m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16541         (*m\_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();}
\DoxyCodeLine{16542 \}}
\DoxyCodeLine{16543 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& stats) \{}
\DoxyCodeLine{16544     \textcolor{keywordflow}{if} (m\_config-\/>benchmarkNoAnalysis())}
\DoxyCodeLine{16545     \{}
\DoxyCodeLine{16546         (*m\_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();}
\DoxyCodeLine{16547     \}}
\DoxyCodeLine{16548     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16549     \{}
\DoxyCodeLine{16550         (*m\_tablePrinter) << ColumnBreak()}
\DoxyCodeLine{16551             << Duration(stats.mean.point.count()) << ColumnBreak()}
\DoxyCodeLine{16552             << Duration(stats.mean.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16553             << Duration(stats.mean.upper\_bound.count()) << ColumnBreak() << ColumnBreak()}
\DoxyCodeLine{16554             << Duration(stats.standardDeviation.point.count()) << ColumnBreak()}
\DoxyCodeLine{16555             << Duration(stats.standardDeviation.lower\_bound.count()) << ColumnBreak()}
\DoxyCodeLine{16556             << Duration(stats.standardDeviation.upper\_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();}
\DoxyCodeLine{16557     \}}
\DoxyCodeLine{16558 \}}
\DoxyCodeLine{16559 }
\DoxyCodeLine{16560 \textcolor{keywordtype}{void} ConsoleReporter::benchmarkFailed(std::string \textcolor{keyword}{const}\& error) \{}
\DoxyCodeLine{16561     Colour colour(Colour::Red);}
\DoxyCodeLine{16562     (*m\_tablePrinter)}
\DoxyCodeLine{16563         << \textcolor{stringliteral}{"{}Benchmark failed ("{}} << error << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16564         << ColumnBreak() << RowBreak();}
\DoxyCodeLine{16565 \}}
\DoxyCodeLine{16566 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{16567 }
\DoxyCodeLine{16568 \textcolor{keywordtype}{void} ConsoleReporter::testCaseEnded(TestCaseStats \textcolor{keyword}{const}\& \_testCaseStats) \{}
\DoxyCodeLine{16569     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16570     StreamingReporterBase::testCaseEnded(\_testCaseStats);}
\DoxyCodeLine{16571     m\_headerPrinted = \textcolor{keyword}{false};}
\DoxyCodeLine{16572 \}}
\DoxyCodeLine{16573 \textcolor{keywordtype}{void} ConsoleReporter::testGroupEnded(TestGroupStats \textcolor{keyword}{const}\& \_testGroupStats) \{}
\DoxyCodeLine{16574     \textcolor{keywordflow}{if} (currentGroupInfo.used) \{}
\DoxyCodeLine{16575         printSummaryDivider();}
\DoxyCodeLine{16576         stream << \textcolor{stringliteral}{"{}Summary for group '"{}} << \_testGroupStats.groupInfo.name << \textcolor{stringliteral}{"{}':\(\backslash\)n"{}};}
\DoxyCodeLine{16577         printTotals(\_testGroupStats.totals);}
\DoxyCodeLine{16578         stream << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16579     \}}
\DoxyCodeLine{16580     StreamingReporterBase::testGroupEnded(\_testGroupStats);}
\DoxyCodeLine{16581 \}}
\DoxyCodeLine{16582 \textcolor{keywordtype}{void} ConsoleReporter::testRunEnded(TestRunStats \textcolor{keyword}{const}\& \_testRunStats) \{}
\DoxyCodeLine{16583     printTotalsDivider(\_testRunStats.totals);}
\DoxyCodeLine{16584     printTotals(\_testRunStats.totals);}
\DoxyCodeLine{16585     stream << std::endl;}
\DoxyCodeLine{16586     StreamingReporterBase::testRunEnded(\_testRunStats);}
\DoxyCodeLine{16587 \}}
\DoxyCodeLine{16588 \textcolor{keywordtype}{void} ConsoleReporter::testRunStarting(TestRunInfo \textcolor{keyword}{const}\& \_testInfo) \{}
\DoxyCodeLine{16589     StreamingReporterBase::testRunStarting(\_testInfo);}
\DoxyCodeLine{16590     printTestFilters();}
\DoxyCodeLine{16591 \}}
\DoxyCodeLine{16592 }
\DoxyCodeLine{16593 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrint() \{}
\DoxyCodeLine{16594 }
\DoxyCodeLine{16595     m\_tablePrinter-\/>close();}
\DoxyCodeLine{16596     lazyPrintWithoutClosingBenchmarkTable();}
\DoxyCodeLine{16597 \}}
\DoxyCodeLine{16598 }
\DoxyCodeLine{16599 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() \{}
\DoxyCodeLine{16600 }
\DoxyCodeLine{16601     \textcolor{keywordflow}{if} (!currentTestRunInfo.used)}
\DoxyCodeLine{16602         lazyPrintRunInfo();}
\DoxyCodeLine{16603     \textcolor{keywordflow}{if} (!currentGroupInfo.used)}
\DoxyCodeLine{16604         lazyPrintGroupInfo();}
\DoxyCodeLine{16605 }
\DoxyCodeLine{16606     \textcolor{keywordflow}{if} (!m\_headerPrinted) \{}
\DoxyCodeLine{16607         printTestCaseAndSectionHeader();}
\DoxyCodeLine{16608         m\_headerPrinted = \textcolor{keyword}{true};}
\DoxyCodeLine{16609     \}}
\DoxyCodeLine{16610 \}}
\DoxyCodeLine{16611 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintRunInfo() \{}
\DoxyCodeLine{16612     stream << '\(\backslash\)n' << getLineOfChars<'\string~'>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16613     Colour colour(Colour::SecondaryText);}
\DoxyCodeLine{16614     stream << currentTestRunInfo-\/>name}
\DoxyCodeLine{16615         << \textcolor{stringliteral}{"{} is a Catch v"{}} << libraryVersion() << \textcolor{stringliteral}{"{} host application.\(\backslash\)n"{}}}
\DoxyCodeLine{16616         << \textcolor{stringliteral}{"{}Run with -\/? for options\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16617 }
\DoxyCodeLine{16618     \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0)}
\DoxyCodeLine{16619         stream << \textcolor{stringliteral}{"{}Randomness seeded to: "{}} << m\_config-\/>rngSeed() << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{16620 }
\DoxyCodeLine{16621     currentTestRunInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16622 \}}
\DoxyCodeLine{16623 \textcolor{keywordtype}{void} ConsoleReporter::lazyPrintGroupInfo() \{}
\DoxyCodeLine{16624     \textcolor{keywordflow}{if} (!currentGroupInfo-\/>name.empty() \&\& currentGroupInfo-\/>groupsCounts > 1) \{}
\DoxyCodeLine{16625         printClosedHeader(\textcolor{stringliteral}{"{}Group: "{}} + currentGroupInfo-\/>name);}
\DoxyCodeLine{16626         currentGroupInfo.used = \textcolor{keyword}{true};}
\DoxyCodeLine{16627     \}}
\DoxyCodeLine{16628 \}}
\DoxyCodeLine{16629 \textcolor{keywordtype}{void} ConsoleReporter::printTestCaseAndSectionHeader() \{}
\DoxyCodeLine{16630     assert(!m\_sectionStack.empty());}
\DoxyCodeLine{16631     printOpenHeader(currentTestCaseInfo-\/>name);}
\DoxyCodeLine{16632 }
\DoxyCodeLine{16633     \textcolor{keywordflow}{if} (m\_sectionStack.size() > 1) \{}
\DoxyCodeLine{16634         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16635 }
\DoxyCodeLine{16636         \textcolor{keyword}{auto}}
\DoxyCodeLine{16637             it = m\_sectionStack.begin() + 1, \textcolor{comment}{// Skip first section (test case)}}
\DoxyCodeLine{16638             itEnd = m\_sectionStack.end();}
\DoxyCodeLine{16639         \textcolor{keywordflow}{for} (; it != itEnd; ++it)}
\DoxyCodeLine{16640             printHeaderString(it-\/>name, 2);}
\DoxyCodeLine{16641     \}}
\DoxyCodeLine{16642 }
\DoxyCodeLine{16643     SourceLineInfo lineInfo = m\_sectionStack.back().lineInfo;}
\DoxyCodeLine{16644 }
\DoxyCodeLine{16645     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16646     Colour colourGuard(Colour::FileName);}
\DoxyCodeLine{16647     stream << lineInfo << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16648     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'} << std::endl;}
\DoxyCodeLine{16649 \}}
\DoxyCodeLine{16650 }
\DoxyCodeLine{16651 \textcolor{keywordtype}{void} ConsoleReporter::printClosedHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16652     printOpenHeader(\_name);}
\DoxyCodeLine{16653     stream << getLineOfChars<\textcolor{charliteral}{'.'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16654 \}}
\DoxyCodeLine{16655 \textcolor{keywordtype}{void} ConsoleReporter::printOpenHeader(std::string \textcolor{keyword}{const}\& \_name) \{}
\DoxyCodeLine{16656     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16657     \{}
\DoxyCodeLine{16658         Colour colourGuard(Colour::Headers);}
\DoxyCodeLine{16659         printHeaderString(\_name);}
\DoxyCodeLine{16660     \}}
\DoxyCodeLine{16661 \}}
\DoxyCodeLine{16662 }
\DoxyCodeLine{16663 \textcolor{comment}{// if string has a : in first line will set indent to follow it on}}
\DoxyCodeLine{16664 \textcolor{comment}{// subsequent lines}}
\DoxyCodeLine{16665 \textcolor{keywordtype}{void} ConsoleReporter::printHeaderString(std::string \textcolor{keyword}{const}\& \_string, std::size\_t indent) \{}
\DoxyCodeLine{16666     std::size\_t i = \_string.find(\textcolor{stringliteral}{"{}: "{}});}
\DoxyCodeLine{16667     \textcolor{keywordflow}{if} (i != std::string::npos)}
\DoxyCodeLine{16668         i += 2;}
\DoxyCodeLine{16669     \textcolor{keywordflow}{else}}
\DoxyCodeLine{16670         i = 0;}
\DoxyCodeLine{16671     stream << Column(\_string).indent(indent + i).initialIndent(indent) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16672 \}}
\DoxyCodeLine{16673 }
\DoxyCodeLine{16674 \textcolor{keyword}{struct }SummaryColumn \{}
\DoxyCodeLine{16675 }
\DoxyCodeLine{16676     SummaryColumn( std::string \_label, Colour::Code \_colour )}
\DoxyCodeLine{16677     :   label( std::move( \_label ) ),}
\DoxyCodeLine{16678         colour( \_colour ) \{\}}
\DoxyCodeLine{16679     SummaryColumn addRow( std::size\_t count ) \{}
\DoxyCodeLine{16680         ReusableStringStream rss;}
\DoxyCodeLine{16681         rss << count;}
\DoxyCodeLine{16682         std::string row = rss.str();}
\DoxyCodeLine{16683         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& oldRow : rows) \{}
\DoxyCodeLine{16684             \textcolor{keywordflow}{while} (oldRow.size() < row.size())}
\DoxyCodeLine{16685                 oldRow = \textcolor{charliteral}{' '} + oldRow;}
\DoxyCodeLine{16686             \textcolor{keywordflow}{while} (oldRow.size() > row.size())}
\DoxyCodeLine{16687                 row = \textcolor{charliteral}{' '} + row;}
\DoxyCodeLine{16688         \}}
\DoxyCodeLine{16689         rows.push\_back(row);}
\DoxyCodeLine{16690         \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{16691     \}}
\DoxyCodeLine{16692 }
\DoxyCodeLine{16693     std::string label;}
\DoxyCodeLine{16694     Colour::Code colour;}
\DoxyCodeLine{16695     std::vector<std::string> rows;}
\DoxyCodeLine{16696 }
\DoxyCodeLine{16697 \};}
\DoxyCodeLine{16698 }
\DoxyCodeLine{16699 \textcolor{keywordtype}{void} ConsoleReporter::printTotals( Totals \textcolor{keyword}{const}\& totals ) \{}
\DoxyCodeLine{16700     \textcolor{keywordflow}{if} (totals.testCases.total() == 0) \{}
\DoxyCodeLine{16701         stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}No tests ran\(\backslash\)n"{}};}
\DoxyCodeLine{16702     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (totals.assertions.total() > 0 \&\& totals.testCases.allPassed()) \{}
\DoxyCodeLine{16703         stream << Colour(Colour::ResultSuccess) << \textcolor{stringliteral}{"{}All tests passed"{}};}
\DoxyCodeLine{16704         stream << \textcolor{stringliteral}{"{} ("{}}}
\DoxyCodeLine{16705             << pluralise(totals.assertions.passed, \textcolor{stringliteral}{"{}assertion"{}}) << \textcolor{stringliteral}{"{} in "{}}}
\DoxyCodeLine{16706             << pluralise(totals.testCases.passed, \textcolor{stringliteral}{"{}test case"{}}) << \textcolor{charliteral}{')'}}
\DoxyCodeLine{16707             << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16708     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16709 }
\DoxyCodeLine{16710         std::vector<SummaryColumn> columns;}
\DoxyCodeLine{16711         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}"{}}, Colour::None)}
\DoxyCodeLine{16712                           .addRow(totals.testCases.total())}
\DoxyCodeLine{16713                           .addRow(totals.assertions.total()));}
\DoxyCodeLine{16714         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}passed"{}}, Colour::Success)}
\DoxyCodeLine{16715                           .addRow(totals.testCases.passed)}
\DoxyCodeLine{16716                           .addRow(totals.assertions.passed));}
\DoxyCodeLine{16717         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed"{}}, Colour::ResultError)}
\DoxyCodeLine{16718                           .addRow(totals.testCases.failed)}
\DoxyCodeLine{16719                           .addRow(totals.assertions.failed));}
\DoxyCodeLine{16720         columns.push\_back(SummaryColumn(\textcolor{stringliteral}{"{}failed as expected"{}}, Colour::ResultExpectedFailure)}
\DoxyCodeLine{16721                           .addRow(totals.testCases.failedButOk)}
\DoxyCodeLine{16722                           .addRow(totals.assertions.failedButOk));}
\DoxyCodeLine{16723 }
\DoxyCodeLine{16724         printSummaryRow(\textcolor{stringliteral}{"{}test cases"{}}, columns, 0);}
\DoxyCodeLine{16725         printSummaryRow(\textcolor{stringliteral}{"{}assertions"{}}, columns, 1);}
\DoxyCodeLine{16726     \}}
\DoxyCodeLine{16727 \}}
\DoxyCodeLine{16728 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryRow(std::string \textcolor{keyword}{const}\& label, std::vector<SummaryColumn> \textcolor{keyword}{const}\& cols, std::size\_t row) \{}
\DoxyCodeLine{16729     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} col : cols) \{}
\DoxyCodeLine{16730         std::string value = col.rows[row];}
\DoxyCodeLine{16731         \textcolor{keywordflow}{if} (col.label.empty()) \{}
\DoxyCodeLine{16732             stream << label << \textcolor{stringliteral}{"{}: "{}};}
\DoxyCodeLine{16733             \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}})}
\DoxyCodeLine{16734                 stream << value;}
\DoxyCodeLine{16735             \textcolor{keywordflow}{else}}
\DoxyCodeLine{16736                 stream << Colour(Colour::Warning) << \textcolor{stringliteral}{"{}-\/ none -\/"{}};}
\DoxyCodeLine{16737         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (value != \textcolor{stringliteral}{"{}0"{}}) \{}
\DoxyCodeLine{16738             stream << Colour(Colour::LightGrey) << \textcolor{stringliteral}{"{} | "{}};}
\DoxyCodeLine{16739             stream << Colour(col.colour)}
\DoxyCodeLine{16740                 << value << \textcolor{charliteral}{' '} << col.label;}
\DoxyCodeLine{16741         \}}
\DoxyCodeLine{16742     \}}
\DoxyCodeLine{16743     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16744 \}}
\DoxyCodeLine{16745 }
\DoxyCodeLine{16746 \textcolor{keywordtype}{void} ConsoleReporter::printTotalsDivider(Totals \textcolor{keyword}{const}\& totals) \{}
\DoxyCodeLine{16747     \textcolor{keywordflow}{if} (totals.testCases.total() > 0) \{}
\DoxyCodeLine{16748         std::size\_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());}
\DoxyCodeLine{16749         std::size\_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());}
\DoxyCodeLine{16750         std::size\_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());}
\DoxyCodeLine{16751         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio < CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16752             findMax(failedRatio, failedButOkRatio, passedRatio)++;}
\DoxyCodeLine{16753         \textcolor{keywordflow}{while} (failedRatio + failedButOkRatio + passedRatio > CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1)}
\DoxyCodeLine{16754             findMax(failedRatio, failedButOkRatio, passedRatio)-\/-\/;}
\DoxyCodeLine{16755 }
\DoxyCodeLine{16756         stream << Colour(Colour::Error) << std::string(failedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16757         stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16758         \textcolor{keywordflow}{if} (totals.testCases.allPassed())}
\DoxyCodeLine{16759             stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16760         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16761             stream << Colour(Colour::Success) << std::string(passedRatio, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16762     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16763         stream << Colour(Colour::Warning) << std::string(CATCH\_CONFIG\_CONSOLE\_WIDTH -\/ 1, \textcolor{charliteral}{'='});}
\DoxyCodeLine{16764     \}}
\DoxyCodeLine{16765     stream << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16766 \}}
\DoxyCodeLine{16767 \textcolor{keywordtype}{void} ConsoleReporter::printSummaryDivider() \{}
\DoxyCodeLine{16768     stream << getLineOfChars<\textcolor{charliteral}{'-\/'}>() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16769 \}}
\DoxyCodeLine{16770 }
\DoxyCodeLine{16771 \textcolor{keywordtype}{void} ConsoleReporter::printTestFilters() \{}
\DoxyCodeLine{16772     \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters()) \{}
\DoxyCodeLine{16773         Colour guard(Colour::BrightYellow);}
\DoxyCodeLine{16774         stream << \textcolor{stringliteral}{"{}Filters: "{}} << serializeFilters(m\_config-\/>getTestsOrTags()) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{16775     \}}
\DoxyCodeLine{16776 \}}
\DoxyCodeLine{16777 }
\DoxyCodeLine{16778 CATCH\_REGISTER\_REPORTER(\textcolor{stringliteral}{"{}console"{}}, ConsoleReporter)}
\DoxyCodeLine{16779 }
\DoxyCodeLine{16780 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{16781 }
\DoxyCodeLine{16782 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{16783 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{16784 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16785 }
\DoxyCodeLine{16786 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_)}}
\DoxyCodeLine{16787 \textcolor{preprocessor}{\#  pragma clang diagnostic pop}}
\DoxyCodeLine{16788 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16789 \textcolor{comment}{// end catch\_reporter\_console.cpp}}
\DoxyCodeLine{16790 \textcolor{comment}{// start catch\_reporter\_junit.cpp}}
\DoxyCodeLine{16791 }
\DoxyCodeLine{16792 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{16793 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{16794 \textcolor{preprocessor}{\#include <ctime>}}
\DoxyCodeLine{16795 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{16796 \textcolor{preprocessor}{\#include <iomanip>}}
\DoxyCodeLine{16797 }
\DoxyCodeLine{16798 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{16799 }
\DoxyCodeLine{16800     \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{16801         std::string getCurrentTimestamp() \{}
\DoxyCodeLine{16802             \textcolor{comment}{// Beware, this is not reentrant because of backward compatibility issues}}
\DoxyCodeLine{16803             \textcolor{comment}{// Also, UTC only, again because of backward compatibility (\%z is C++11)}}
\DoxyCodeLine{16804             time\_t rawtime;}
\DoxyCodeLine{16805             std::time(\&rawtime);}
\DoxyCodeLine{16806             \textcolor{keyword}{auto} \textcolor{keyword}{const} timeStampSize = \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"{}2017-\/01-\/16T17:06:45Z"{}});}
\DoxyCodeLine{16807 }
\DoxyCodeLine{16808 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16809             std::tm timeInfo = \{\};}
\DoxyCodeLine{16810             gmtime\_s(\&timeInfo, \&rawtime);}
\DoxyCodeLine{16811 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16812             std::tm* timeInfo;}
\DoxyCodeLine{16813             timeInfo = std::gmtime(\&rawtime);}
\DoxyCodeLine{16814 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16815 }
\DoxyCodeLine{16816             \textcolor{keywordtype}{char} timeStamp[timeStampSize];}
\DoxyCodeLine{16817             \textcolor{keyword}{const} \textcolor{keywordtype}{char} * \textcolor{keyword}{const} fmt = \textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%dT\%H:\%M:\%SZ"{}};}
\DoxyCodeLine{16818 }
\DoxyCodeLine{16819 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{16820             std::strftime(timeStamp, timeStampSize, fmt, \&timeInfo);}
\DoxyCodeLine{16821 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{16822             std::strftime(timeStamp, timeStampSize, fmt, timeInfo);}
\DoxyCodeLine{16823 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{16824             \textcolor{keywordflow}{return} std::string(timeStamp, timeStampSize-\/1);}
\DoxyCodeLine{16825         \}}
\DoxyCodeLine{16826 }
\DoxyCodeLine{16827         std::string fileNameTag(\textcolor{keyword}{const} std::vector<std::string> \&tags) \{}
\DoxyCodeLine{16828             \textcolor{keyword}{auto} it = std::find\_if(begin(tags),}
\DoxyCodeLine{16829                                    end(tags),}
\DoxyCodeLine{16830                                    [] (std::string \textcolor{keyword}{const}\& tag) \{\textcolor{keywordflow}{return} tag.front() == \textcolor{charliteral}{'\#'}; \});}
\DoxyCodeLine{16831             \textcolor{keywordflow}{if} (it != tags.end())}
\DoxyCodeLine{16832                 \textcolor{keywordflow}{return} it-\/>substr(1);}
\DoxyCodeLine{16833             \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{16834         \}}
\DoxyCodeLine{16835 }
\DoxyCodeLine{16836         \textcolor{comment}{// Formats the duration in seconds to 3 decimal places.}}
\DoxyCodeLine{16837         \textcolor{comment}{// This is done because some genius defined Maven Surefire schema}}
\DoxyCodeLine{16838         \textcolor{comment}{// in a way that only accepts 3 decimal places, and tools like}}
\DoxyCodeLine{16839         \textcolor{comment}{// Jenkins use that schema for validation JUnit reporter output.}}
\DoxyCodeLine{16840         std::string formatDuration( \textcolor{keywordtype}{double} seconds ) \{}
\DoxyCodeLine{16841             ReusableStringStream rss;}
\DoxyCodeLine{16842             rss << std::fixed << std::setprecision( 3 ) << seconds;}
\DoxyCodeLine{16843             \textcolor{keywordflow}{return} rss.str();}
\DoxyCodeLine{16844         \}}
\DoxyCodeLine{16845 }
\DoxyCodeLine{16846     \} \textcolor{comment}{// anonymous namespace}}
\DoxyCodeLine{16847 }
\DoxyCodeLine{16848     JunitReporter::JunitReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{16849         :   CumulativeReporterBase( \_config ),}
\DoxyCodeLine{16850             xml( \_config.stream() )}
\DoxyCodeLine{16851         \{}
\DoxyCodeLine{16852             m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{16853             m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{16854         \}}
\DoxyCodeLine{16855 }
\DoxyCodeLine{16856     JunitReporter::\string~JunitReporter() \{\}}
\DoxyCodeLine{16857 }
\DoxyCodeLine{16858     std::string JunitReporter::getDescription() \{}
\DoxyCodeLine{16859         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results in an XML format that looks like Ant's junitreport target"{}};}
\DoxyCodeLine{16860     \}}
\DoxyCodeLine{16861 }
\DoxyCodeLine{16862     \textcolor{keywordtype}{void} JunitReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& \textcolor{comment}{/*spec*/} ) \{\}}
\DoxyCodeLine{16863 }
\DoxyCodeLine{16864     \textcolor{keywordtype}{void} JunitReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& runInfo )  \{}
\DoxyCodeLine{16865         CumulativeReporterBase::testRunStarting( runInfo );}
\DoxyCodeLine{16866         xml.startElement( \textcolor{stringliteral}{"{}testsuites"{}} );}
\DoxyCodeLine{16867     \}}
\DoxyCodeLine{16868 }
\DoxyCodeLine{16869     \textcolor{keywordtype}{void} JunitReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{16870         suiteTimer.start();}
\DoxyCodeLine{16871         stdOutForSuite.clear();}
\DoxyCodeLine{16872         stdErrForSuite.clear();}
\DoxyCodeLine{16873         unexpectedExceptions = 0;}
\DoxyCodeLine{16874         CumulativeReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{16875     \}}
\DoxyCodeLine{16876 }
\DoxyCodeLine{16877     \textcolor{keywordtype}{void} JunitReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testCaseInfo ) \{}
\DoxyCodeLine{16878         m\_okToFail = testCaseInfo.okToFail();}
\DoxyCodeLine{16879     \}}
\DoxyCodeLine{16880 }
\DoxyCodeLine{16881     \textcolor{keywordtype}{bool} JunitReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{16882         \textcolor{keywordflow}{if}( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException \&\& !m\_okToFail )}
\DoxyCodeLine{16883             unexpectedExceptions++;}
\DoxyCodeLine{16884         \textcolor{keywordflow}{return} CumulativeReporterBase::assertionEnded( assertionStats );}
\DoxyCodeLine{16885     \}}
\DoxyCodeLine{16886 }
\DoxyCodeLine{16887     \textcolor{keywordtype}{void} JunitReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{16888         stdOutForSuite += testCaseStats.stdOut;}
\DoxyCodeLine{16889         stdErrForSuite += testCaseStats.stdErr;}
\DoxyCodeLine{16890         CumulativeReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{16891     \}}
\DoxyCodeLine{16892 }
\DoxyCodeLine{16893     \textcolor{keywordtype}{void} JunitReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{16894         \textcolor{keywordtype}{double} suiteTime = suiteTimer.getElapsedSeconds();}
\DoxyCodeLine{16895         CumulativeReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{16896         writeGroup( *m\_testGroups.back(), suiteTime );}
\DoxyCodeLine{16897     \}}
\DoxyCodeLine{16898 }
\DoxyCodeLine{16899     \textcolor{keywordtype}{void} JunitReporter::testRunEndedCumulative() \{}
\DoxyCodeLine{16900         xml.endElement();}
\DoxyCodeLine{16901     \}}
\DoxyCodeLine{16902 }
\DoxyCodeLine{16903     \textcolor{keywordtype}{void} JunitReporter::writeGroup( TestGroupNode \textcolor{keyword}{const}\& groupNode, \textcolor{keywordtype}{double} suiteTime ) \{}
\DoxyCodeLine{16904         XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testsuite"{}} );}
\DoxyCodeLine{16905 }
\DoxyCodeLine{16906         TestGroupStats \textcolor{keyword}{const}\& stats = groupNode.value;}
\DoxyCodeLine{16907         xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, stats.groupInfo.name );}
\DoxyCodeLine{16908         xml.writeAttribute( \textcolor{stringliteral}{"{}errors"{}}, unexpectedExceptions );}
\DoxyCodeLine{16909         xml.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, stats.totals.assertions.failed-\/unexpectedExceptions );}
\DoxyCodeLine{16910         xml.writeAttribute( \textcolor{stringliteral}{"{}tests"{}}, stats.totals.assertions.total() );}
\DoxyCodeLine{16911         xml.writeAttribute( \textcolor{stringliteral}{"{}hostname"{}}, \textcolor{stringliteral}{"{}tbd"{}} ); \textcolor{comment}{// !TBD}}
\DoxyCodeLine{16912         \textcolor{keywordflow}{if}( m\_config-\/>showDurations() == ShowDurations::Never )}
\DoxyCodeLine{16913             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, \textcolor{stringliteral}{"{}"{}} );}
\DoxyCodeLine{16914         \textcolor{keywordflow}{else}}
\DoxyCodeLine{16915             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, formatDuration( suiteTime ) );}
\DoxyCodeLine{16916         xml.writeAttribute( \textcolor{stringliteral}{"{}timestamp"{}}, getCurrentTimestamp() );}
\DoxyCodeLine{16917 }
\DoxyCodeLine{16918         \textcolor{comment}{// Write properties if there are any}}
\DoxyCodeLine{16919         \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters() || m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16920             \textcolor{keyword}{auto} properties = xml.scopedElement(\textcolor{stringliteral}{"{}properties"{}});}
\DoxyCodeLine{16921             \textcolor{keywordflow}{if} (m\_config-\/>hasTestFilters()) \{}
\DoxyCodeLine{16922                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16923                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}filters"{}})}
\DoxyCodeLine{16924                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, serializeFilters(m\_config-\/>getTestsOrTags()));}
\DoxyCodeLine{16925             \}}
\DoxyCodeLine{16926             \textcolor{keywordflow}{if} (m\_config-\/>rngSeed() != 0) \{}
\DoxyCodeLine{16927                 xml.scopedElement(\textcolor{stringliteral}{"{}property"{}})}
\DoxyCodeLine{16928                     .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}random-\/seed"{}})}
\DoxyCodeLine{16929                     .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, m\_config-\/>rngSeed());}
\DoxyCodeLine{16930             \}}
\DoxyCodeLine{16931         \}}
\DoxyCodeLine{16932 }
\DoxyCodeLine{16933         \textcolor{comment}{// Write test cases}}
\DoxyCodeLine{16934         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& child : groupNode.children )}
\DoxyCodeLine{16935             writeTestCase( *child );}
\DoxyCodeLine{16936 }
\DoxyCodeLine{16937         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16938         xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );}
\DoxyCodeLine{16939     \}}
\DoxyCodeLine{16940 }
\DoxyCodeLine{16941     \textcolor{keywordtype}{void} JunitReporter::writeTestCase( TestCaseNode \textcolor{keyword}{const}\& testCaseNode ) \{}
\DoxyCodeLine{16942         TestCaseStats \textcolor{keyword}{const}\& stats = testCaseNode.value;}
\DoxyCodeLine{16943 }
\DoxyCodeLine{16944         \textcolor{comment}{// All test cases have exactly one section -\/ which represents the}}
\DoxyCodeLine{16945         \textcolor{comment}{// test case itself. That section may have 0-\/n nested sections}}
\DoxyCodeLine{16946         assert( testCaseNode.children.size() == 1 );}
\DoxyCodeLine{16947         SectionNode \textcolor{keyword}{const}\& rootSection = *testCaseNode.children.front();}
\DoxyCodeLine{16948 }
\DoxyCodeLine{16949         std::string className = stats.testInfo.className;}
\DoxyCodeLine{16950 }
\DoxyCodeLine{16951         \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16952             className = fileNameTag(stats.testInfo.tags);}
\DoxyCodeLine{16953             \textcolor{keywordflow}{if} ( className.empty() )}
\DoxyCodeLine{16954                 className = \textcolor{stringliteral}{"{}global"{}};}
\DoxyCodeLine{16955         \}}
\DoxyCodeLine{16956 }
\DoxyCodeLine{16957         \textcolor{keywordflow}{if} ( !m\_config-\/>name().empty() )}
\DoxyCodeLine{16958             className = m\_config-\/>name() + "{}."{} + className;}
\DoxyCodeLine{16959 }
\DoxyCodeLine{16960         writeSection( className, \textcolor{stringliteral}{"{}"{}}, rootSection, stats.testInfo.okToFail() );}
\DoxyCodeLine{16961     \}}
\DoxyCodeLine{16962 }
\DoxyCodeLine{16963     \textcolor{keywordtype}{void} JunitReporter::writeSection( std::string \textcolor{keyword}{const}\& className,}
\DoxyCodeLine{16964                                       std::string \textcolor{keyword}{const}\& rootName,}
\DoxyCodeLine{16965                                       SectionNode \textcolor{keyword}{const}\& sectionNode,}
\DoxyCodeLine{16966                                       \textcolor{keywordtype}{bool} testOkToFail) \{}
\DoxyCodeLine{16967         std::string name = trim( sectionNode.stats.sectionInfo.name );}
\DoxyCodeLine{16968         \textcolor{keywordflow}{if}( !rootName.empty() )}
\DoxyCodeLine{16969             name = rootName + '/' + name;}
\DoxyCodeLine{16970 }
\DoxyCodeLine{16971         \textcolor{keywordflow}{if}( !sectionNode.assertions.empty() ||}
\DoxyCodeLine{16972             !sectionNode.stdOut.empty() ||}
\DoxyCodeLine{16973             !sectionNode.stdErr.empty() ) \{}
\DoxyCodeLine{16974             XmlWriter::ScopedElement e = xml.scopedElement( \textcolor{stringliteral}{"{}testcase"{}} );}
\DoxyCodeLine{16975             \textcolor{keywordflow}{if}( className.empty() ) \{}
\DoxyCodeLine{16976                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, name );}
\DoxyCodeLine{16977                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, \textcolor{stringliteral}{"{}root"{}} );}
\DoxyCodeLine{16978             \}}
\DoxyCodeLine{16979             \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{16980                 xml.writeAttribute( \textcolor{stringliteral}{"{}classname"{}}, className );}
\DoxyCodeLine{16981                 xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, name );}
\DoxyCodeLine{16982             \}}
\DoxyCodeLine{16983             xml.writeAttribute( \textcolor{stringliteral}{"{}time"{}}, formatDuration( sectionNode.stats.durationInSeconds ) );}
\DoxyCodeLine{16984             \textcolor{comment}{// This is not ideal, but it should be enough to mimic gtest's}}
\DoxyCodeLine{16985             \textcolor{comment}{// junit output.}}
\DoxyCodeLine{16986             \textcolor{comment}{// Ideally the JUnit reporter would also handle `skipTest`}}
\DoxyCodeLine{16987             \textcolor{comment}{// events and write those out appropriately.}}
\DoxyCodeLine{16988             xml.writeAttribute( \textcolor{stringliteral}{"{}status"{}}, \textcolor{stringliteral}{"{}run"{}} );}
\DoxyCodeLine{16989 }
\DoxyCodeLine{16990             \textcolor{keywordflow}{if} (sectionNode.stats.assertions.failedButOk) \{}
\DoxyCodeLine{16991                 xml.scopedElement(\textcolor{stringliteral}{"{}skipped"{}})}
\DoxyCodeLine{16992                     .writeAttribute(\textcolor{stringliteral}{"{}message"{}}, \textcolor{stringliteral}{"{}TEST\_CASE tagged with !mayfail"{}});}
\DoxyCodeLine{16993             \}}
\DoxyCodeLine{16994 }
\DoxyCodeLine{16995             writeAssertions( sectionNode );}
\DoxyCodeLine{16996 }
\DoxyCodeLine{16997             \textcolor{keywordflow}{if}( !sectionNode.stdOut.empty() )}
\DoxyCodeLine{16998                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/out"{}} ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{16999             \textcolor{keywordflow}{if}( !sectionNode.stdErr.empty() )}
\DoxyCodeLine{17000                 xml.scopedElement( \textcolor{stringliteral}{"{}system-\/err"{}} ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{17001         \}}
\DoxyCodeLine{17002         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& childNode : sectionNode.childSections )}
\DoxyCodeLine{17003             \textcolor{keywordflow}{if}( className.empty() )}
\DoxyCodeLine{17004                 writeSection( name, \textcolor{stringliteral}{"{}"{}}, *childNode, testOkToFail );}
\DoxyCodeLine{17005             \textcolor{keywordflow}{else}}
\DoxyCodeLine{17006                 writeSection( className, name, *childNode, testOkToFail );}
\DoxyCodeLine{17007     \}}
\DoxyCodeLine{17008 }
\DoxyCodeLine{17009     \textcolor{keywordtype}{void} JunitReporter::writeAssertions( SectionNode \textcolor{keyword}{const}\& sectionNode ) \{}
\DoxyCodeLine{17010         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& assertion : sectionNode.assertions )}
\DoxyCodeLine{17011             writeAssertion( assertion );}
\DoxyCodeLine{17012     \}}
\DoxyCodeLine{17013 }
\DoxyCodeLine{17014     \textcolor{keywordtype}{void} JunitReporter::writeAssertion( AssertionStats \textcolor{keyword}{const}\& stats ) \{}
\DoxyCodeLine{17015         AssertionResult \textcolor{keyword}{const}\& result = stats.assertionResult;}
\DoxyCodeLine{17016         \textcolor{keywordflow}{if}( !result.isOk() ) \{}
\DoxyCodeLine{17017             std::string elementName;}
\DoxyCodeLine{17018             \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{17019                 \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{17020                 \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{17021                     elementName = \textcolor{stringliteral}{"{}error"{}};}
\DoxyCodeLine{17022                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17023                 \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{17024                 \textcolor{keywordflow}{case} ResultWas::ExpressionFailed:}
\DoxyCodeLine{17025                 \textcolor{keywordflow}{case} ResultWas::DidntThrowException:}
\DoxyCodeLine{17026                     elementName = \textcolor{stringliteral}{"{}failure"{}};}
\DoxyCodeLine{17027                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17028 }
\DoxyCodeLine{17029                 \textcolor{comment}{// We should never see these here:}}
\DoxyCodeLine{17030                 \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{17031                 \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{17032                 \textcolor{keywordflow}{case} ResultWas::Ok:}
\DoxyCodeLine{17033                 \textcolor{keywordflow}{case} ResultWas::Unknown:}
\DoxyCodeLine{17034                 \textcolor{keywordflow}{case} ResultWas::FailureBit:}
\DoxyCodeLine{17035                 \textcolor{keywordflow}{case} ResultWas::Exception:}
\DoxyCodeLine{17036                     elementName = \textcolor{stringliteral}{"{}internalError"{}};}
\DoxyCodeLine{17037                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{17038             \}}
\DoxyCodeLine{17039 }
\DoxyCodeLine{17040             XmlWriter::ScopedElement e = xml.scopedElement( elementName );}
\DoxyCodeLine{17041 }
\DoxyCodeLine{17042             xml.writeAttribute( \textcolor{stringliteral}{"{}message"{}}, result.getExpression() );}
\DoxyCodeLine{17043             xml.writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{17044 }
\DoxyCodeLine{17045             ReusableStringStream rss;}
\DoxyCodeLine{17046             \textcolor{keywordflow}{if} (stats.totals.assertions.total() > 0) \{}
\DoxyCodeLine{17047                 rss << \textcolor{stringliteral}{"{}FAILED"{}} << \textcolor{stringliteral}{"{}:\(\backslash\)n"{}};}
\DoxyCodeLine{17048                 \textcolor{keywordflow}{if} (result.hasExpression()) \{}
\DoxyCodeLine{17049                     rss << \textcolor{stringliteral}{"{}  "{}};}
\DoxyCodeLine{17050                     rss << result.getExpressionInMacro();}
\DoxyCodeLine{17051                     rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17052                 \}}
\DoxyCodeLine{17053                 \textcolor{keywordflow}{if} (result.hasExpandedExpression()) \{}
\DoxyCodeLine{17054                     rss << \textcolor{stringliteral}{"{}with expansion:\(\backslash\)n"{}};}
\DoxyCodeLine{17055                     rss << Column(result.getExpandedExpression()).indent(2) << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17056                 \}}
\DoxyCodeLine{17057             \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{17058                 rss << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17059             \}}
\DoxyCodeLine{17060 }
\DoxyCodeLine{17061             \textcolor{keywordflow}{if}( !result.getMessage().empty() )}
\DoxyCodeLine{17062                 rss << result.getMessage() << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17063             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : stats.infoMessages )}
\DoxyCodeLine{17064                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info )}
\DoxyCodeLine{17065                     rss << msg.message << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{17066 }
\DoxyCodeLine{17067             rss << \textcolor{stringliteral}{"{}at "{}} << result.getSourceInfo();}
\DoxyCodeLine{17068             xml.writeText( rss.str(), XmlFormatting::Newline );}
\DoxyCodeLine{17069         \}}
\DoxyCodeLine{17070     \}}
\DoxyCodeLine{17071 }
\DoxyCodeLine{17072     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}junit"{}}, JunitReporter )}
\DoxyCodeLine{17073 }
\DoxyCodeLine{17074 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17075 \textcolor{comment}{// end catch\_reporter\_junit.cpp}}
\DoxyCodeLine{17076 \textcolor{comment}{// start catch\_reporter\_listening.cpp}}
\DoxyCodeLine{17077 }
\DoxyCodeLine{17078 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{17079 }
\DoxyCodeLine{17080 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17081 }
\DoxyCodeLine{17082     ListeningReporter::ListeningReporter() \{}
\DoxyCodeLine{17083         \textcolor{comment}{// We will assume that listeners will always want all assertions}}
\DoxyCodeLine{17084         m\_preferences.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17085     \}}
\DoxyCodeLine{17086 }
\DoxyCodeLine{17087     \textcolor{keywordtype}{void} ListeningReporter::addListener( IStreamingReporterPtr\&\& listener ) \{}
\DoxyCodeLine{17088         m\_listeners.push\_back( std::move( listener ) );}
\DoxyCodeLine{17089     \}}
\DoxyCodeLine{17090 }
\DoxyCodeLine{17091     \textcolor{keywordtype}{void} ListeningReporter::addReporter(IStreamingReporterPtr\&\& reporter) \{}
\DoxyCodeLine{17092         assert(!m\_reporter \&\& \textcolor{stringliteral}{"{}Listening reporter can wrap only 1 real reporter"{}});}
\DoxyCodeLine{17093         m\_reporter = std::move( reporter );}
\DoxyCodeLine{17094         m\_preferences.shouldRedirectStdOut = m\_reporter-\/>getPreferences().shouldRedirectStdOut;}
\DoxyCodeLine{17095     \}}
\DoxyCodeLine{17096 }
\DoxyCodeLine{17097     ReporterPreferences ListeningReporter::getPreferences()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17098         \textcolor{keywordflow}{return} m\_preferences;}
\DoxyCodeLine{17099     \}}
\DoxyCodeLine{17100 }
\DoxyCodeLine{17101     std::set<Verbosity> ListeningReporter::getSupportedVerbosities() \{}
\DoxyCodeLine{17102         \textcolor{keywordflow}{return} std::set<Verbosity>\{ \};}
\DoxyCodeLine{17103     \}}
\DoxyCodeLine{17104 }
\DoxyCodeLine{17105     \textcolor{keywordtype}{void} ListeningReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& spec ) \{}
\DoxyCodeLine{17106         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17107             listener-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17108         \}}
\DoxyCodeLine{17109         m\_reporter-\/>noMatchingTestCases( spec );}
\DoxyCodeLine{17110     \}}
\DoxyCodeLine{17111 }
\DoxyCodeLine{17112     \textcolor{keywordtype}{void} ListeningReporter::reportInvalidArguments(std::string \textcolor{keyword}{const}\&arg)\{}
\DoxyCodeLine{17113         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17114             listener-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17115         \}}
\DoxyCodeLine{17116         m\_reporter-\/>reportInvalidArguments( arg );}
\DoxyCodeLine{17117     \}}
\DoxyCodeLine{17118 }
\DoxyCodeLine{17119 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17120     \textcolor{keywordtype}{void} ListeningReporter::benchmarkPreparing( std::string \textcolor{keyword}{const}\& name ) \{}
\DoxyCodeLine{17121         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17122             listener-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17123         \}}
\DoxyCodeLine{17124         m\_reporter-\/>benchmarkPreparing(name);}
\DoxyCodeLine{17125     \}}
\DoxyCodeLine{17126     \textcolor{keywordtype}{void} ListeningReporter::benchmarkStarting( BenchmarkInfo \textcolor{keyword}{const}\& benchmarkInfo ) \{}
\DoxyCodeLine{17127         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17128             listener-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17129         \}}
\DoxyCodeLine{17130         m\_reporter-\/>benchmarkStarting( benchmarkInfo );}
\DoxyCodeLine{17131     \}}
\DoxyCodeLine{17132     \textcolor{keywordtype}{void} ListeningReporter::benchmarkEnded( BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats ) \{}
\DoxyCodeLine{17133         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17134             listener-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17135         \}}
\DoxyCodeLine{17136         m\_reporter-\/>benchmarkEnded( benchmarkStats );}
\DoxyCodeLine{17137     \}}
\DoxyCodeLine{17138 }
\DoxyCodeLine{17139     \textcolor{keywordtype}{void} ListeningReporter::benchmarkFailed( std::string \textcolor{keyword}{const}\& error ) \{}
\DoxyCodeLine{17140         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners) \{}
\DoxyCodeLine{17141             listener-\/>benchmarkFailed(error);}
\DoxyCodeLine{17142         \}}
\DoxyCodeLine{17143         m\_reporter-\/>benchmarkFailed(error);}
\DoxyCodeLine{17144     \}}
\DoxyCodeLine{17145 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17146 }
\DoxyCodeLine{17147     \textcolor{keywordtype}{void} ListeningReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testRunInfo ) \{}
\DoxyCodeLine{17148         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17149             listener-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17150         \}}
\DoxyCodeLine{17151         m\_reporter-\/>testRunStarting( testRunInfo );}
\DoxyCodeLine{17152     \}}
\DoxyCodeLine{17153 }
\DoxyCodeLine{17154     \textcolor{keywordtype}{void} ListeningReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17155         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17156             listener-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17157         \}}
\DoxyCodeLine{17158         m\_reporter-\/>testGroupStarting( groupInfo );}
\DoxyCodeLine{17159     \}}
\DoxyCodeLine{17160 }
\DoxyCodeLine{17161     \textcolor{keywordtype}{void} ListeningReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17162         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17163             listener-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17164         \}}
\DoxyCodeLine{17165         m\_reporter-\/>testCaseStarting( testInfo );}
\DoxyCodeLine{17166     \}}
\DoxyCodeLine{17167 }
\DoxyCodeLine{17168     \textcolor{keywordtype}{void} ListeningReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17169         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17170             listener-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17171         \}}
\DoxyCodeLine{17172         m\_reporter-\/>sectionStarting( sectionInfo );}
\DoxyCodeLine{17173     \}}
\DoxyCodeLine{17174 }
\DoxyCodeLine{17175     \textcolor{keywordtype}{void} ListeningReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& assertionInfo ) \{}
\DoxyCodeLine{17176         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17177             listener-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17178         \}}
\DoxyCodeLine{17179         m\_reporter-\/>assertionStarting( assertionInfo );}
\DoxyCodeLine{17180     \}}
\DoxyCodeLine{17181 }
\DoxyCodeLine{17182     \textcolor{comment}{// The return value indicates if the messages buffer should be cleared:}}
\DoxyCodeLine{17183     \textcolor{keywordtype}{bool} ListeningReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17184         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17185             \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}\textcolor{keyword}{>}( listener-\/>assertionEnded( assertionStats ) );}
\DoxyCodeLine{17186         \}}
\DoxyCodeLine{17187         \textcolor{keywordflow}{return} m\_reporter-\/>assertionEnded( assertionStats );}
\DoxyCodeLine{17188     \}}
\DoxyCodeLine{17189 }
\DoxyCodeLine{17190     \textcolor{keywordtype}{void} ListeningReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17191         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17192             listener-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17193         \}}
\DoxyCodeLine{17194         m\_reporter-\/>sectionEnded( sectionStats );}
\DoxyCodeLine{17195     \}}
\DoxyCodeLine{17196 }
\DoxyCodeLine{17197     \textcolor{keywordtype}{void} ListeningReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17198         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17199             listener-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17200         \}}
\DoxyCodeLine{17201         m\_reporter-\/>testCaseEnded( testCaseStats );}
\DoxyCodeLine{17202     \}}
\DoxyCodeLine{17203 }
\DoxyCodeLine{17204     \textcolor{keywordtype}{void} ListeningReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17205         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17206             listener-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17207         \}}
\DoxyCodeLine{17208         m\_reporter-\/>testGroupEnded( testGroupStats );}
\DoxyCodeLine{17209     \}}
\DoxyCodeLine{17210 }
\DoxyCodeLine{17211     \textcolor{keywordtype}{void} ListeningReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17212         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17213             listener-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17214         \}}
\DoxyCodeLine{17215         m\_reporter-\/>testRunEnded( testRunStats );}
\DoxyCodeLine{17216     \}}
\DoxyCodeLine{17217 }
\DoxyCodeLine{17218     \textcolor{keywordtype}{void} ListeningReporter::skipTest( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17219         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& listener : m\_listeners ) \{}
\DoxyCodeLine{17220             listener-\/>skipTest( testInfo );}
\DoxyCodeLine{17221         \}}
\DoxyCodeLine{17222         m\_reporter-\/>skipTest( testInfo );}
\DoxyCodeLine{17223     \}}
\DoxyCodeLine{17224 }
\DoxyCodeLine{17225     \textcolor{keywordtype}{bool} ListeningReporter::isMulti()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17226         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17227     \}}
\DoxyCodeLine{17228 }
\DoxyCodeLine{17229 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17230 \textcolor{comment}{// end catch\_reporter\_listening.cpp}}
\DoxyCodeLine{17231 \textcolor{comment}{// start catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17232 }
\DoxyCodeLine{17233 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17234 \textcolor{preprocessor}{\#pragma warning(push)}}
\DoxyCodeLine{17235 \textcolor{preprocessor}{\#pragma warning(disable:4061) }\textcolor{comment}{// Not all labels are EXPLICITLY handled in switch}}
\DoxyCodeLine{17236                               \textcolor{comment}{// Note that 4062 (not all labels are handled}}
\DoxyCodeLine{17237                               \textcolor{comment}{// and default is missing) is enabled}}
\DoxyCodeLine{17238 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17239 }
\DoxyCodeLine{17240 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17241     XmlReporter::XmlReporter( ReporterConfig \textcolor{keyword}{const}\& \_config )}
\DoxyCodeLine{17242     :   StreamingReporterBase( \_config ),}
\DoxyCodeLine{17243         m\_xml(\_config.stream())}
\DoxyCodeLine{17244     \{}
\DoxyCodeLine{17245         m\_reporterPrefs.shouldRedirectStdOut = \textcolor{keyword}{true};}
\DoxyCodeLine{17246         m\_reporterPrefs.shouldReportAllAssertions = \textcolor{keyword}{true};}
\DoxyCodeLine{17247     \}}
\DoxyCodeLine{17248 }
\DoxyCodeLine{17249     XmlReporter::\string~XmlReporter() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{17250 }
\DoxyCodeLine{17251     std::string XmlReporter::getDescription() \{}
\DoxyCodeLine{17252         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Reports test results as an XML document"{}};}
\DoxyCodeLine{17253     \}}
\DoxyCodeLine{17254 }
\DoxyCodeLine{17255     std::string XmlReporter::getStylesheetRef()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{17256         \textcolor{keywordflow}{return} std::string();}
\DoxyCodeLine{17257     \}}
\DoxyCodeLine{17258 }
\DoxyCodeLine{17259     \textcolor{keywordtype}{void} XmlReporter::writeSourceInfo( SourceLineInfo \textcolor{keyword}{const}\& sourceInfo ) \{}
\DoxyCodeLine{17260         m\_xml}
\DoxyCodeLine{17261             .writeAttribute( \textcolor{stringliteral}{"{}filename"{}}, sourceInfo.file )}
\DoxyCodeLine{17262             .writeAttribute( \textcolor{stringliteral}{"{}line"{}}, sourceInfo.line );}
\DoxyCodeLine{17263     \}}
\DoxyCodeLine{17264 }
\DoxyCodeLine{17265     \textcolor{keywordtype}{void} XmlReporter::noMatchingTestCases( std::string \textcolor{keyword}{const}\& s ) \{}
\DoxyCodeLine{17266         StreamingReporterBase::noMatchingTestCases( s );}
\DoxyCodeLine{17267     \}}
\DoxyCodeLine{17268 }
\DoxyCodeLine{17269     \textcolor{keywordtype}{void} XmlReporter::testRunStarting( TestRunInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17270         StreamingReporterBase::testRunStarting( testInfo );}
\DoxyCodeLine{17271         std::string stylesheetRef = getStylesheetRef();}
\DoxyCodeLine{17272         \textcolor{keywordflow}{if}( !stylesheetRef.empty() )}
\DoxyCodeLine{17273             m\_xml.writeStylesheetRef( stylesheetRef );}
\DoxyCodeLine{17274         m\_xml.startElement( \textcolor{stringliteral}{"{}Catch"{}} );}
\DoxyCodeLine{17275         \textcolor{keywordflow}{if}( !m\_config-\/>name().empty() )}
\DoxyCodeLine{17276             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}name"{}}, m\_config-\/>name() );}
\DoxyCodeLine{17277         \textcolor{keywordflow}{if} (m\_config-\/>testSpec().hasFilters())}
\DoxyCodeLine{17278             m\_xml.writeAttribute( \textcolor{stringliteral}{"{}filters"{}}, serializeFilters( m\_config-\/>getTestsOrTags() ) );}
\DoxyCodeLine{17279         \textcolor{keywordflow}{if}( m\_config-\/>rngSeed() != 0 )}
\DoxyCodeLine{17280             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Randomness"{}} )}
\DoxyCodeLine{17281                 .writeAttribute( \textcolor{stringliteral}{"{}seed"{}}, m\_config-\/>rngSeed() );}
\DoxyCodeLine{17282     \}}
\DoxyCodeLine{17283 }
\DoxyCodeLine{17284     \textcolor{keywordtype}{void} XmlReporter::testGroupStarting( GroupInfo \textcolor{keyword}{const}\& groupInfo ) \{}
\DoxyCodeLine{17285         StreamingReporterBase::testGroupStarting( groupInfo );}
\DoxyCodeLine{17286         m\_xml.startElement( \textcolor{stringliteral}{"{}Group"{}} )}
\DoxyCodeLine{17287             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, groupInfo.name );}
\DoxyCodeLine{17288     \}}
\DoxyCodeLine{17289 }
\DoxyCodeLine{17290     \textcolor{keywordtype}{void} XmlReporter::testCaseStarting( TestCaseInfo \textcolor{keyword}{const}\& testInfo ) \{}
\DoxyCodeLine{17291         StreamingReporterBase::testCaseStarting(testInfo);}
\DoxyCodeLine{17292         m\_xml.startElement( \textcolor{stringliteral}{"{}TestCase"{}} )}
\DoxyCodeLine{17293             .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( testInfo.name ) )}
\DoxyCodeLine{17294             .writeAttribute( \textcolor{stringliteral}{"{}description"{}}, testInfo.description )}
\DoxyCodeLine{17295             .writeAttribute( \textcolor{stringliteral}{"{}tags"{}}, testInfo.tagsAsString() );}
\DoxyCodeLine{17296 }
\DoxyCodeLine{17297         writeSourceInfo( testInfo.lineInfo );}
\DoxyCodeLine{17298 }
\DoxyCodeLine{17299         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17300             m\_testCaseTimer.start();}
\DoxyCodeLine{17301         m\_xml.ensureTagClosed();}
\DoxyCodeLine{17302     \}}
\DoxyCodeLine{17303 }
\DoxyCodeLine{17304     \textcolor{keywordtype}{void} XmlReporter::sectionStarting( SectionInfo \textcolor{keyword}{const}\& sectionInfo ) \{}
\DoxyCodeLine{17305         StreamingReporterBase::sectionStarting( sectionInfo );}
\DoxyCodeLine{17306         \textcolor{keywordflow}{if}( m\_sectionDepth++ > 0 ) \{}
\DoxyCodeLine{17307             m\_xml.startElement( \textcolor{stringliteral}{"{}Section"{}} )}
\DoxyCodeLine{17308                 .writeAttribute( \textcolor{stringliteral}{"{}name"{}}, trim( sectionInfo.name ) );}
\DoxyCodeLine{17309             writeSourceInfo( sectionInfo.lineInfo );}
\DoxyCodeLine{17310             m\_xml.ensureTagClosed();}
\DoxyCodeLine{17311         \}}
\DoxyCodeLine{17312     \}}
\DoxyCodeLine{17313 }
\DoxyCodeLine{17314     \textcolor{keywordtype}{void} XmlReporter::assertionStarting( AssertionInfo \textcolor{keyword}{const}\& ) \{ \}}
\DoxyCodeLine{17315 }
\DoxyCodeLine{17316     \textcolor{keywordtype}{bool} XmlReporter::assertionEnded( AssertionStats \textcolor{keyword}{const}\& assertionStats ) \{}
\DoxyCodeLine{17317 }
\DoxyCodeLine{17318         AssertionResult \textcolor{keyword}{const}\& result = assertionStats.assertionResult;}
\DoxyCodeLine{17319 }
\DoxyCodeLine{17320         \textcolor{keywordtype}{bool} includeResults = m\_config-\/>includeSuccessfulResults() || !result.isOk();}
\DoxyCodeLine{17321 }
\DoxyCodeLine{17322         \textcolor{keywordflow}{if}( includeResults || result.getResultType() == ResultWas::Warning ) \{}
\DoxyCodeLine{17323             \textcolor{comment}{// Print any info messages in <Info> tags.}}
\DoxyCodeLine{17324             \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \textcolor{keyword}{const}\& msg : assertionStats.infoMessages ) \{}
\DoxyCodeLine{17325                 \textcolor{keywordflow}{if}( msg.type == ResultWas::Info \&\& includeResults ) \{}
\DoxyCodeLine{17326                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17327                             .writeText( msg.message );}
\DoxyCodeLine{17328                 \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( msg.type == ResultWas::Warning ) \{}
\DoxyCodeLine{17329                     m\_xml.scopedElement( \textcolor{stringliteral}{"{}Warning"{}} )}
\DoxyCodeLine{17330                             .writeText( msg.message );}
\DoxyCodeLine{17331                 \}}
\DoxyCodeLine{17332             \}}
\DoxyCodeLine{17333         \}}
\DoxyCodeLine{17334 }
\DoxyCodeLine{17335         \textcolor{comment}{// Drop out if result was successful but we're not printing them.}}
\DoxyCodeLine{17336         \textcolor{keywordflow}{if}( !includeResults \&\& result.getResultType() != ResultWas::Warning )}
\DoxyCodeLine{17337             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17338 }
\DoxyCodeLine{17339         \textcolor{comment}{// Print the expression if there is one.}}
\DoxyCodeLine{17340         \textcolor{keywordflow}{if}( result.hasExpression() ) \{}
\DoxyCodeLine{17341             m\_xml.startElement( \textcolor{stringliteral}{"{}Expression"{}} )}
\DoxyCodeLine{17342                 .writeAttribute( \textcolor{stringliteral}{"{}success"{}}, result.succeeded() )}
\DoxyCodeLine{17343                 .writeAttribute( \textcolor{stringliteral}{"{}type"{}}, result.getTestMacroName() );}
\DoxyCodeLine{17344 }
\DoxyCodeLine{17345             writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17346 }
\DoxyCodeLine{17347             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Original"{}} )}
\DoxyCodeLine{17348                 .writeText( result.getExpression() );}
\DoxyCodeLine{17349             m\_xml.scopedElement( \textcolor{stringliteral}{"{}Expanded"{}} )}
\DoxyCodeLine{17350                 .writeText( result.getExpandedExpression() );}
\DoxyCodeLine{17351         \}}
\DoxyCodeLine{17352 }
\DoxyCodeLine{17353         \textcolor{comment}{// And... Print a result applicable to each result type.}}
\DoxyCodeLine{17354         \textcolor{keywordflow}{switch}( result.getResultType() ) \{}
\DoxyCodeLine{17355             \textcolor{keywordflow}{case} ResultWas::ThrewException:}
\DoxyCodeLine{17356                 m\_xml.startElement( \textcolor{stringliteral}{"{}Exception"{}} );}
\DoxyCodeLine{17357                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17358                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17359                 m\_xml.endElement();}
\DoxyCodeLine{17360                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17361             \textcolor{keywordflow}{case} ResultWas::FatalErrorCondition:}
\DoxyCodeLine{17362                 m\_xml.startElement( \textcolor{stringliteral}{"{}FatalErrorCondition"{}} );}
\DoxyCodeLine{17363                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17364                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17365                 m\_xml.endElement();}
\DoxyCodeLine{17366                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17367             \textcolor{keywordflow}{case} ResultWas::Info:}
\DoxyCodeLine{17368                 m\_xml.scopedElement( \textcolor{stringliteral}{"{}Info"{}} )}
\DoxyCodeLine{17369                     .writeText( result.getMessage() );}
\DoxyCodeLine{17370                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17371             \textcolor{keywordflow}{case} ResultWas::Warning:}
\DoxyCodeLine{17372                 \textcolor{comment}{// Warning will already have been written}}
\DoxyCodeLine{17373                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17374             \textcolor{keywordflow}{case} ResultWas::ExplicitFailure:}
\DoxyCodeLine{17375                 m\_xml.startElement( \textcolor{stringliteral}{"{}Failure"{}} );}
\DoxyCodeLine{17376                 writeSourceInfo( result.getSourceInfo() );}
\DoxyCodeLine{17377                 m\_xml.writeText( result.getMessage() );}
\DoxyCodeLine{17378                 m\_xml.endElement();}
\DoxyCodeLine{17379                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17380             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{17381                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{17382         \}}
\DoxyCodeLine{17383 }
\DoxyCodeLine{17384         \textcolor{keywordflow}{if}( result.hasExpression() )}
\DoxyCodeLine{17385             m\_xml.endElement();}
\DoxyCodeLine{17386 }
\DoxyCodeLine{17387         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{17388     \}}
\DoxyCodeLine{17389 }
\DoxyCodeLine{17390     \textcolor{keywordtype}{void} XmlReporter::sectionEnded( SectionStats \textcolor{keyword}{const}\& sectionStats ) \{}
\DoxyCodeLine{17391         StreamingReporterBase::sectionEnded( sectionStats );}
\DoxyCodeLine{17392         \textcolor{keywordflow}{if}( -\/-\/m\_sectionDepth > 0 ) \{}
\DoxyCodeLine{17393             XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} );}
\DoxyCodeLine{17394             e.writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, sectionStats.assertions.passed );}
\DoxyCodeLine{17395             e.writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, sectionStats.assertions.failed );}
\DoxyCodeLine{17396             e.writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, sectionStats.assertions.failedButOk );}
\DoxyCodeLine{17397 }
\DoxyCodeLine{17398             \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17399                 e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, sectionStats.durationInSeconds );}
\DoxyCodeLine{17400 }
\DoxyCodeLine{17401             m\_xml.endElement();}
\DoxyCodeLine{17402         \}}
\DoxyCodeLine{17403     \}}
\DoxyCodeLine{17404 }
\DoxyCodeLine{17405     \textcolor{keywordtype}{void} XmlReporter::testCaseEnded( TestCaseStats \textcolor{keyword}{const}\& testCaseStats ) \{}
\DoxyCodeLine{17406         StreamingReporterBase::testCaseEnded( testCaseStats );}
\DoxyCodeLine{17407         XmlWriter::ScopedElement e = m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResult"{}} );}
\DoxyCodeLine{17408         e.writeAttribute( \textcolor{stringliteral}{"{}success"{}}, testCaseStats.totals.assertions.allOk() );}
\DoxyCodeLine{17409 }
\DoxyCodeLine{17410         \textcolor{keywordflow}{if} ( m\_config-\/>showDurations() == ShowDurations::Always )}
\DoxyCodeLine{17411             e.writeAttribute( \textcolor{stringliteral}{"{}durationInSeconds"{}}, m\_testCaseTimer.getElapsedSeconds() );}
\DoxyCodeLine{17412 }
\DoxyCodeLine{17413         \textcolor{keywordflow}{if}( !testCaseStats.stdOut.empty() )}
\DoxyCodeLine{17414             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdOut"{}} ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );}
\DoxyCodeLine{17415         \textcolor{keywordflow}{if}( !testCaseStats.stdErr.empty() )}
\DoxyCodeLine{17416             m\_xml.scopedElement( \textcolor{stringliteral}{"{}StdErr"{}} ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );}
\DoxyCodeLine{17417 }
\DoxyCodeLine{17418         m\_xml.endElement();}
\DoxyCodeLine{17419     \}}
\DoxyCodeLine{17420 }
\DoxyCodeLine{17421     \textcolor{keywordtype}{void} XmlReporter::testGroupEnded( TestGroupStats \textcolor{keyword}{const}\& testGroupStats ) \{}
\DoxyCodeLine{17422         StreamingReporterBase::testGroupEnded( testGroupStats );}
\DoxyCodeLine{17423         \textcolor{comment}{// TODO: Check testGroupStats.aborting and act accordingly.}}
\DoxyCodeLine{17424         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17425             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.assertions.passed )}
\DoxyCodeLine{17426             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.assertions.failed )}
\DoxyCodeLine{17427             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17428         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17429             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testGroupStats.totals.testCases.passed )}
\DoxyCodeLine{17430             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testGroupStats.totals.testCases.failed )}
\DoxyCodeLine{17431             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testGroupStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17432         m\_xml.endElement();}
\DoxyCodeLine{17433     \}}
\DoxyCodeLine{17434 }
\DoxyCodeLine{17435     \textcolor{keywordtype}{void} XmlReporter::testRunEnded( TestRunStats \textcolor{keyword}{const}\& testRunStats ) \{}
\DoxyCodeLine{17436         StreamingReporterBase::testRunEnded( testRunStats );}
\DoxyCodeLine{17437         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResults"{}} )}
\DoxyCodeLine{17438             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.assertions.passed )}
\DoxyCodeLine{17439             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.assertions.failed )}
\DoxyCodeLine{17440             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.assertions.failedButOk );}
\DoxyCodeLine{17441         m\_xml.scopedElement( \textcolor{stringliteral}{"{}OverallResultsCases"{}})}
\DoxyCodeLine{17442             .writeAttribute( \textcolor{stringliteral}{"{}successes"{}}, testRunStats.totals.testCases.passed )}
\DoxyCodeLine{17443             .writeAttribute( \textcolor{stringliteral}{"{}failures"{}}, testRunStats.totals.testCases.failed )}
\DoxyCodeLine{17444             .writeAttribute( \textcolor{stringliteral}{"{}expectedFailures"{}}, testRunStats.totals.testCases.failedButOk );}
\DoxyCodeLine{17445         m\_xml.endElement();}
\DoxyCodeLine{17446     \}}
\DoxyCodeLine{17447 }
\DoxyCodeLine{17448 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17449     \textcolor{keywordtype}{void} XmlReporter::benchmarkPreparing(std::string \textcolor{keyword}{const}\& name) \{}
\DoxyCodeLine{17450         m\_xml.startElement(\textcolor{stringliteral}{"{}BenchmarkResults"{}})}
\DoxyCodeLine{17451             .writeAttribute(\textcolor{stringliteral}{"{}name"{}}, name);}
\DoxyCodeLine{17452     \}}
\DoxyCodeLine{17453 }
\DoxyCodeLine{17454     \textcolor{keywordtype}{void} XmlReporter::benchmarkStarting(BenchmarkInfo \textcolor{keyword}{const} \&info) \{}
\DoxyCodeLine{17455         m\_xml.writeAttribute(\textcolor{stringliteral}{"{}samples"{}}, info.samples)}
\DoxyCodeLine{17456             .writeAttribute(\textcolor{stringliteral}{"{}resamples"{}}, info.resamples)}
\DoxyCodeLine{17457             .writeAttribute(\textcolor{stringliteral}{"{}iterations"{}}, info.iterations)}
\DoxyCodeLine{17458             .writeAttribute(\textcolor{stringliteral}{"{}clockResolution"{}}, info.clockResolution)}
\DoxyCodeLine{17459             .writeAttribute(\textcolor{stringliteral}{"{}estimatedDuration"{}}, info.estimatedDuration)}
\DoxyCodeLine{17460             .writeComment(\textcolor{stringliteral}{"{}All values in nano seconds"{}});}
\DoxyCodeLine{17461     \}}
\DoxyCodeLine{17462 }
\DoxyCodeLine{17463     \textcolor{keywordtype}{void} XmlReporter::benchmarkEnded(BenchmarkStats<> \textcolor{keyword}{const}\& benchmarkStats) \{}
\DoxyCodeLine{17464         m\_xml.startElement(\textcolor{stringliteral}{"{}mean"{}})}
\DoxyCodeLine{17465             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.mean.point.count())}
\DoxyCodeLine{17466             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.mean.lower\_bound.count())}
\DoxyCodeLine{17467             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.mean.upper\_bound.count())}
\DoxyCodeLine{17468             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.mean.confidence\_interval);}
\DoxyCodeLine{17469         m\_xml.endElement();}
\DoxyCodeLine{17470         m\_xml.startElement(\textcolor{stringliteral}{"{}standardDeviation"{}})}
\DoxyCodeLine{17471             .writeAttribute(\textcolor{stringliteral}{"{}value"{}}, benchmarkStats.standardDeviation.point.count())}
\DoxyCodeLine{17472             .writeAttribute(\textcolor{stringliteral}{"{}lowerBound"{}}, benchmarkStats.standardDeviation.lower\_bound.count())}
\DoxyCodeLine{17473             .writeAttribute(\textcolor{stringliteral}{"{}upperBound"{}}, benchmarkStats.standardDeviation.upper\_bound.count())}
\DoxyCodeLine{17474             .writeAttribute(\textcolor{stringliteral}{"{}ci"{}}, benchmarkStats.standardDeviation.confidence\_interval);}
\DoxyCodeLine{17475         m\_xml.endElement();}
\DoxyCodeLine{17476         m\_xml.startElement(\textcolor{stringliteral}{"{}outliers"{}})}
\DoxyCodeLine{17477             .writeAttribute(\textcolor{stringliteral}{"{}variance"{}}, benchmarkStats.outlierVariance)}
\DoxyCodeLine{17478             .writeAttribute(\textcolor{stringliteral}{"{}lowMild"{}}, benchmarkStats.outliers.low\_mild)}
\DoxyCodeLine{17479             .writeAttribute(\textcolor{stringliteral}{"{}lowSevere"{}}, benchmarkStats.outliers.low\_severe)}
\DoxyCodeLine{17480             .writeAttribute(\textcolor{stringliteral}{"{}highMild"{}}, benchmarkStats.outliers.high\_mild)}
\DoxyCodeLine{17481             .writeAttribute(\textcolor{stringliteral}{"{}highSevere"{}}, benchmarkStats.outliers.high\_severe);}
\DoxyCodeLine{17482         m\_xml.endElement();}
\DoxyCodeLine{17483         m\_xml.endElement();}
\DoxyCodeLine{17484     \}}
\DoxyCodeLine{17485 }
\DoxyCodeLine{17486     \textcolor{keywordtype}{void} XmlReporter::benchmarkFailed(std::string \textcolor{keyword}{const} \&error) \{}
\DoxyCodeLine{17487         m\_xml.scopedElement(\textcolor{stringliteral}{"{}failed"{}}).}
\DoxyCodeLine{17488             writeAttribute(\textcolor{stringliteral}{"{}message"{}}, error);}
\DoxyCodeLine{17489         m\_xml.endElement();}
\DoxyCodeLine{17490     \}}
\DoxyCodeLine{17491 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17492 }
\DoxyCodeLine{17493     CATCH\_REGISTER\_REPORTER( \textcolor{stringliteral}{"{}xml"{}}, XmlReporter )}
\DoxyCodeLine{17494 }
\DoxyCodeLine{17495 \} \textcolor{comment}{// end namespace Catch}}
\DoxyCodeLine{17496 }
\DoxyCodeLine{17497 \textcolor{preprocessor}{\#if defined(\_MSC\_VER)}}
\DoxyCodeLine{17498 \textcolor{preprocessor}{\#pragma warning(pop)}}
\DoxyCodeLine{17499 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17500 \textcolor{comment}{// end catch\_reporter\_xml.cpp}}
\DoxyCodeLine{17501 }
\DoxyCodeLine{17502 \textcolor{keyword}{namespace }Catch \{}
\DoxyCodeLine{17503     LeakDetector leakDetector;}
\DoxyCodeLine{17504 \}}
\DoxyCodeLine{17505 }
\DoxyCodeLine{17506 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17507 \textcolor{preprocessor}{\#pragma clang diagnostic pop}}
\DoxyCodeLine{17508 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17509 }
\DoxyCodeLine{17510 \textcolor{comment}{// end catch\_impl.hpp}}
\DoxyCodeLine{17511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17512 }
\DoxyCodeLine{17513 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{17514 \textcolor{comment}{// start catch\_default\_main.hpp}}
\DoxyCodeLine{17515 }
\DoxyCodeLine{17516 \textcolor{preprocessor}{\#ifndef \_\_OBJC\_\_}}
\DoxyCodeLine{17517 }
\DoxyCodeLine{17518 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_WCHAR) \&\& defined(CATCH\_PLATFORM\_WINDOWS) \&\& defined(\_UNICODE) \&\& !defined(DO\_NOT\_USE\_WMAIN)}}
\DoxyCodeLine{17519 \textcolor{comment}{// Standard C/C++ Win32 Unicode wmain entry point}}
\DoxyCodeLine{17520 \textcolor{keyword}{extern} \textcolor{stringliteral}{"{}C"{}} \textcolor{keywordtype}{int} wmain (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} * argv[], \textcolor{keywordtype}{wchar\_t} * []) \{}
\DoxyCodeLine{17521 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17522 \textcolor{comment}{// Standard C/C++ main entry point}}
\DoxyCodeLine{17523 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * argv[]) \{}
\DoxyCodeLine{17524 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17525 }
\DoxyCodeLine{17526     \textcolor{keywordflow}{return} Catch::Session().run( argc, argv );}
\DoxyCodeLine{17527 \}}
\DoxyCodeLine{17528 }
\DoxyCodeLine{17529 \textcolor{preprocessor}{\#else }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17530 }
\DoxyCodeLine{17531 \textcolor{comment}{// Objective-\/C entry point}}
\DoxyCodeLine{17532 \textcolor{keywordtype}{int} main (\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} * \textcolor{keyword}{const} argv[]) \{}
\DoxyCodeLine{17533 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17534     NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];}
\DoxyCodeLine{17535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17536 }
\DoxyCodeLine{17537     Catch::registerTestMethods();}
\DoxyCodeLine{17538     \textcolor{keywordtype}{int} result = Catch::Session().run( argc, (\textcolor{keywordtype}{char}**)argv );}
\DoxyCodeLine{17539 }
\DoxyCodeLine{17540 \textcolor{preprocessor}{\#if !CATCH\_ARC\_ENABLED}}
\DoxyCodeLine{17541     [pool drain];}
\DoxyCodeLine{17542 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17543 }
\DoxyCodeLine{17544     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{17545 \}}
\DoxyCodeLine{17546 }
\DoxyCodeLine{17547 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_OBJC\_\_}}
\DoxyCodeLine{17548 }
\DoxyCodeLine{17549 \textcolor{comment}{// end catch\_default\_main.hpp}}
\DoxyCodeLine{17550 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17551 }
\DoxyCodeLine{17552 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_IMPL\_ONLY)}}
\DoxyCodeLine{17553 }
\DoxyCodeLine{17554 \textcolor{preprocessor}{\#ifdef CLARA\_CONFIG\_MAIN\_NOT\_DEFINED}}
\DoxyCodeLine{17555 \textcolor{preprocessor}{\#  undef CLARA\_CONFIG\_MAIN}}
\DoxyCodeLine{17556 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17557 }
\DoxyCodeLine{17558 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE)}}
\DoxyCodeLine{17560 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17561 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17562 }
\DoxyCodeLine{17563 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17564 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17565 }
\DoxyCodeLine{17566 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}CATCH\_REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17567 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17568 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17569 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17570 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17571 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17572 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17573 }
\DoxyCodeLine{17574 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17575 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17576 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CATCH\_CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17577 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CATCH\_CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17578 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CATCH\_CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17579 }
\DoxyCodeLine{17580 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CATCH\_CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17581 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CATCH\_CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17582 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CATCH\_CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17583 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17584 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CATCH\_CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17585 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17586 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CATCH\_CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17587 }
\DoxyCodeLine{17588 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17589 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17590 }
\DoxyCodeLine{17591 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CATCH\_REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17592 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17593 }
\DoxyCodeLine{17594 \textcolor{preprocessor}{\#define CATCH\_INFO( msg ) INTERNAL\_CATCH\_INFO( "{}CATCH\_INFO"{}}, msg )}
\DoxyCodeLine{17595 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}CATCH\_UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17596 \textcolor{preprocessor}{\#define CATCH\_WARN( msg ) INTERNAL\_CATCH\_MSG( "{}CATCH\_WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17597 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CATCH\_CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17598 }
\DoxyCodeLine{17599 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17600 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17601 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17602 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17603 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17604 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17605 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17606 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17607 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}CATCH\_SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17608 }
\DoxyCodeLine{17609 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17610 }
\DoxyCodeLine{17611 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17612 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17613 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17614 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17615 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17616 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17617 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17618 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17619 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17620 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17621 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17622 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17623 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17624 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17625 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17626 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17627 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17628 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17629 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17630 }
\DoxyCodeLine{17631 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17632 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_ ,      \#\_\_VA\_ARGS\_\_ );     CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17633 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); CATCH\_SUCCEED( \#\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17634 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17635 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       CATCH\_REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17636 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) CATCH\_REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17637 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17638 }
\DoxyCodeLine{17639 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17640 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) CATCH\_TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17641 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17642 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17643 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17644 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17645 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17646 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17647 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17648 }
\DoxyCodeLine{17649 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17650 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17651 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17652 \textcolor{preprocessor}{\#define CATCH\_BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17653 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), name)}}
\DoxyCodeLine{17654 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17655 }
\DoxyCodeLine{17656 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17657 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17658 }
\DoxyCodeLine{17659 \textcolor{preprocessor}{\#define REQUIRE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_  )}
\DoxyCodeLine{17660 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}REQUIRE\_FALSE"{}}, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17661 }
\DoxyCodeLine{17662 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) INTERNAL\_CATCH\_THROWS( "{}REQUIRE\_THROWS"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17663 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}REQUIRE\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::Normal, expr )}
\DoxyCodeLine{17664 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}REQUIRE\_THROWS\_WITH"{}}, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17665 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17666 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}REQUIRE\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::Normal, matcher, expr )}
\DoxyCodeLine{17667 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17668 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}REQUIRE\_NOTHROW"{}}, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17669 }
\DoxyCodeLine{17670 \textcolor{preprocessor}{\#define CHECK( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17671 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_FALSE"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17672 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) INTERNAL\_CATCH\_IF( "{}CHECKED\_IF"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17673 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) INTERNAL\_CATCH\_ELSE( "{}CHECKED\_ELSE"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17674 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) INTERNAL\_CATCH\_TEST( "{}CHECK\_NOFAIL"{}}, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17675 }
\DoxyCodeLine{17676 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  INTERNAL\_CATCH\_THROWS( "{}CHECK\_THROWS"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17677 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) INTERNAL\_CATCH\_THROWS\_AS( "{}CHECK\_THROWS\_AS"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )}
\DoxyCodeLine{17678 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) INTERNAL\_CATCH\_THROWS\_STR\_MATCHES( "{}CHECK\_THROWS\_WITH"{}}, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17679 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17680 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) INTERNAL\_CATCH\_THROWS\_MATCHES( "{}CHECK\_THROWS\_MATCHES"{}}, exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )}
\DoxyCodeLine{17681 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17682 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) INTERNAL\_CATCH\_NO\_THROW( "{}CHECK\_NOTHROW"{}}, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17683 }
\DoxyCodeLine{17684 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17685 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}CHECK\_THAT"{}}, matcher, Catch::ResultDisposition::ContinueOnFailure, arg )}
\DoxyCodeLine{17686 }
\DoxyCodeLine{17687 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) INTERNAL\_CHECK\_THAT( "{}REQUIRE\_THAT"{}}, matcher, Catch::ResultDisposition::Normal, arg )}
\DoxyCodeLine{17688 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17689 }
\DoxyCodeLine{17690 \textcolor{preprocessor}{\#define INFO( msg ) INTERNAL\_CATCH\_INFO( "{}INFO"{}}, msg )}
\DoxyCodeLine{17691 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) INTERNAL\_CATCH\_UNSCOPED\_INFO( "{}UNSCOPED\_INFO"{}}, msg )}
\DoxyCodeLine{17692 \textcolor{preprocessor}{\#define WARN( msg ) INTERNAL\_CATCH\_MSG( "{}WARN"{}}, Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )}
\DoxyCodeLine{17693 \textcolor{preprocessor}{\#define CAPTURE( ... ) INTERNAL\_CATCH\_CAPTURE( INTERNAL\_CATCH\_UNIQUE\_NAME(capturer), "{}CAPTURE"{}},\_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17694 }
\DoxyCodeLine{17695 \textcolor{preprocessor}{\#define TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17696 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17697 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... ) INTERNAL\_CATCH\_METHOD\_AS\_TEST\_CASE( method, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17698 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) INTERNAL\_CATCH\_REGISTER\_TESTCASE( Function, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17699 \textcolor{preprocessor}{\#define SECTION( ... ) INTERNAL\_CATCH\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17700 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17701 \textcolor{preprocessor}{\#define FAIL( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17702 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) INTERNAL\_CATCH\_MSG( "{}FAIL\_CHECK"{}}, Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17703 \textcolor{preprocessor}{\#define SUCCEED( ... ) INTERNAL\_CATCH\_MSG( "{}SUCCEED"{}}, Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17704 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE()}}
\DoxyCodeLine{17705 }
\DoxyCodeLine{17706 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17707 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17708 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17709 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17710 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17711 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17712 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17713 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17714 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17715 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17716 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17717 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17718 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17719 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17720 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17721 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17722 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17723 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17724 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17725 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17726 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE( \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17727 \textcolor{preprocessor}{\#define TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_LIST\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17728 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17729 }
\DoxyCodeLine{17730 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_RUNTIME\_STATIC\_REQUIRE)}}
\DoxyCodeLine{17731 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       static\_assert(   \_\_VA\_ARGS\_\_,  \#\_\_VA\_ARGS\_\_ ); SUCCEED( \#\_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17732 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) static\_assert( !(\_\_VA\_ARGS\_\_), "{}!("{}} \#\_\_VA\_ARGS\_\_ "{})"{} ); SUCCEED( "{}!("{} \#\_\_VA\_ARGS\_\_ "{})"{} )}
\DoxyCodeLine{17733 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17734 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       REQUIRE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17735 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) REQUIRE\_FALSE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17736 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17737 }
\DoxyCodeLine{17738 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17739 }
\DoxyCodeLine{17740 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION( signature )}}
\DoxyCodeLine{17741 }
\DoxyCodeLine{17742 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17743 \textcolor{preprocessor}{\#define SCENARIO( ... ) TEST\_CASE( "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17744 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TEST\_CASE\_METHOD( className, "{}Scenario: "{}} \_\_VA\_ARGS\_\_ )}
\DoxyCodeLine{17745 }
\DoxyCodeLine{17746 \textcolor{preprocessor}{\#define GIVEN( desc )     INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}    Given: "{}} << desc )}
\DoxyCodeLine{17747 \textcolor{preprocessor}{\#define AND\_GIVEN( desc ) INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}And given: "{}} << desc )}
\DoxyCodeLine{17748 \textcolor{preprocessor}{\#define WHEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     When: "{}} << desc )}
\DoxyCodeLine{17749 \textcolor{preprocessor}{\#define AND\_WHEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{} And when: "{}} << desc )}
\DoxyCodeLine{17750 \textcolor{preprocessor}{\#define THEN( desc )      INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}     Then: "{}} << desc )}
\DoxyCodeLine{17751 \textcolor{preprocessor}{\#define AND\_THEN( desc )  INTERNAL\_CATCH\_DYNAMIC\_SECTION( "{}      And: "{}} << desc )}
\DoxyCodeLine{17752 }
\DoxyCodeLine{17753 \textcolor{preprocessor}{\#if defined(CATCH\_CONFIG\_ENABLE\_BENCHMARKING)}}
\DoxyCodeLine{17754 \textcolor{preprocessor}{\#define BENCHMARK(...) \(\backslash\)}}
\DoxyCodeLine{17755 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), INTERNAL\_CATCH\_GET\_1\_ARG(\_\_VA\_ARGS\_\_,,), INTERNAL\_CATCH\_GET\_2\_ARG(\_\_VA\_ARGS\_\_,,))}}
\DoxyCodeLine{17756 \textcolor{preprocessor}{\#define BENCHMARK\_ADVANCED(name) \(\backslash\)}}
\DoxyCodeLine{17757 \textcolor{preprocessor}{    INTERNAL\_CATCH\_BENCHMARK\_ADVANCED(INTERNAL\_CATCH\_UNIQUE\_NAME(\_\_\_\_C\_A\_T\_C\_H\_\_\_\_B\_E\_N\_C\_H\_\_\_\_), name)}}
\DoxyCodeLine{17758 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_ENABLE\_BENCHMARKING}}
\DoxyCodeLine{17759 }
\DoxyCodeLine{17760 \textcolor{keyword}{using} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17761 }
\DoxyCodeLine{17762 \textcolor{preprocessor}{\#else }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE}}
\DoxyCodeLine{17763 }
\DoxyCodeLine{17765 \textcolor{comment}{// If this config identifier is defined then all CATCH macros are prefixed with CATCH\_}}
\DoxyCodeLine{17766 \textcolor{preprocessor}{\#ifdef CATCH\_CONFIG\_PREFIX\_ALL}}
\DoxyCodeLine{17767 }
\DoxyCodeLine{17768 \textcolor{preprocessor}{\#define CATCH\_REQUIRE( ... )        (void)(0)}}
\DoxyCodeLine{17769 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_FALSE( ... )  (void)(0)}}
\DoxyCodeLine{17770 }
\DoxyCodeLine{17771 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17772 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17773 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17774 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17775 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17776 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17777 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17778 }
\DoxyCodeLine{17779 \textcolor{preprocessor}{\#define CATCH\_CHECK( ... )         (void)(0)}}
\DoxyCodeLine{17780 \textcolor{preprocessor}{\#define CATCH\_CHECK\_FALSE( ... )   (void)(0)}}
\DoxyCodeLine{17781 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_IF( ... )    if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17782 \textcolor{preprocessor}{\#define CATCH\_CHECKED\_ELSE( ... )  if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17783 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOFAIL( ... )  (void)(0)}}
\DoxyCodeLine{17784 }
\DoxyCodeLine{17785 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17786 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17787 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_WITH( expr, matcher )     (void)(0)}}
\DoxyCodeLine{17788 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17789 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17790 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17791 \textcolor{preprocessor}{\#define CATCH\_CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17792 }
\DoxyCodeLine{17793 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17794 \textcolor{preprocessor}{\#define CATCH\_CHECK\_THAT( arg, matcher )   (void)(0)}}
\DoxyCodeLine{17795 }
\DoxyCodeLine{17796 \textcolor{preprocessor}{\#define CATCH\_REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17797 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17798 }
\DoxyCodeLine{17799 \textcolor{preprocessor}{\#define CATCH\_INFO( msg )          (void)(0)}}
\DoxyCodeLine{17800 \textcolor{preprocessor}{\#define CATCH\_UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17801 \textcolor{preprocessor}{\#define CATCH\_WARN( msg )          (void)(0)}}
\DoxyCodeLine{17802 \textcolor{preprocessor}{\#define CATCH\_CAPTURE( msg )       (void)(0)}}
\DoxyCodeLine{17803 }
\DoxyCodeLine{17804 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17805 \textcolor{preprocessor}{\#define CATCH\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17806 \textcolor{preprocessor}{\#define CATCH\_METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17807 \textcolor{preprocessor}{\#define CATCH\_REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17808 \textcolor{preprocessor}{\#define CATCH\_SECTION( ... )}}
\DoxyCodeLine{17809 \textcolor{preprocessor}{\#define CATCH\_DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17810 \textcolor{preprocessor}{\#define CATCH\_FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17811 \textcolor{preprocessor}{\#define CATCH\_FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17812 \textcolor{preprocessor}{\#define CATCH\_SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17813 }
\DoxyCodeLine{17814 \textcolor{preprocessor}{\#define CATCH\_ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17815 }
\DoxyCodeLine{17816 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17817 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17818 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17819 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17820 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17821 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17822 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17823 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17824 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17825 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17826 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17827 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17828 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17829 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17830 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17831 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) CATCH\_TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17832 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17833 \textcolor{preprocessor}{\#define CATCH\_TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) CATCH\_TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17834 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17835 }
\DoxyCodeLine{17836 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17837 \textcolor{preprocessor}{\#define CATCH\_SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17838 \textcolor{preprocessor}{\#define CATCH\_SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{17839 \textcolor{preprocessor}{\#define CATCH\_GIVEN( desc )}}
\DoxyCodeLine{17840 \textcolor{preprocessor}{\#define CATCH\_AND\_GIVEN( desc )}}
\DoxyCodeLine{17841 \textcolor{preprocessor}{\#define CATCH\_WHEN( desc )}}
\DoxyCodeLine{17842 \textcolor{preprocessor}{\#define CATCH\_AND\_WHEN( desc )}}
\DoxyCodeLine{17843 \textcolor{preprocessor}{\#define CATCH\_THEN( desc )}}
\DoxyCodeLine{17844 \textcolor{preprocessor}{\#define CATCH\_AND\_THEN( desc )}}
\DoxyCodeLine{17845 }
\DoxyCodeLine{17846 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17847 \textcolor{preprocessor}{\#define CATCH\_STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17848 }
\DoxyCodeLine{17849 \textcolor{comment}{// If CATCH\_CONFIG\_PREFIX\_ALL is not defined then the CATCH\_ prefix is not required}}
\DoxyCodeLine{17850 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17851 }
\DoxyCodeLine{17852 \textcolor{preprocessor}{\#define REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17853 \textcolor{preprocessor}{\#define REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17854 }
\DoxyCodeLine{17855 \textcolor{preprocessor}{\#define REQUIRE\_THROWS( ... ) (void)(0)}}
\DoxyCodeLine{17856 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17857 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17858 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17859 \textcolor{preprocessor}{\#define REQUIRE\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17860 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17861 \textcolor{preprocessor}{\#define REQUIRE\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17862 }
\DoxyCodeLine{17863 \textcolor{preprocessor}{\#define CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17864 \textcolor{preprocessor}{\#define CHECK\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17865 \textcolor{preprocessor}{\#define CHECKED\_IF( ... ) if (\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17866 \textcolor{preprocessor}{\#define CHECKED\_ELSE( ... ) if (!(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{17867 \textcolor{preprocessor}{\#define CHECK\_NOFAIL( ... ) (void)(0)}}
\DoxyCodeLine{17868 }
\DoxyCodeLine{17869 \textcolor{preprocessor}{\#define CHECK\_THROWS( ... )  (void)(0)}}
\DoxyCodeLine{17870 \textcolor{preprocessor}{\#define CHECK\_THROWS\_AS( expr, exceptionType ) (void)(0)}}
\DoxyCodeLine{17871 \textcolor{preprocessor}{\#define CHECK\_THROWS\_WITH( expr, matcher ) (void)(0)}}
\DoxyCodeLine{17872 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17873 \textcolor{preprocessor}{\#define CHECK\_THROWS\_MATCHES( expr, exceptionType, matcher ) (void)(0)}}
\DoxyCodeLine{17874 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17875 \textcolor{preprocessor}{\#define CHECK\_NOTHROW( ... ) (void)(0)}}
\DoxyCodeLine{17876 }
\DoxyCodeLine{17877 \textcolor{preprocessor}{\#if !defined(CATCH\_CONFIG\_DISABLE\_MATCHERS)}}
\DoxyCodeLine{17878 \textcolor{preprocessor}{\#define CHECK\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17879 }
\DoxyCodeLine{17880 \textcolor{preprocessor}{\#define REQUIRE\_THAT( arg, matcher ) (void)(0)}}
\DoxyCodeLine{17881 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// CATCH\_CONFIG\_DISABLE\_MATCHERS}}
\DoxyCodeLine{17882 }
\DoxyCodeLine{17883 \textcolor{preprocessor}{\#define INFO( msg ) (void)(0)}}
\DoxyCodeLine{17884 \textcolor{preprocessor}{\#define UNSCOPED\_INFO( msg ) (void)(0)}}
\DoxyCodeLine{17885 \textcolor{preprocessor}{\#define WARN( msg ) (void)(0)}}
\DoxyCodeLine{17886 \textcolor{preprocessor}{\#define CAPTURE( msg ) (void)(0)}}
\DoxyCodeLine{17887 }
\DoxyCodeLine{17888 \textcolor{preprocessor}{\#define TEST\_CASE( ... )  INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17889 \textcolor{preprocessor}{\#define TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17890 \textcolor{preprocessor}{\#define METHOD\_AS\_TEST\_CASE( method, ... )}}
\DoxyCodeLine{17891 \textcolor{preprocessor}{\#define REGISTER\_TEST\_CASE( Function, ... ) (void)(0)}}
\DoxyCodeLine{17892 \textcolor{preprocessor}{\#define SECTION( ... )}}
\DoxyCodeLine{17893 \textcolor{preprocessor}{\#define DYNAMIC\_SECTION( ... )}}
\DoxyCodeLine{17894 \textcolor{preprocessor}{\#define FAIL( ... ) (void)(0)}}
\DoxyCodeLine{17895 \textcolor{preprocessor}{\#define FAIL\_CHECK( ... ) (void)(0)}}
\DoxyCodeLine{17896 \textcolor{preprocessor}{\#define SUCCEED( ... ) (void)(0)}}
\DoxyCodeLine{17897 \textcolor{preprocessor}{\#define ANON\_TEST\_CASE() INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ))}}
\DoxyCodeLine{17898 }
\DoxyCodeLine{17899 \textcolor{preprocessor}{\#ifndef CATCH\_CONFIG\_TRADITIONAL\_MSVC\_PREPROCESSOR}}
\DoxyCodeLine{17900 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17901 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17902 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_)}}
\DoxyCodeLine{17903 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17904 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17905 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17906 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17907 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17908 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{17909 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17910 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_SIG( ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_SIG\_NO\_REGISTRATION(\_\_VA\_ARGS\_\_) )}}
\DoxyCodeLine{17911 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17912 \textcolor{preprocessor}{\#define TEMPLATE\_TEST\_CASE\_METHOD\_SIG( className, ... ) INTERNAL\_CATCH\_EXPAND\_VARGS( INTERNAL\_CATCH\_TEMPLATE\_TEST\_CASE\_METHOD\_SIG\_NO\_REGISTRATION(className, \_\_VA\_ARGS\_\_ ) )}}
\DoxyCodeLine{17913 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17914 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_SIG( ... ) TEMPLATE\_TEST\_CASE( \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17915 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17916 \textcolor{preprocessor}{\#define TEMPLATE\_PRODUCT\_TEST\_CASE\_METHOD\_SIG( className, ... ) TEMPLATE\_TEST\_CASE\_METHOD( className, \_\_VA\_ARGS\_\_ )}}
\DoxyCodeLine{17917 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17918 }
\DoxyCodeLine{17919 \textcolor{preprocessor}{\#define STATIC\_REQUIRE( ... )       (void)(0)}}
\DoxyCodeLine{17920 \textcolor{preprocessor}{\#define STATIC\_REQUIRE\_FALSE( ... ) (void)(0)}}
\DoxyCodeLine{17921 }
\DoxyCodeLine{17922 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17923 }
\DoxyCodeLine{17924 \textcolor{preprocessor}{\#define CATCH\_TRANSLATE\_EXCEPTION( signature ) INTERNAL\_CATCH\_TRANSLATE\_EXCEPTION\_NO\_REG( INTERNAL\_CATCH\_UNIQUE\_NAME( catch\_internal\_ExceptionTranslator ), signature )}}
\DoxyCodeLine{17925 }
\DoxyCodeLine{17926 \textcolor{comment}{// "{}BDD-\/style"{} convenience wrappers}}
\DoxyCodeLine{17927 \textcolor{preprocessor}{\#define SCENARIO( ... ) INTERNAL\_CATCH\_TESTCASE\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ) )}}
\DoxyCodeLine{17928 \textcolor{preprocessor}{\#define SCENARIO\_METHOD( className, ... ) INTERNAL\_CATCH\_TESTCASE\_METHOD\_NO\_REGISTRATION(INTERNAL\_CATCH\_UNIQUE\_NAME( \_\_\_\_C\_A\_T\_C\_H\_\_\_\_T\_E\_S\_T\_\_\_\_ ), className )}}
\DoxyCodeLine{17929 }
\DoxyCodeLine{17930 \textcolor{preprocessor}{\#define GIVEN( desc )}}
\DoxyCodeLine{17931 \textcolor{preprocessor}{\#define AND\_GIVEN( desc )}}
\DoxyCodeLine{17932 \textcolor{preprocessor}{\#define WHEN( desc )}}
\DoxyCodeLine{17933 \textcolor{preprocessor}{\#define AND\_WHEN( desc )}}
\DoxyCodeLine{17934 \textcolor{preprocessor}{\#define THEN( desc )}}
\DoxyCodeLine{17935 \textcolor{preprocessor}{\#define AND\_THEN( desc )}}
\DoxyCodeLine{17936 }
\DoxyCodeLine{17937 \textcolor{keyword}{using} \mbox{\hyperlink{class_catch_1_1_detail_1_1_approx}{Catch::Detail::Approx}};}
\DoxyCodeLine{17938 }
\DoxyCodeLine{17939 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17940 }
\DoxyCodeLine{17941 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// ! CATCH\_CONFIG\_IMPL\_ONLY}}
\DoxyCodeLine{17942 }
\DoxyCodeLine{17943 \textcolor{comment}{// start catch\_reenable\_warnings.h}}
\DoxyCodeLine{17944 }
\DoxyCodeLine{17945 }
\DoxyCodeLine{17946 \textcolor{preprocessor}{\#ifdef \_\_clang\_\_}}
\DoxyCodeLine{17947 \textcolor{preprocessor}{\#    ifdef \_\_ICC }\textcolor{comment}{// icpc defines the \_\_clang\_\_ macro}}
\DoxyCodeLine{17948 \textcolor{preprocessor}{\#        pragma warning(pop)}}
\DoxyCodeLine{17949 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{17950 \textcolor{preprocessor}{\#        pragma clang diagnostic pop}}
\DoxyCodeLine{17951 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{17952 \textcolor{preprocessor}{\#elif defined \_\_GNUC\_\_}}
\DoxyCodeLine{17953 \textcolor{preprocessor}{\#    pragma GCC diagnostic pop}}
\DoxyCodeLine{17954 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{17955 }
\DoxyCodeLine{17956 \textcolor{comment}{// end catch\_reenable\_warnings.h}}
\DoxyCodeLine{17957 \textcolor{comment}{// end catch.hpp}}
\DoxyCodeLine{17958 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TWOBLUECUBES\_SINGLE\_INCLUDE\_CATCH\_HPP\_INCLUDED}}
\DoxyCodeLine{17959 }

\end{DoxyCode}
